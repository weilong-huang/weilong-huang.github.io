<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>9-27个人总结</title>
    <url>/2017/11/29/9-27%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li><p><code>res.json()</code>是返回给客户端一个 json 对象,但是并不会就此停下里,需要在前面加上 return, 才会停止整个 API 或者方法.</p>
</li>
<li><p>Array 对象有 unshift()和 push()方法,组合成队列,头出尾进</p>
<ul>
<li>还有 push() 和 pop() 方法组合成栈,尾进尾出,</li>
<li>也可以用 unshift()和 pop() 方法组合成头进尾出.是另一种队列,同理还可以有头进头出,shift() 和 unshift()<span id="more"></span></li>
</ul>
</li>
<li><p>Promise 的使用: 把异步操作全部封装成 Promise, 然后使用 then() 传递参数,这样可以保证操作的先后顺序,而不会因为异步而顺序错乱.</p>
</li>
<li><p>被 reject 的参数也会传递给下一个 then 里,所以所有的错误都要被 reject 这样最后才会被 catch</p>
</li>
<li><p>异步尤其要注意循环!循环往往会打乱异步操作的顺序.使用 async 库可以一定程序上去避免这个问题.async.each(arr,(item, callback)&#x3D;&gt;{},(err) &#x3D;&gt;{})会在循环中去异步执行,但是整个过程完成后会执行 err&#x3D;&gt;()的这个方法参数,简单的说就是第一个参数是数组,第二个参数是数组的项和 callback, 第三个参数是循环执行完后执行的操作.</p>
</li>
<li><p>但是 async 还是有问题,他的整个过程是异步的,如果要求返回是数组是按原数组的顺序返回, async.each() 是做不到的,也许使用 Promise.all 可以,以后可以试验一下.</p>
</li>
<li><p>在写代码之前先打一下草稿,把请求的数据格式和返回的数据格式和前端定下来,以免以后修改.</p>
</li>
<li><p>还可以思考一下哪些操作会使用的比较频繁,比如提取用户某些信息,根据 userId 获取用户信息,根据手机号获取用户信息,通过 roomId 获取用户信息这种,尤其是代码量大的操作,像给数组返回数组,这种最好是封装成一个 Promise 的方法,以后写接口时会大量的复用</p>
</li>
<li><p>甚至可以和前端定好返回是状态码–&gt; status:200||500||1001,这样的哪个代码代表什么意思,这样就不用特意用 msg 去说明情况,msg 是用来提示用户或者描述具体问题的</p>
</li>
<li><p>活用 lodash,_.get(obj,’path’, default), <em>.isEmpty(),</em>.isUndefined()等等,有些方法没有结果会返回 undefined 有些则是空对象或者空数组,这些都可以减少代码的复杂性,而提高代码的可阅读性,尤其是保证代码的安全性,不会因为 undefined.get()中 can’t read the propotype of undefined 而报错,也不用单独写算法去检测对象是不是空或者 undefined 或者是不是 Array</p>
</li>
<li><p>把文件封装成 module,在文件的最后一定要加<code>module.exports = router;</code>这样在其他文件里才可以获取的到,如果要 exports 的不止一个对象,需要写成对象<code>module.exports = &#123;router:router, func : someFunction&#125;;</code>这样写的话在引入时也要写明<code>const heroMsg = require(&#39;./hok&#39;).heroMap;</code></p>
</li>
<li><p>中间件是指在路由中过程中去执行的方法,<code>router.get(&#39;/audio/userRoom&#39;,jwt.verify,(req, res) =&gt; &#123;&#125;)</code>,如果报错这个 API 就不会继续执行下去,如果没错才会继续,不需要写参数(),req 会自动被获取</p>
</li>
<li><p>要理解 app.use() 到底做了什么事,两个参数分别代表什么意思.</p>
</li>
<li><p>灵巧的使用 Map 数据结构, Map 是一个完完全全的键值对, object 是字符串对应值,通过.str 来调用,而 Map 更像是数组一样,通过[key]来引用,这样来获取一些非常规的键值对组合是非常有用的.</p>
</li>
<li><p>Set 类型也可以学着使用,一种新型的数组,不过这个数组可以用</p>
<ul>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
<li>最重要的一点, Set 类型成员不能有重复,所以可以用来最简单代码去重</li>
</ul>
</li>
<li><p>比起第三方数据存储,用自己本地的数据存储显然要快更多.减少网络通讯时间,所以以后写后端,数据部分最好用自己服务器本地的 MySQL 或者 MongoDB, 这样怎么读写都是在本地,而不用担心查数据库的次数多了,会带来的网络通讯延迟导致的 API 性能异常差的问题,毕竟本地数据库读写比网络数据库读写快不是一点点,所以读写量大的数据必须放在服务器本地.</p>
</li>
<li><p>方法分类要做好,比如按功能模块分,比如按数据库操作分,又比如按数据库文件对象分.我觉得可以把对数据格式化,提取时间,获取随机数,数字精度处理这样所有文件的都有可能用到的方法写在一个文件里,然后把数据库操作封装到一个文件里,类似种种</p>
</li>
<li><p>如果有时间的话,可以用测试先行模式,先把单元测试写好,这样每次修改代码只要跑一次单元测试就知道这次的代码修改有没有引起其他API 或者方法的错误.减少提交错误代码到 github 再提交到服务器的这种失误,这样非常浪费时间</p>
</li>
<li><p>pm2真的是个好东西, pm2 start xxx 用 pm2起一个后台服务,这样即可用监控进程的内存 CPU 使用情况,又可以持久化的在后台运行,要重启服务也非常方便 pm2 restart xxx</p>
</li>
<li><p>redis 是一种非常快的键值对临时数据库,也有 GUI 可以查看数据,不过要收费,如果需要快速的缓存数据,可以用 redis, 不过 redis 不知道怎么存储多个对象的数据目前只会 redis.set(‘key’,’value’)和 redis.get(‘key’, ‘value’),如果要像数据库那也分表,那要怎么做?</p>
</li>
<li><p>lsof -i tcp:port &#x2F;&#x2F;把port换成端口号<br>找到PID以后 kill PID &#x2F;&#x2F;（进程的PID，如2044）</p>
</li>
<li><p>远程 SSH 登录服务器<code>ssh root@112.74.40.136 -p 4999</code>然后回车输入密码</p>
</li>
<li><p>其实部署最好是写成一个. sh 脚本,这样下次重启电脑以后也可以一键部署,或者在修改了本地代码以后一键更新部署,不过暂时不会写</p>
</li>
<li><p>遇到什么不过马上用 thing3记录下来,不要打断当前的 codeing, 等代码写完以后再去处理bug 或者问题</p>
</li>
<li><p>用 htop 指令监控 Linux 的资源使用情况</p>
</li>
<li><p>用 find &#x2F; -name 查找 Linux 中某文件的位置</p>
</li>
</ul>
]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
  </entry>
  <entry>
    <title>CSS Flex 布局</title>
    <url>/2018/06/13/CSS%20FlexBox%20%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="Flexbox-布局有2个关键的概念"><a href="#Flexbox-布局有2个关键的概念" class="headerlink" title="Flexbox 布局有2个关键的概念"></a>Flexbox 布局有2个关键的概念</h1><ul>
<li>Flex容器（Flex Container） ：父元素显式设置了 display:flex</li>
<li>Flex项目（Flex Items） ：Flex容器内的子元素</li>
</ul>
<p>使用 Flexbox 布局,容器尽量不要设置固定的 width, 可以设置为 auto<br>在 Flexbox中将方向分为水平的主轴和竖直的侧轴<br><img src="http://p04c6djlz.bkt.clouddn.com//18-6-7/62715710.jpg"></p>
<h1 id="其中Flex容器有以下参数"><a href="#其中Flex容器有以下参数" class="headerlink" title="其中Flex容器有以下参数:"></a>其中Flex容器有以下参数:</h1><blockquote>
<p>flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content</p>
</blockquote>
<span id="more"></span>
<p>每个参数都有自己的含义:</p>
<h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction:"></a>flex-direction:</h2><p><strong>指定容器内部项目的方向</strong></p>
<blockquote>
<p>row || column || row-reverse || column-reverse;</p>
</blockquote>
<ul>
<li>row: 水平从左到右</li>
<li>column: 垂直从上到下</li>
<li>row-reverse: 水平从右到左</li>
<li>column-reverse: 垂直从下到上</li>
</ul>
<p><img src="http://p04c6djlz.bkt.clouddn.com//18-6-7/55713609.jpg"></p>
<h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap:"></a>flex-wrap:</h2><p><strong>指定容器内部项目是否换行</strong></p>
<blockquote>
<p>wrap || nowrap || wrap-reverse;</p>
</blockquote>
<ul>
<li>wrap: 自适应屏幕大小,自动换行 (从左到右,从上到下)</li>
<li>nowrap: 不换行</li>
<li>wrap-reverse: 自动换行(从左到右,从下到上,如图)<br> <img src="http://p04c6djlz.bkt.clouddn.com//18-6-7/2247062.jpg"></li>
</ul>
<h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow:"></a>flex-flow:</h2><p><strong>是 direction 和 wrap 的速写,接收2个参数,第一个是 direction 第二个是 wrap</strong></p>
<blockquote>
<p>row || column || row-reverse || column-reverse;<br>wrap || nowrap || wrap-reverse;</p>
</blockquote>
<p>两两随意搭配,共有12种</p>
<h3 id="值得注意的是flex-wrap-只考虑换行不换行-而具体的方向最好让-flex-direction-来做"><a href="#值得注意的是flex-wrap-只考虑换行不换行-而具体的方向最好让-flex-direction-来做" class="headerlink" title="值得注意的是flex-wrap 只考虑换行不换行,而具体的方向最好让 flex-direction 来做"></a>值得注意的是flex-wrap 只考虑换行不换行,而具体的方向最好让 flex-direction 来做</h3><p>比如从右向左排列,换行: row-reverse wrap<br><img src="http://p04c6djlz.bkt.clouddn.com//2018/6/7-%E4%B8%8A%E5%8D%8810:48:14.png"></p>
<h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content:"></a>justify-content:</h2><p><strong>指定容器内部项目的对齐方式,很像text-align,参考的标准是主轴</strong></p>
<blockquote>
<p>flex-start || flex-end || center || space-between || space-around</p>
</blockquote>
<ul>
<li>flex-start 向左对齐</li>
<li>flex-end 向右对齐</li>
<li>center 中间对齐</li>
<li>space-between 向外对齐 </li>
<li>space-around 分散性对齐</li>
</ul>
<h3 id="需要提一下后面三种情况的不同"><a href="#需要提一下后面三种情况的不同" class="headerlink" title="需要提一下后面三种情况的不同"></a>需要提一下后面三种情况的不同</h3><h4 id="center"><a href="#center" class="headerlink" title="center:"></a>center:</h4><p><img src="http://p04c6djlz.bkt.clouddn.com//2018/6/7-%E4%B8%8A%E5%8D%8810:57:05.png"></p>
<h4 id="space-between"><a href="#space-between" class="headerlink" title="space-between:"></a>space-between:</h4><p><img src="http://p04c6djlz.bkt.clouddn.com//A0F5288C67AEA1D76B09C5552EC42D66.jpg"></p>
<h4 id="space-around"><a href="#space-around" class="headerlink" title="space-around:"></a>space-around:</h4><p><img src="http://p04c6djlz.bkt.clouddn.com//90A99EE2F363FFC34338526C0BEDDB7B.jpg"></p>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p><strong>align-items就是justify-content的竖直版本,参考的标准是侧轴</strong></p>
<blockquote>
<p>flex-start || flex-end || center || stretch || baseline</p>
</blockquote>
<ul>
<li>flex-start 向上对齐</li>
<li>flex-end 向下对齐</li>
<li>center 垂直中央对齐</li>
<li>stretch(默认) 占满容器</li>
<li>baseline 基线对齐(第一行文字的下划线)</li>
</ul>
<p><img src="http://p04c6djlz.bkt.clouddn.com//18-6-7/80183898.jpg"></p>
<h3 id="详细讲一下-stretch-和-baseline"><a href="#详细讲一下-stretch-和-baseline" class="headerlink" title="详细讲一下 stretch 和 baseline"></a>详细讲一下 stretch 和 baseline</h3><h4 id="stretch-默认值"><a href="#stretch-默认值" class="headerlink" title="stretch(默认值)"></a>stretch(默认值)</h4><p>如果项目未设置高度或设为auto，将占满整个容器的高度。</p>
<h4 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h4><p>项目的第一行文字的基线对齐</p>
<h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p><strong>定义了多行的对齐方式。如果项目只有一行，该属性不起作用。</strong></p>
<blockquote>
<p>flex-start | flex-end | center | space-between | space-around | stretch;</p>
</blockquote>
<p>多行且没有设置 align-content 的时候是这样的(align-content: stretch;(默认))<br><img src="http://p04c6djlz.bkt.clouddn.com//2018/6/7-%E4%B8%8A%E5%8D%8811:17:57.png"><br>会根据容器的高度,平均分隔成两层</p>
<ul>
<li>flex-start: 多行一起向上对齐</li>
<li>flex-end: 多行一起向下对齐</li>
<li>center: 多行一起中央对齐</li>
<li>space-between: 多行一起向外对齐,这里的外是指上下</li>
<li>space-around: 多行一起分散对齐</li>
<li>stretch: 根据容器的高度,平均分隔成两层</li>
</ul>
<p><strong>其实简单的说,就是把一整行当做一个项目看,然后把画面选择90度以后的align-items</strong><br><img src="http://p04c6djlz.bkt.clouddn.com//18-6-7/76328567.jpg"></p>
<h1 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h1><blockquote>
<p>order || flex-grow || flex-shrink || flex-basis</p>
</blockquote>
<h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p><strong>给项目排序,数字越小(可以为负数)优先级最高,同优先级的情况下,按默认先后顺序排序</strong></p>
<h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p><strong>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</strong><br>在有剩余空间的前提下,放大一定的倍数.这里指的是对剩余空间的使用率,如果没有剩余空间写多少都没用.</p>
<h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p><strong>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</strong></p>
<h2 id="flex-grow-和-flex-shrink"><a href="#flex-grow-和-flex-shrink" class="headerlink" title="flex-grow 和 flex-shrink"></a>flex-grow 和 flex-shrink</h2><p>指的都是对剩余空间的利用率而不是直接的放大缩小,最起码会保证项目本身的 width属性的宽度,当然,如果项目的 width 是 auto 的话就是按比例放大缩小了</p>
<h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p><strong>在调整flex-grow 和 flex-shrink之前的基本宽度</strong><br><em>优先级似乎高于 width? 可能还和 CSS 的选择器优先级有关?</em></p>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p><strong>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</strong><br>阮一峰建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p><strong>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-item</code>s属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</strong></p>
<blockquote>
<p>auto | flex-start | flex-end | center | baseline | stretch<br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致</p>
</blockquote>
<p><img src="http://p04c6djlz.bkt.clouddn.com//18-6-7/73502504.jpg"></p>
<p>参考:<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰版</a><br><a href="http://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html?utm_source=tuicool&utm_medium=referral">大漠 W3CPlus 版</a><br><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox">英文版</a> </p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 选择器及优先级</title>
    <url>/2018/06/22/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h1><p>其实，CSS有自己的优先级计算公式，而不仅仅是行间&gt;内部&gt;外部样式；ID&gt;class&gt;元素。</p>
<h2 id="一、选择器类型"><a href="#一、选择器类型" class="headerlink" title="一、选择器类型"></a>一、选择器类型</h2><ol>
<li>ID———#id</li>
<li>class——.class</li>
<li>标签——-p</li>
<li>通用——-*</li>
<li>属性——-[type&#x3D;”text”]</li>
<li>伪类——-：hover</li>
<li>伪元素—–::first-line</li>
<li>子选择器、相邻选择器</li>
</ol>
<h2 id="二、优先级计算"><a href="#二、优先级计算" class="headerlink" title="二、优先级计算"></a>二、优先级计算</h2><ol>
<li>第一等：代表内联样式，如: style&#x3D;””，权值为1000。</li>
<li>第二等：代表ID选择器，如：#content，权值为0100。</li>
<li>第三等：代表类，伪类和属性选择器，如.content，权值为0010。</li>
<li>第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。</li>
<li>通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。</li>
<li>继承的样式没有权值。</li>
</ol>
<h2 id="三、优先级规则"><a href="#三、优先级规则" class="headerlink" title="三、优先级规则"></a>三、优先级规则</h2><ol>
<li><strong>1,0,0,0 &gt; 0,99,99,99。也就是说从左往右逐个等级比较，前一等级相等才往后比。</strong></li>
<li><strong>无论是行间、内部和外部样式，都是按照这个规则来进行比较。而不是直观的行间&gt;内部&gt;外部样式；ID&gt;class&gt;元素。之所以有这样的错觉，是因为确实行间为第一等的权重，所以它的权重是最高的。而内部样式可能一般写在了外部样式引用了之后，所以覆盖掉了之前的。</strong></li>
<li><strong>在权重相同的情况下，后面的样式会覆盖掉前面的样式。</strong></li>
<li><strong>通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先。</strong></li>
</ol>
<h2 id="四、！important"><a href="#四、！important" class="headerlink" title="四、！important"></a>四、！important</h2><p><strong>!important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:red <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">    &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;&quot;</span>&gt;</span>我显示红色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、实例"><a href="#五、实例" class="headerlink" title="五、实例"></a>五、实例</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">color</span>: yellow;&#125; <span class="comment">/*特殊性值：0,0,0,1*/</span></span><br><span class="line"> <span class="selector-tag">div</span> <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>: green;&#125; <span class="comment">/*特殊性值：0,0,0,2*/</span></span><br><span class="line"><span class="selector-class">.demo</span> <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>: black;&#125; <span class="comment">/*特殊性值：0,0,1,1*/</span></span><br><span class="line"> <span class="selector-class">.demo</span> <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span>&#123;<span class="attribute">color</span>: blue;&#125; <span class="comment">/*特殊性值：0,0,2,1*/</span></span><br><span class="line"> <span class="selector-class">.demo</span> *<span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span>&#123;<span class="attribute">color</span>: grey;&#125; <span class="comment">/*特殊性值：0,0,2,0*/</span></span><br><span class="line"> <span class="selector-id">#demo</span> <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>: orange;&#125; <span class="comment">/*特殊性值：0,1,0,1*/</span></span><br><span class="line"> <span class="selector-tag">div</span><span class="selector-id">#demo</span> <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>: red;&#125; <span class="comment">/*特殊性值：0,1,0,2*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>第一条应该是黄色<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--适用第1行规则--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;第二条应该是蓝色&quot;</span> /&gt;</span><span class="comment">&lt;!--适用第4、5行规则，第4行优先级高--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>第三条应该是黑色<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!--适用第2、3行规则，第3行优先级高--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>第四条应该是红色<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!--适用第5、6行规则，第6行优先级高--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 布局</title>
    <url>/2018/06/13/CSS%20%E5%B8%83%E5%B1%80position%20float%20%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>盒模型就是 margin border padding content<br><img src="http://p04c6djlz.bkt.clouddn.com//18-6-13/52283840.jpg"><br>因为存在 margin,border和padding,元素可能会变得和预想的不一样大小,在 CSS 中加入以下代码能避免这样的事</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    -webkit-<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    -moz-<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用* 通配符选择器,选择所有元素,加上 border-box,元素就会变得以设置的长度会显示标准, margin会在 width 之外, border 和padding 会在 width 以内</p>
<h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><span id="more"></span>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fancy</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid seagreen;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;!<span class="attr">--position</span>: relative;--&gt; </span><br><span class="line">    &lt;!<span class="attr">--top</span>: -<span class="number">20px</span>;--&gt;</span><br><span class="line">    &lt;!<span class="attr">--left</span>: <span class="number">20px</span>;--&gt;</span><br><span class="line">    &lt;!<span class="attr">--background-color</span>: sienna;--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="static"><a href="#static" class="headerlink" title="static:"></a>static:</h2><p>  static 是 position 的默认值,意思是不会被 position 特殊定位,只按正常的方式定位<br><img src="http://p04c6djlz.bkt.clouddn.com//18-6-13/89694992.jpg"></p>
<h2 id="relative-它的偏移是相对于原先在文档流中的位置"><a href="#relative-它的偏移是相对于原先在文档流中的位置" class="headerlink" title="relative: 它的偏移是相对于原先在文档流中的位置"></a>relative: 它的偏移是相对于原先在文档流中的位置</h2><p>  relative是相对定位,相对参考值是他本来position:static 时的位置.其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。<br>  <img src="http://p04c6djlz.bkt.clouddn.com//18-6-13/72993159.jpg"></p>
<h2 id="fixed-它的偏移量是相对于视窗的"><a href="#fixed-它的偏移量是相对于视窗的" class="headerlink" title="fixed: 它的偏移量是相对于视窗的"></a>fixed: 它的偏移量是相对于视窗的</h2><p>  fixed是固定定位.一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。<br>  <strong>不一样的是 relative 的参考对象是原来它应该在的地方, fixed 是绝对定位,参考对象是整个浏览器当前显示的部分</strong></p>
<h2 id="absolute-它的偏移量是相对于最近一级position不是static的祖先元素的"><a href="#absolute-它的偏移量是相对于最近一级position不是static的祖先元素的" class="headerlink" title="absolute:它的偏移量是相对于最近一级position不是static的祖先元素的"></a>absolute:它的偏移量是相对于最近一级position不是static的祖先元素的</h2><p>  absolute 是最棘手的position值。首先先记住“positioned”元素是指 position 值不是 static 的元素。然后是 absolute 的规则:<br>  absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。<br>  <img src="http://p04c6djlz.bkt.clouddn.com//18-6-13/29961621.jpg"><br>  这里的主块是relative,1是absolute,2是relative</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">   <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="selector-class">.simple</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid salmon;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fancy</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: <span class="number">2</span>;</span><br><span class="line">   <span class="attribute">top</span>: -<span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: sienna;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid seagreen;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">   <span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="float"><a href="#float" class="headerlink" title="float"></a>float</h1><p>  浮动也是一种经常用来布局的属性.Float 可用于实现文字环绕图片,就像 word 里面那种一样.<br>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1em</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="http://p04c6djlz.bkt.clouddn.com//1528703198681.jpg"></p>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>  clear 是个很神奇的东西,在块元素中加入float 之后,这个块就会变成一个浮动的块,在它后面的元素会根据他的存在而变化,但是如果我们想换行,不让第一个浮动元素影响自己的话,就需要加上<code> clear: both;</code> ,然后第二个元素就会跑到下一行里,按原来的性质来定位.</p>
<h2 id="clearfix-hack"><a href="#clearfix-hack" class="headerlink" title="clearfix hack"></a>clearfix hack</h2><p>我们知道，一个块级元素如果没有设置height，其height是由子元素撑开的。对子元素使用了浮动之后，子元素会脱离标准文档流，也就是说，父级元素中没有内容可以撑开其高度，这样父级元素的height就会被忽略，这就是所谓的高度塌陷。要解决这样的问题，我们就是要使用清除浮动。</p>
<p>这个图片比包含它的元素还高， 而且它是浮动的，于是它就溢出到了容器外面<br><img src="http://p04c6djlz.bkt.clouddn.com//1528705376831.jpg"></p>
<p>这个时候需要在他的容器上加上这一句</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: auto;  //或者</span><br><span class="line"><span class="attribute">overflow</span>: hidden;  // 或者在需要结尾处增加一个清除浮动的块元素,例如:</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">clear: both; </span><br><span class="line">当然也可以加载下面第一个不需要浮动的元素里,但由于代码最好是可复用的,所以增加这个清楚浮动块元素更加好</span><br></pre></td></tr></table></figure>
<p><img src="http://p04c6djlz.bkt.clouddn.com//18-6-11/63454385.jpg"></p>
<h2 id="如何使用-float-做布局"><a href="#如何使用-float-做布局" class="headerlink" title="如何使用 float 做布局"></a>如何使用 float 做布局</h2><p>左边用 <code>float: left;width: 100px;</code> 右边用 <code>margin-right:100px;</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid saddlebrown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://p04c6djlz.bkt.clouddn.com//18-6-11/60196164.jpg"></p>
<p><strong>还可以用百分比控制宽度,但是不能长度超过100%,因为经常还要算上边框的宽度,50%加上50%就会超出屏幕宽度,这时就会自动换行</strong></p>
<h1 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h1><p>如果是要做成一行连续的浮动元素,可以用<code>display: inline-block;</code>行内块元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.after-box</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://p04c6djlz.bkt.clouddn.com//18-6-11/7294191.jpg"><br>这个时候如果用内行块元素:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果完全相同,而且下一行的元素也不需要加上 <code>clear: left;</code><br>如果用 inline-block 来布局要注意一下几点:</p>
<ul>
<li>vertical-align 属性会影响到 inline-block 元素，你可能会把它的值设置为 top 。</li>
<li>你需要设置每一列的宽度</li>
<li>如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙</li>
<li>解决换行符导致是空隙:在inline-block的父元素中设置样式font-size：0；letter-spacing: -4px; 然后设置inline-block的所有兄弟元素 font-size：值；letter-spacing: 值px;  恢复正常的显示。</li>
<li>如果用百分比做长度,注意如果有边框,那么两个长度的百分比相加可能会大于100%,从而第二个元素跑到第二行去.(30%+1px+70%+1px&gt;100%)</li>
<li>inline-block默认是基线对齐的，而inline-block的基线又跟文本基线一致，所以在内容不同的时候并不能水平对齐。只需要用vertical-align显式声明一下top&#x2F;bottom&#x2F;middle对齐即可</li>
</ul>
<p>这里补充一下基线的内容，没你想的那么简单哦。分有文字和无文字两种情况：</p>
<ul>
<li>无文字：容器的margin-bottom下边缘。与容器内部的元素没一毛钱关系。</li>
<li>有文字：最后一行文字的下边缘，跟文字块（p,h等）的margin、padding没关系！注意是最后一行，无论文字在什么子对象容器内在什么位置都没关系，浏览器会找到最后一行文字对齐底部。</li>
</ul>
<p>你们感受一下：<br><img src="http://p04c6djlz.bkt.clouddn.com//18-6-12/96100507.jpg"></p>
<h2 id="警示"><a href="#警示" class="headerlink" title="警示"></a><strong>警示</strong></h2><p>inline-block的基线是最后一行文字的底部，flex里面的基线是第一行文字的底部<br><img src="http://p04c6djlz.bkt.clouddn.com//18-6-13/92907686.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS 6 环境配置</title>
    <url>/2017/11/29/CentOS%206%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>一. 首先安装 Git :</p>
<blockquote>
<p>sudo yum install git<br>二. 安装 NVM: </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</span><br></pre></td></tr></table></figure>
<p><strong>重启 shell 以后生效</strong><br>三.使用 NVM 安装 node, 推荐安装8.0以后的版本然后设为默认</p>
<blockquote>
<p>nvm install 8.8.1<br>nvm alias default 8.8.1</p>
</blockquote>
<span id="more"></span>
<p>然后安装阿里镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>四.安装 MySQL</p>
<p>用系统自带的yum命令来安装MySQL 5.6，下面记录一下整个安装、配置过程。</p>
<blockquote>
<p>CentOS 6.5 默认yum只能安装mysql 5.1<br>安装前要检查机器原来是否安装过mysql，如有安装需要先进行数据备份、清理。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum list installed | grep mysql</span><br><span class="line"># ps -ef|grep mysql</span><br><span class="line"># service mysqld stop </span><br><span class="line"># rpm -e mysql-libs --nodeps</span><br><span class="line"># yum -y remove mysql mysql-*</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:<br>如果不使用5.7 或者其他任何版本，只能有一个是 enabled&#x3D;1的，其他的都得enabled&#x3D;0。</p>
</blockquote>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum -y install mysql-server mysql</span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># service mysqld start</span><br></pre></td></tr></table></figure>
<h2 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql -u root</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set password=PASSWORD(&quot;GIVE-NEW-ROOT-PASSWORD&quot;) where User=&#x27;root&#x27;;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure>

<p>以后要改密码用<br><code>mysqladmin -u root -p password &quot;new password&quot;</code></p>
<p><a href="http://www.jianshu.com/p/5a2e4e0b6eda">原贴</a></p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS 6.5安装 MySQL</title>
    <url>/2017/11/29/CentOS%206.5%20%E5%AE%89%E8%A3%85%20MySQL/</url>
    <content><![CDATA[<p>用系统自带的yum命令来安装MySQL 5.6，下面记录一下整个安装、配置过程。</p>
<blockquote>
<p>CentOS 6.5 默认yum只能安装mysql 5.1<br>安装前要检查机器原来是否安装过mysql，如有安装需要先进行数据备份、清理。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum list installed | grep mysql</span><br><span class="line"># ps -ef|grep mysql</span><br><span class="line"># service mysqld stop </span><br><span class="line"># rpm -e mysql-libs --nodeps</span><br><span class="line"># yum -y remove mysql mysql-*</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<blockquote>
<p>注意:<br>如果不使用5.7 或者其他任何版本，只能有一个是 enabled&#x3D;1的，其他的都得enabled&#x3D;0。</p>
</blockquote>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum -y install mysql-server mysql</span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># service mysqld start</span><br></pre></td></tr></table></figure>
<h2 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql -u root</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set password=PASSWORD(&quot;GIVE-NEW-ROOT-PASSWORD&quot;) where mysql&gt; User=&#x27;root&#x27;;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure>

<p><a href="http://www.jianshu.com/p/5a2e4e0b6eda">原贴</a></p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>使用Docker安装rabbitMQ</title>
    <url>/2020/08/18/Docker%E4%B8%8B%E5%AE%89%E8%A3%85rabbitmq/</url>
    <content><![CDATA[<h2 id="Docker下安装rabbitmq"><a href="#Docker下安装rabbitmq" class="headerlink" title="Docker下安装rabbitmq"></a><a href="https://www.cnblogs.com/hackyo/p/9318252.html">Docker下安装rabbitmq</a></h2><ol>
<li>拉取镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动镜像（默认用户名密码）,默认guest 用户，密码也是 guest</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname rabbitmq --name rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动镜像（设置用户名密码）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname rabbitmq --name rabbitmq -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>完成后访问：<a href="http://localhost:15672/">http://localhost:15672/</a></li>
</ol>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2020/03/05/Docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><blockquote>
<p><code>docker pull [选项] [Docker 仓库地址[:端口号]]仓库名[:标签]</code></p>
</blockquote>
<ul>
<li>[]内的属于可选参数,所以最基本的命令就是 <code>docker pull mongo</code> 这样的.</li>
<li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名&#x2F;IP&gt;[:端口号]。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;&#x2F;&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li>
</ul>
<p>例如: <code>docker pull mongo</code><br>这里没有给定Docker仓库地址就用默认的Docker Hub,没有给定标签就拿最新的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Using default tag: latest</span><br></pre></td></tr></table></figure>
<p>具体的tag可以去hub.docker.com里查看</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><blockquote>
<p><code>docker image ls</code></p>
</blockquote>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200305164223.png"><br>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。</p>
<span id="more"></span>

<h2 id="实例化镜像"><a href="#实例化镜像" class="headerlink" title="实例化镜像"></a>实例化镜像</h2><blockquote>
<p><code>docker run -p 本地端口:容器端口 -d --name Name 镜像</code></p>
</blockquote>
<p>例如<br><code>docker run -p 27017:27017 -d --name mongoDB mongo</code><br>就是在指定主机端口27017映射容器端口27017端口后台运行mongo,别名为mongoDB<br>这个时候就会在后台27017端口运行容器mongoDB,这个时候在Docker里运行的mongo就和在本地运行一样</p>
<p>如果不映射端口的话,我们就需要知道docker中的redis的IP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; $&#123;容器id&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>docker ps</code>看到容器id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; b7378e4328d6</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure>
<p>然后去连这个IP地址的对应端口的服务<code>./redis-cli -h 172.17.0.3</code><br><a href="http://kael-aiur.com/docker/%E4%BD%BF%E7%94%A8docker%E7%9A%84redis%E9%95%9C%E5%83%8F.html">参考文章</a></p>
<h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>在<code>docker image ls</code>里展示的SIZE是指本地解压缩以后的镜像体积,会比Docker Hub中显示大.<br>而<code>docker image ls</code>中展示的体积也并非是实际硬盘消耗的体积,因为Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。<br>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure>

<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>有一种特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p>
<p><code>&lt;none&gt;</code>      <code>&lt;none&gt;</code>   00285df0df87        5 days ago   342 MB<br>这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker image ls -f dangling=true</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>


<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><blockquote>
<p><code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code><br>这里的&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要<br>例如:</p>
</blockquote>
<ul>
<li><code>docker image rm 0d35b744b3012621</code></li>
<li><code>docker image rm 0d35b744b30126210d35b744b30126210d35b744b3012621</code></li>
<li><code>docker image rm redis</code></li>
</ul>
<h2 id="定制化镜像"><a href="#定制化镜像" class="headerlink" title="定制化镜像"></a>定制化镜像</h2><blockquote>
<p>只是使用别人的镜像最多就是方便安装一个服务,一个系统,一个软件.这显然不够,Docker能做到更多.Dockerfile文件就是用来做这个事的.</p>
</blockquote>
<p>首先在一个空白文件夹中创建一个名为<code>Dockerfile</code>的文件 <code>touch Dockerfile</code><br>Dockerfile文件由2部分组成,<code>FROM 镜像名</code>和<code>RUN shell脚本</code><br>例如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>定制化镜像,一般是在别人的镜像基础上进行调整,FROM的就是基础镜像,这里就是继承了Docker Hub的nginx镜像,然后执行<code>RUN shell脚本</code>生成新的镜像<br>如果shell脚本比较复杂也可以写成脚本文件用exec格式去执行<br><code>exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。</code></p>
<h3 id="RUN-shell脚本"><a href="#RUN-shell脚本" class="headerlink" title="RUN shell脚本"></a>RUN shell脚本</h3><blockquote>
<p>以下内容引用自<a href="https://docker_practice.gitee.io/zh-cn/image/build.html">docker_practice</a></p>
</blockquote>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>

<p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 Dockerfile 正确的写法应该是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN buildDeps=&#x27;gcc libc6-dev make wget&#x27; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>

<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t 镜像:标签 &lt;上下文路径/URL/-&gt;</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">docker build -t nginx:v2 .</span><br></pre></td></tr></table></figure>
<p>构建完成以后就可以用<code>docker image ls</code>查看新的标签为v2的nginx镜像了</p>
<h4 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h4><p>你可能会留意到<code>docker build -t nginx:v2 .</code>这里最后加了一个<code>.</code>,这个<code>.</code>表示的是当前目录,而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的.<br>这里其实一个上下文路径.因为Dockerfile中可能会执行<code>ADD</code>,<code>COPY</code>之类的操作,这类操作会用到的路径就是以这个上下文路径为标准的.例如:<br>如果在 Dockerfile 中这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>
<p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。</p>
<p>所以为了避免出现路径的bug,最好是将要用的文件都复制到Dockerfile文件的同个目录下,然后<code>docker build nginx .</code>时采用默认的Dockerfile当前路径.如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>具体细节和docker build 的其他用法<a href="https://docker_practice.gitee.io/zh-cn/image/build.html">参考文档</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>Docker和 K8S</title>
    <url>/2019/09/11/Docker%E5%92%8C%20K8S/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote>
<p>在了解 Docker 之前先了解虚拟机,虚拟机就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。而Docker这样的容器技术，也是虚拟化技术，属于轻量级的虚拟化</p>
</blockquote>
<p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。<br>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190911105521.jpg"></p>
<span id="more"></span>

<p>而Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。Docker 是由三个概念组成的:镜像,仓库,容器.<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190911110909.png"></p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>可重复生成容器的原型文件,类似于 mac 的 Time Machine.比如我把当前的mac 用Time Machine备份了一份,以后用这个备份文件(镜像)就可以恢复出无限多台一模一样的电脑.</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>在刚刚的例子里,复制出来的电脑就是 Docker 中的容器.通过镜像生成的一模一样的计算机环境.不一样的是现实生活中,一台电脑上只能恢复一份 mac 系统,而用 Docker 技术可以在一台 Linux 计算机上用一份镜像恢复出很多个Docker 容器,相当于多台电脑.</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>我们一般将Time Machine备份放在移动硬盘里,这个硬盘就相当于是一个仓库,只不过我们的仓库里只有一份镜像文件,但是苹果的 iCloud 中就有很多份Time Machine备份,这个 iCloud 就相当于是 Docker 的官方仓库 Docker Hub.不同的是 Docker Hub 是开放性的,只要通过审核以后就可以由用户自己上传到 Docker Hub 上,别人也都可以自由使用.</p>
<blockquote>
<p><a href="https://docker_practice.gitee.io/zh-cn/">具体使用文档</a></p>
</blockquote>
<h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><blockquote>
<p>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</p>
</blockquote>
<p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p>
<h2 id="K8S-架构"><a href="#K8S-架构" class="headerlink" title="K8S 架构"></a>K8S 架构</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190911111005.png"></p>
<p>这个集群主要包括两个部分：</p>
<ul>
<li>一个Master节点（主节点）</li>
<li>一群Node节点（计算节点）</li>
</ul>
<p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。<br>深入来看这两种节点。</p>
<h3 id="首先是Master节点。"><a href="#首先是Master节点。" class="headerlink" title="首先是Master节点。"></a>首先是Master节点。</h3><ul>
<li>Master节点包括API Server、Scheduler、Controller manager、etcd。</li>
<li>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</li>
<li>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</li>
<li>Controller manager负责管理控制器，相当于“大总管”。</li>
</ul>
<h3 id="然后是Node节点。"><a href="#然后是Node节点。" class="headerlink" title="然后是Node节点。"></a>然后是Node节点。</h3><p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是Pod。<br>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。</p>
<ul>
<li>Docker，不用说了，创建容器的。</li>
<li>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</li>
<li>Kube-proxy，主要负责为Pod对象提供代理。</li>
<li>Fluentd，主要负责日志收集、存储与查询。</li>
</ul>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>用 find或 include 代替 indexOf</title>
    <url>/2017/11/29/ES6%E2%80%94Array%E2%80%94%20indexOf%20%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%88%96%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="find"><a href="#find" class="headerlink" title="find:"></a>find:</h2><blockquote>
<p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<h3 id="findIndexOf-返回是的-item-的-index-其他都一样"><a href="#findIndexOf-返回是的-item-的-index-其他都一样" class="headerlink" title="findIndexOf 返回是的 item 的 index, 其他都一样"></a>findIndexOf 返回是的 item 的 index, 其他都一样</h3><span id="more"></span>
<h2 id="include"><a href="#include" class="headerlink" title="include:"></a>include:</h2><blockquote>
<p>第一个参数为要查找的元素,该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
</blockquote>
<p><strong>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（&#x3D;&#x3D;&#x3D;）进行判断，这会导致对NaN的误判。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>git flow</title>
    <url>/2017/11/29/Git%20Flow/</url>
    <content><![CDATA[<h2 id="一共有5个分支"><a href="#一共有5个分支" class="headerlink" title="一共有5个分支"></a>一共有5个分支</h2><p><img src="http://p04c6djlz.bkt.clouddn.com//17-11-29/80113051.jpg"></p>
<span id="more"></span>
<ul>
<li>master:也可以叫 production 分支,一般用于发布产品.最好打上 Tag, 标注是哪个产品版本.用 X.Y.Z原则</li>
<li>develop:用于开发的分支,一个版本的功能开发完成后,推到 master 上.<code>(git merge develop master)</code></li>
<li>feature: 开发新功能的分支.一般是在 develop 上分出来,进行功能性开发,完成后合并到 develop 上.<code>(git merge feature develop)</code></li>
<li>hotfix: 紧急修复分支,突然发现 master 上出现了 bug, 然后从 master 上分出来进行 debug, 完成后合并回 master.<code>(git merge hotfix master)</code></li>
<li>release:预发布分支.当完成了很多个 feature 以后, develop 上可以分出一个 release 分支,用于发布给测试debug,完成 debug 以后再合并到 develop 和 master 上同时再打上Tag, 记住 release 版本号,然后就可以删除分支了. <strong>(记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)</strong>,可以把 release 理解为 develop 合并到 master 之前的 debug 测试分支.<code>(git merge release master)(git merge release develop)(git branch -d release)(git tag -a v0.1.0 master)</code></li>
</ul>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>onmouseover和onmouseout的坑</title>
    <url>/2018/06/07/HTML%20--onmouseover%E5%92%8Conmouseout%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="HTML-–onmouseover和onmouseout的坑"><a href="#HTML-–onmouseover和onmouseout的坑" class="headerlink" title="HTML –onmouseover和onmouseout的坑"></a>HTML –onmouseover和onmouseout的坑</h1><h2 id="一个DIV层，当鼠标移进的时候会触发onmouseover，移出的时候会触发onmouseout。"><a href="#一个DIV层，当鼠标移进的时候会触发onmouseover，移出的时候会触发onmouseout。" class="headerlink" title="一个DIV层，当鼠标移进的时候会触发onmouseover，移出的时候会触发onmouseout。"></a>一个DIV层，当鼠标移进的时候会触发onmouseover，移出的时候会触发onmouseout。</h2><h3 id="很简单的逻辑，这也是我们想要的！但随之烦恼也就来了：onmouseover并不会只在移进时才触发，onmouseout也不会只在移出时才触发！鼠标在DIV里面移动时也会可能触发onmouseover或onmouseout。"><a href="#很简单的逻辑，这也是我们想要的！但随之烦恼也就来了：onmouseover并不会只在移进时才触发，onmouseout也不会只在移出时才触发！鼠标在DIV里面移动时也会可能触发onmouseover或onmouseout。" class="headerlink" title="很简单的逻辑，这也是我们想要的！但随之烦恼也就来了：onmouseover并不会只在移进时才触发，onmouseout也不会只在移出时才触发！鼠标在DIV里面移动时也会可能触发onmouseover或onmouseout。"></a>很简单的逻辑，这也是我们想要的！但随之烦恼也就来了：onmouseover并不会只在移进时才触发，onmouseout也不会只在移出时才触发！鼠标在DIV里面移动时也会可能触发onmouseover或onmouseout。</h3><p><img src="http://p04c6djlz.bkt.clouddn.com//0_1330051781bhn1.gif"><br>在上图中，对于’A’来说：当鼠标进入’A’(路径’1′)时那么就会触发’A’的onmouseover事件；接着鼠标移动到’B’(路径’2′)，此时’A’会触发onmouseout(先)和onmouseover(后)事件。</p>
<p>由此可见，如果HTML元素(‘A’层)内还有其他元素(‘B’,’C’层)，当我们移动到这些内部的元素时就会触发最外层(‘A’层)的onmouseout和onmouseover事件。</p>
<p>这两个事件的触发表现真的就是你想要的吗？也许你需要一个只在移进时才触发的，一个只在移出时才触发的事件，不管其内部是否还有其他元素….</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><h1 id="使用onmouseenter-和-onmouseleave代替onmouseover和onmouseout"><a href="#使用onmouseenter-和-onmouseleave代替onmouseover和onmouseout" class="headerlink" title="使用onmouseenter 和 onmouseleave代替onmouseover和onmouseout"></a>使用onmouseenter 和 onmouseleave代替onmouseover和onmouseout</h1>]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP 状态码表</title>
    <url>/2017/11/29/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li>200 - 服务器成功返回网页</li>
<li>404 - 请求的网页不存在</li>
<li>503 - 服务不可用<br>详细分解：<span id="more"></span>
<h3 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h3>表示临时响应并需要请求者继续执行操作的状态代码。</li>
</ul>
<p>代码 说明<br>100 （继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
<h3 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h3><p>表示成功处理了请求的状态代码。</p>
<p>代码 说明<br>200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206 （部分内容） 服务器成功处理了部分 GET 请求。</p>
<h3 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h3><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<p>代码 说明<br>300 （多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301 （永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h3 id="4xx（请求错误）"><a href="#4xx（请求错误）" class="headerlink" title="4xx（请求错误）"></a>4xx（请求错误）</h3><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>代码 说明<br>400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。<br>404 （未找到） 服务器找不到请求的网页。<br>405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p>
<h3 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h3><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>代码 说明<br>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
<p>HttpWatch状态码Result is<br>200 - 服务器成功返回网页，客户端请求已成功。<br>302 - 对象临时移动。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>304 - 属于重定向。自上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br>401 - 未授权。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>404 - 未找到。服务器找不到请求的网页。<br>2xx - 成功。表示服务器成功地接受了客户端请求。<br>3xx - 重定向。表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。<br>4xx - 请求错误。这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>5xx - 服务器错误。表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>JS的 console 对象</title>
    <url>/2018/05/28/JS%20%E4%B8%AD%E7%9A%84console%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="console对象的各种方法介绍"><a href="#console对象的各种方法介绍" class="headerlink" title="console对象的各种方法介绍"></a>console对象的各种方法介绍</h2><h2 id="1-console-assert-方法"><a href="#1-console-assert-方法" class="headerlink" title="1.console.assert()方法"></a>1.console.assert()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line"><span class="comment">//声明一个名为People的构造函数  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name,age,performance</span>)&#123;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">performance</span> = performance;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//引用上面的构造函数People,声明变量people  </span></span><br><span class="line"><span class="keyword">var</span> people =<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;john&quot;</span>,<span class="number">20</span>,[<span class="number">80</span>,<span class="number">90</span>,<span class="number">99</span>]);  </span><br><span class="line"><span class="comment">//调用console.assert()方法  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>( people.<span class="property">performance</span>.<span class="property">length</span> == <span class="number">3</span>, <span class="string">&quot;长度不准确&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//说明  </span></span><br><span class="line"><span class="comment">//上面在调用console.assert()的意思是：  </span></span><br><span class="line"><span class="comment">//如果people.performance.length == 3返回的结果是true，  </span></span><br><span class="line"><span class="comment">//就不输出&quot;长度不准确&quot;；  </span></span><br><span class="line"><span class="comment">//如果people.performance.length == 3返回的结果是false，  </span></span><br><span class="line"><span class="comment">//就输出&quot;长度不准确&quot;；  </span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="2-console-clear-方法"><a href="#2-console-clear-方法" class="headerlink" title="2.console.clear()方法"></a>2.console.clear()方法</h2><!--more-->

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;john&quot;</span>);  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">clear</span>();  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;is a good man&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//说明  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">clear</span>()主要的作用是：  </span><br><span class="line">    清空浏览器中的打印输出面板，也就是清空浏览器里面的<span class="variable language_">console</span>  </span><br></pre></td></tr></table></figure>

<h2 id="3-console-count-方法"><a href="#3-console-count-方法" class="headerlink" title="3.console.count()方法"></a>3.console.count()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实力代码  </span></span><br><span class="line">    <span class="comment">//定义一个简单的加法函数addition  </span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">addition</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">        <span class="comment">//调用console.count()方法  </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&#x27;addition function called times:&#x27;</span>);  </span><br><span class="line">        <span class="keyword">return</span> a + b;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//声明一个变量  </span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">             sum = <span class="title function_">addition</span>(sum, i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sum);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//说明  </span></span><br><span class="line">    <span class="comment">//console.count()方法用于统计代码块被执行的次数，  </span></span><br><span class="line">    <span class="comment">//console.count()参数是可选的标题，方便阅读  </span></span><br></pre></td></tr></table></figure>

<h2 id="4-console-debug-方法，console-info-方法-console-warn-方法-console-error-方法-console-log-方法"><a href="#4-console-debug-方法，console-info-方法-console-warn-方法-console-error-方法-console-log-方法" class="headerlink" title="4.console.debug()方法，console.info()方法 console.warn()方法 , console.error()方法 console.log()方法"></a>4.console.debug()方法，console.info()方法 console.warn()方法 , console.error()方法 console.log()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//console以上方法支持类似C语言的占位符，  </span></span><br><span class="line">  <span class="comment">//如 %s=&gt;字符串, %d=&gt;整数, %f=&gt;浮点数, %o=&gt;object  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//示例代码  </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I %s more than %d %o.&#x27;</span>, <span class="string">&#x27;want&#x27;</span>, <span class="number">3</span>, &#123;<span class="attr">animal</span>: <span class="string">&#x27;dogs&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>&#125;);  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">debug</span>(<span class="string">&#x27;I like&#x27;</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;Cat&#x27;</span>&#125;, <span class="string">&#x27;A&#x27;</span>);  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">debug</span>(<span class="string">&#x27;I %s more than %d %o.&#x27;</span>, <span class="string">&#x27;want&#x27;</span>, <span class="number">3</span>, &#123;<span class="attr">animal</span>: <span class="string">&#x27;dogs&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>&#125;);  </span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;I like&#x27;</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;Cat&#x27;</span>&#125;, <span class="string">&#x27;A&#x27;</span>);  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;I %s more than %d %o.&#x27;</span>, <span class="string">&#x27;want&#x27;</span>, <span class="number">3</span>, &#123;<span class="attr">animal</span>: <span class="string">&#x27;dogs&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>&#125;);  </span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;I like&#x27;</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;Cat&#x27;</span>&#125;, <span class="string">&#x27;A&#x27;</span>);  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;I %s more than %d %o.&#x27;</span>, <span class="string">&#x27;want&#x27;</span>, <span class="number">3</span>, &#123;<span class="attr">animal</span>: <span class="string">&#x27;dogs&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>&#125;);  </span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;I like&#x27;</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;Cat&#x27;</span>&#125;, <span class="string">&#x27;A&#x27;</span>);  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;I %s more than %d %o.&#x27;</span>, <span class="string">&#x27;want&#x27;</span>, <span class="number">3</span>, &#123;<span class="attr">animal</span>: <span class="string">&#x27;dogs&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>&#125;);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//说明  </span></span><br><span class="line">  <span class="comment">//上面几个方法比较简单，就不细说了  </span></span><br></pre></td></tr></table></figure>

<h2 id="5-console-dir-方法"><a href="#5-console-dir-方法" class="headerlink" title="5.console.dir()方法"></a>5.console.dir()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line">    <span class="comment">//声明一个名为People的构造函数  </span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name,age,performance</span>)&#123;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">performance</span> = performance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//引用上面的构造函数People,声明变量people  </span></span><br><span class="line">    <span class="keyword">var</span> people =<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;john&quot;</span>,<span class="number">20</span>,[<span class="number">80</span>,<span class="number">90</span>,<span class="number">99</span>]);  </span><br><span class="line">    <span class="comment">//调用console.dir()方法  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">dir</span>( people );  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//说明  </span></span><br><span class="line">    <span class="comment">//在调试JavaScript程序时，有时需要转储对象的详细信息。  </span></span><br><span class="line">    <span class="comment">//通过手工编写JavaScript代码可以完成这一工作：  </span></span><br><span class="line">    <span class="comment">//针对对象的属性进行循环，将循环到的每一个属性值打印出来；  </span></span><br><span class="line">    <span class="comment">//可见，这一过程是比较繁琐的，但是在具备调试工具的浏览器上，  </span></span><br><span class="line">    <span class="comment">//通过console.dir()方法可以轻松完成  </span></span><br></pre></td></tr></table></figure>

<h2 id="5-console-dirxml-方法"><a href="#5-console-dirxml-方法" class="headerlink" title="5.console.dirxml()方法"></a>5.console.dirxml()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>));  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">dirxml</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//说明  </span></span><br><span class="line">    输出网页的某个节点（node）包含的html/xml代码，  </span><br><span class="line">    与<span class="variable language_">console</span>.<span class="title function_">log</span>()功能相似  </span><br><span class="line"><span class="number">6.</span><span class="variable language_">console</span>.<span class="title function_">group</span>()方法</span><br><span class="line">[javascript] view plain copy</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupCollapsed</span>()方法  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">groupEnd</span>()方法  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//示例代码  </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;第一组&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1.1&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1.2&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1.3&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();  </span><br><span class="line">  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">groupCollapsed</span>(<span class="string">&#x27;第二组&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2.1&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2.2&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2.3&#x27;</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//说明  </span></span><br><span class="line">      <span class="comment">//console.group()默认展开  </span></span><br><span class="line">      <span class="comment">//console.groupCollapsed()默认关闭  </span></span><br><span class="line">      <span class="comment">//console.groupEnd()结束分组  </span></span><br></pre></td></tr></table></figure>

<h2 id="7-console-profile-方法-console-profileEnd-方法"><a href="#7-console-profile-方法-console-profileEnd-方法" class="headerlink" title="7.console.profile()方法 console.profileEnd()方法"></a>7.console.profile()方法 console.profileEnd()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">AllFunction</span>(<span class="params"></span>)&#123;  </span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;  </span><br><span class="line">              <span class="title function_">functionA</span>(<span class="number">10000</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="title function_">functionB</span>(<span class="number">10000</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">functionA</span>(<span class="params">count</span>)&#123; <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;&#125; &#125;  </span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">functionB</span>(<span class="params">count</span>)&#123; <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;&#125; &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">profile</span>(<span class="string">&#x27;profile&#x27;</span>);  </span><br><span class="line">      <span class="title class_">AllFunction</span>();  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">profileEnd</span>();  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//说明  </span></span><br><span class="line">      <span class="comment">//分析profile和profileEnd之间代码的执行情况，即js代码的性能分析。  </span></span><br><span class="line">      <span class="comment">//注意，如果代码运行时间过短，则在性能分析时可能会被忽略（如上面的函数functionB）:  </span></span><br><span class="line">      <span class="comment">//在浏览器的开发工具中的profile面板里可以看到结果  </span></span><br></pre></td></tr></table></figure>

<h2 id="8-console-table-方法"><a href="#8-console-table-方法" class="headerlink" title="8.console.table()方法"></a>8.console.table()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line"><span class="comment">//数组  </span></span><br><span class="line"><span class="keyword">var</span> dataArr = [  </span><br><span class="line">    [<span class="number">111</span>, <span class="number">222</span>, <span class="number">332</span>],  </span><br><span class="line">    [<span class="number">442</span>, <span class="number">555</span>, <span class="number">666</span>]  </span><br><span class="line">];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(dataArr);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//JSON对象  </span></span><br><span class="line"><span class="keyword">var</span> dataJson = [  </span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;1.11&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;2.2&#x27;</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;11.1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;22.2&#x27;</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;111.1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;222.2&#x27;</span>&#125;  </span><br><span class="line">];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(dataJson);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//说明  </span></span><br><span class="line"><span class="comment">//table方法用于把data对象用表格的方式显示出来，  </span></span><br><span class="line"><span class="comment">//在显示数组或格式一样的JSON数据时很有用：  </span></span><br></pre></td></tr></table></figure>

<h2 id="9-console-time-方法，console-timeEnd-方法"><a href="#9-console-time-方法，console-timeEnd-方法" class="headerlink" title="9.console.time()方法，console.timeEnd()方法"></a>9.console.time()方法，console.timeEnd()方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;time&#x27;</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123; &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;time&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//说明  </span></span><br><span class="line">    <span class="comment">//计算time和timeEnd之间代码块的执行时间并显示  </span></span><br><span class="line">    <span class="comment">//从而来判断JavaScript语法的性能  </span></span><br><span class="line"><span class="number">10.</span><span class="variable language_">console</span>.<span class="title function_">trace</span>()方法</span><br><span class="line">[javascript] view plain copy</span><br><span class="line"><span class="comment">//示例代码  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">trace</span>();  </span><br><span class="line">    <span class="keyword">return</span> a+b;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">add3</span>(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add3</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> <span class="title function_">add2</span>(a,b);&#125;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add2</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> <span class="title function_">add1</span>(a,b);&#125;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> <span class="title function_">add</span>(a,b);&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//说明  </span></span><br><span class="line"><span class="comment">//console.trace()用来追踪函数的调用轨迹  </span></span><br><span class="line"><span class="comment">//可以查看函数是怎么样调用的！  </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS初学笔记</title>
    <url>/2017/11/29/JS%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符就是<code>...</code> 不懂的情况下阅读难度笔记大,学会了以后非常好用<br>扩展运算符主要有两个作用</p>
<ol>
<li>将一个数组转为用逗号分隔的参数序列</li>
<li>表示剩下的所有参数,并且合并成一个数组.</li>
</ol>
<p>第一种情况主要是用来合并数组的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>(more)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的合并数组</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>第二种情况主要是用来赋值的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 要注意的是...rest这样的写法只能放在最后,如果作为第一个参数,就没有意义了</span></span><br></pre></td></tr></table></figure>

<h2 id="x3D-gt-箭头函数"><a href="#x3D-gt-箭头函数" class="headerlink" title="&#x3D;&gt;箭头函数"></a>&#x3D;&gt;箭头函数</h2><h3 id="简单的说就是把function-参数1-参数2-化简了-参数1-参数2-x3D-gt"><a href="#简单的说就是把function-参数1-参数2-化简了-参数1-参数2-x3D-gt" class="headerlink" title="简单的说就是把function(参数1,参数2){}化简了 (参数1,参数2) &#x3D;&gt;{}"></a>简单的说就是把function(参数1,参数2){}化简了 (参数1,参数2) &#x3D;&gt;{}</h3><p>这样不仅看起来直接的多,而且写起来也方便,因为JS中很多回调函数都是匿名的,并不需要那么完整的格式.<br><strong>但是,这当然不仅仅只是一个语法糖,在&#x3D;&gt;函数里,this的作用域会变,这里的this指向的是定义他的那个对象,而不是当前的对象.所以在使用的时候要注意,并且别什么情况下都使用&#x3D;&gt;函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line"><span class="comment">//当只有一个参数时不需要括号也可以</span></span><br></pre></td></tr></table></figure>

<p>最后的升级版就是把扩展运算符和箭头函数合并在一起使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">numbers</span> = (<span class="params">...nums</span>) =&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="title function_">numbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">headAndTail</span> = (<span class="params">head, ...tail</span>) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line"><span class="title function_">headAndTail</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure>

<h3 id="还要注意一点-x3D-gt-函数不能使用yield命令-所以不能用作Generator函数-也不可以当做构造函数-即不可使用new命令-总结-x3D-gt-函数就是用在回调函数等比较简单的匿名函数里-方便写-方便看"><a href="#还要注意一点-x3D-gt-函数不能使用yield命令-所以不能用作Generator函数-也不可以当做构造函数-即不可使用new命令-总结-x3D-gt-函数就是用在回调函数等比较简单的匿名函数里-方便写-方便看" class="headerlink" title="还要注意一点&#x3D;&gt;函数不能使用yield命令,所以不能用作Generator函数,也不可以当做构造函数,即不可使用new命令.总结,&#x3D;&gt;函数就是用在回调函数等比较简单的匿名函数里,方便写,方便看."></a>还要注意一点&#x3D;&gt;函数不能使用yield命令,所以不能用作Generator函数,也不可以当做构造函数,即不可使用new命令.总结,&#x3D;&gt;函数就是用在回调函数等比较简单的匿名函数里,方便写,方便看.</h3><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>es6变量的赋值比较方便,比如<br><code> let [a,b,c] = [1,2,3];</code><br>对于数组的赋值,就是要位置对,结构对就可以赋值了.比如<br><code> let [foo, [[bar],baz] = [1,[[2],3]];</code><br>如果位置或者结构对不上,那数组的赋值是不行的,报undefined</p>
<p>另一种情况,是对象的解构赋值,对象的更方便,只要名字对的上就好了<br><code> let&#123;foo, bar&#125; = &#123;foo:’123’,bar:’321’&#125;</code><br>其实顺序位置对不上也是可以的,只要名字一样就好了,这就带来的异常的方便.</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h3><p><code>[x,y] = [y,x]</code>直接就交换x和y的值了<br>比如后端返回给前端一个对象obj,前端不用一个个的赋值<code>let a = obj.a,b = obj.b</code>这样麻烦死,用解构赋值以后只要 <code>let&#123;a,b&#125; = obj;</code>前端或者说只要对方只要你的变量叫什么名字,就可以从你封装好的对象里,得到这个值,非常快速方便的赋值.之前看到的<code>const React,&#123;PropTypes&#125; from ‘react’</code>也是一样的道理,这里的<code>&#123;PropTypes&#125;</code>就是react的一个属性可以写成是react.PropTyes</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map有两种用法 </p>
<ol>
<li>数组对象的一个遍历方法</li>
<li>一种数据结构<h3 id="当做遍历时-简单的说就是把数组当前的每一个值-依次的传到参数-中例如"><a href="#当做遍历时-简单的说就是把数组当前的每一个值-依次的传到参数-中例如" class="headerlink" title="当做遍历时,简单的说就是把数组当前的每一个值,依次的传到参数()中例如"></a>当做遍历时,简单的说就是把数组当前的每一个值,依次的传到参数()中例如</h3></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nub = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sqrt</span>(<span class="params">n</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> n*n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sqrt = nub.<span class="title function_">map</span>(sqrt) <span class="comment">// 4,9,16,25</span></span><br></pre></td></tr></table></figure>

<p>所以这第一种情况大多是函数遍历一个数组,只不过写法主动被动上有点不同</p>
<h3 id="这第二种情况呢-map是一个Object的变形"><a href="#这第二种情况呢-map是一个Object的变形" class="headerlink" title="这第二种情况呢,map是一个Object的变形"></a>这第二种情况呢,map是一个Object的变形</h3><p>他比object多的就是他的key不仅仅可以是string,可以是各种类型的值,甚至还包括对象,所以在hash结构上,map是一种比object很好的数据结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//true作为键</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, ‘foo’],</span><br><span class="line">  [‘<span class="literal">true</span>’, ‘bar’]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">get</span>(<span class="literal">true</span>) <span class="comment">// ‘foo’</span></span><br><span class="line">m.<span class="title function_">get</span>(‘<span class="literal">true</span>’) <span class="comment">// ‘bar’</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [‘name’, ‘张三’],</span><br><span class="line">  [‘title’, ‘<span class="title class_">Author</span>’]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">has</span>(‘name’) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(‘name’) <span class="comment">// “张三”</span></span><br><span class="line">map.<span class="title function_">has</span>(‘title’) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(‘title’) <span class="comment">// “Author”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = [</span><br><span class="line">  [‘name’, ‘张三’],</span><br><span class="line">  [‘title’, ‘<span class="title class_">Author</span>’]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.<span class="title function_">set</span>(key, value));</span><br></pre></td></tr></table></figure>

<p>Map这个对象还内置了5个方法和一个属性,</p>
<ul>
<li>get(key)</li>
<li>set(key)</li>
<li>has(key)</li>
<li>delete(key)</li>
<li>clear()</li>
<li>size(属性)<br>还带了4个遍历器</li>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历Map的所有成员。</li>
</ul>
<h2 id="这里顺便讲一下数组的遍历方法-forEach-map-reduce-filter"><a href="#这里顺便讲一下数组的遍历方法-forEach-map-reduce-filter" class="headerlink" title="这里顺便讲一下数组的遍历方法 forEach,map, reduce, filter"></a>这里顺便讲一下数组的遍历方法 forEach,map, reduce, filter</h2><p>假设我们有一个数组，每个元素是一个人。你面前站了一排人。</p>
<h3 id="foreach-就是你按顺序一个一个跟他们做点什么，具体做什么"><a href="#foreach-就是你按顺序一个一个跟他们做点什么，具体做什么" class="headerlink" title="foreach 就是你按顺序一个一个跟他们做点什么，具体做什么:"></a>foreach 就是你按顺序一个一个跟他们做点什么，具体做什么:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">people.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">dude</span>) &#123;</span><br><span class="line">  dude.<span class="title function_">pickUpSoap</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>forEach还有另一种用法<code>forEach(args,callback),</code>这里的args是回调函数执行forEach的作用域.</p>
<h3 id="map-就是你手里拿一个盒子（一个新的数组），一个一个叫他们把钱包扔进去。结束的时候你获得了一个新的数组，里面是大家的钱包，钱包的顺序和人的顺序一一对应。"><a href="#map-就是你手里拿一个盒子（一个新的数组），一个一个叫他们把钱包扔进去。结束的时候你获得了一个新的数组，里面是大家的钱包，钱包的顺序和人的顺序一一对应。" class="headerlink" title="map 就是你手里拿一个盒子（一个新的数组），一个一个叫他们把钱包扔进去。结束的时候你获得了一个新的数组，里面是大家的钱包，钱包的顺序和人的顺序一一对应。"></a>map 就是你手里拿一个盒子（一个新的数组），一个一个叫他们把钱包扔进去。结束的时候你获得了一个新的数组，里面是大家的钱包，钱包的顺序和人的顺序一一对应。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wallets = people.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">dude</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> dude.<span class="property">wallet</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="reduce-就是你拿着钱包，一个一个数过去看里面有多少钱啊？每检查一个，你就和前面的总和加一起来。这样结束的时候你就知道大家总共有多少钱了。"><a href="#reduce-就是你拿着钱包，一个一个数过去看里面有多少钱啊？每检查一个，你就和前面的总和加一起来。这样结束的时候你就知道大家总共有多少钱了。" class="headerlink" title="reduce 就是你拿着钱包，一个一个数过去看里面有多少钱啊？每检查一个，你就和前面的总和加一起来。这样结束的时候你就知道大家总共有多少钱了。"></a>reduce 就是你拿着钱包，一个一个数过去看里面有多少钱啊？每检查一个，你就和前面的总和加一起来。这样结束的时候你就知道大家总共有多少钱了。</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var totalMoney = wallets.reduce(function (countedMoney, wallet) &#123;</span><br><span class="line">	return countedMoney + wallet.money;</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure>

<h3 id="补充一个-filter-的：你一个个钱包数过去的时候，里面钱少于-100-块的不要（留在原来的盒子里），多于-100-块的丢到一个新的盒子里。这样结束的时候你又有了一个新的数组，里面是所有钱多于-100-块的钱包："><a href="#补充一个-filter-的：你一个个钱包数过去的时候，里面钱少于-100-块的不要（留在原来的盒子里），多于-100-块的丢到一个新的盒子里。这样结束的时候你又有了一个新的数组，里面是所有钱多于-100-块的钱包：" class="headerlink" title="补充一个 filter 的：你一个个钱包数过去的时候，里面钱少于 100 块的不要（留在原来的盒子里），多于 100 块的丢到一个新的盒子里。这样结束的时候你又有了一个新的数组，里面是所有钱多于 100 块的钱包："></a>补充一个 filter 的：你一个个钱包数过去的时候，里面钱少于 100 块的不要（留在原来的盒子里），多于 100 块的丢到一个新的盒子里。这样结束的时候你又有了一个新的数组，里面是所有钱多于 100 块的钱包：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fatWallets = wallets.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">wallet</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> wallet.<span class="property">money</span> &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply,call,bind"></a>apply,call,bind</h2><p>apply、call<br>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fruits</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">fruits.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My color is &quot;</span> + <span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits;</span><br><span class="line">apple.<span class="title function_">say</span>();    <span class="comment">//My color is red</span></span><br><span class="line">banana = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;yellow&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">apple.<span class="property">say</span>.<span class="title function_">call</span>(banana);     <span class="comment">//My color is yellow</span></span><br><span class="line">apple.<span class="property">say</span>.<span class="title function_">apply</span>(banana);    <span class="comment">//My color is yellow</span></span><br></pre></td></tr></table></figure>

<p>所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。</p>
<h3 id="apply、call-的区别"><a href="#apply、call-的区别" class="headerlink" title="apply、call 的区别"></a>apply、call 的区别</h3><p>对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="keyword">function</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就可以通过如下方式来调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">call</span>(<span class="variable language_">this</span>, arg1, arg2);</span><br><span class="line">func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [arg1, arg2])</span><br></pre></td></tr></table></figure>

<p>其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。<br>而bind,其实作用和apply还有call差不多<br>区别在于后者是立即执行,而bind是稍后执行<br>而且JavaScript中多次绑定是无效的,只有第一个绑定的对象有效</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 中的 call()和apply()</title>
    <url>/2019/12/19/JavaScript%20%E4%B8%AD%E7%9A%84%20call%20%E5%92%8C%20apply/</url>
    <content><![CDATA[<h1 id="JavaScript-中的-call-和apply"><a href="#JavaScript-中的-call-和apply" class="headerlink" title="JavaScript 中的 call()和apply()"></a>JavaScript 中的 call()和apply()</h1><blockquote>
<p>在JavaScript中,每个函数都包含两个非继承而来的方法：call()和apply()</p>
</blockquote>
<h2 id="作用-call和apply的作用都是为了改变某个函数运行时的上下文（context）-换句话说-就是为了改变函数体内部this的指向。"><a href="#作用-call和apply的作用都是为了改变某个函数运行时的上下文（context）-换句话说-就是为了改变函数体内部this的指向。" class="headerlink" title="作用: call和apply的作用都是为了改变某个函数运行时的上下文（context）,换句话说,就是为了改变函数体内部this的指向。"></a>作用: call和apply的作用都是为了改变某个函数运行时的上下文（context）,换句话说,就是为了改变函数体内部this的指向。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fruits</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">fruits.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My color is &quot;</span> + <span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits;</span><br><span class="line">apple.<span class="title function_">say</span>();                <span class="comment">//My color is red</span></span><br></pre></td></tr></table></figure>

<p>当想另外一个对象想使用fruits中的say方法时不用重新写,使用call和apply可以实现“劫持”别人的方法。</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fruits</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">            </span><br><span class="line">fruits.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My color is &quot;</span> + <span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> another = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;yellow&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits;</span><br><span class="line">apple.<span class="title function_">say</span>();                <span class="comment">//My color is red</span></span><br><span class="line">apple.<span class="property">say</span>.<span class="title function_">call</span>(another);    <span class="comment">//My color is yellow</span></span><br><span class="line">apple.<span class="property">say</span>.<span class="title function_">apply</span>(another);   <span class="comment">//My color is yellow</span></span><br></pre></td></tr></table></figure>

<h2 id="区别：参数书写方式不同"><a href="#区别：参数书写方式不同" class="headerlink" title="区别：参数书写方式不同"></a>区别：参数书写方式不同</h2><blockquote>
<p>call(thisObj, arg1, arg2, arg3, arg4);<br>apply(thisObj, [args]);</p>
</blockquote>
<p>thisObj：call和apply第一个参数是一样的,该参数将替代Function类里面的this对象。<br>arg1,arg2….：是一个个的参数,<br>args：一个数组或类数组,是一个参数列表。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h2><h3 id="1-改变函数作用域"><a href="#1-改变函数作用域" class="headerlink" title="1.改变函数作用域"></a>1.改变函数作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小红&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayName.<span class="title function_">call</span>(<span class="variable language_">this</span>));   <span class="comment">//小白</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayName.<span class="title function_">call</span>(obj));    <span class="comment">//小红</span></span><br></pre></td></tr></table></figure>

<h3 id="2-实现继承"><a href="#2-实现继承" class="headerlink" title="2.实现继承"></a>2.实现继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现js继承</span></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayInfo</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 身高：&quot;</span> + height + <span class="string">&quot;, 体重：&quot;</span> + <span class="variable language_">this</span>.<span class="property">weight</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Chinese</span>(<span class="params">name, height, weight</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, height);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">weight</span> = weight;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是中国人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">America</span>(<span class="params">name, height, weight</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [name, height]);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">weight</span> = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chiness = <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;成龙&quot;</span>, <span class="string">&quot;178cm&quot;</span>, <span class="string">&quot;60kg&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chiness.<span class="title function_">sayInfo</span>());    <span class="comment">//姓名：成龙, 身高：178cm, 体重：60kg</span></span><br><span class="line"><span class="keyword">let</span> america = <span class="keyword">new</span> <span class="title class_">America</span>(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;180cm&quot;</span>, <span class="string">&quot;55kg&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(america.<span class="title function_">sayInfo</span>());    <span class="comment">//姓名：jack, 身高：180cm, 体重：55kg</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 的原型链</title>
    <url>/2019/06/05/JavaScript%20%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="JavaScript-的原型链"><a href="#JavaScript-的原型链" class="headerlink" title="JavaScript 的原型链"></a>JavaScript 的原型链</h1><p>JavaScript 的原型链关系到js 的对象,方法实例化的原理,弄懂原型链就可以明白 js 封装继承的原理.对理解js 的面向对象有很大的帮助.在 ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型链的.<br>原型链主要是由 2 个对象实现的: <code>__proto__</code> 和 <code>prototype</code></p>
<h2 id="proto-和-prototype"><a href="#proto-和-prototype" class="headerlink" title="__proto__和 prototype"></a>__proto__和 prototype</h2><p>JavaScript 的所有对象都有<code>__proto__</code>这个属性,其实<code>__proto__</code>就是一个指针, 他指向实例化他这个对象的原始对象的 prototype 对象.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;&#125; <span class="comment">// function Book() &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> mathBook = <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"><span class="comment">// 这里mathBook.__proto__ === Book.prototype</span></span><br><span class="line"><span class="comment">// 这就是__proto__指向实例化他的原始对象的 prototype.</span></span><br></pre></td></tr></table></figure>
<p>prototype 是所有的<strong>函数对象</strong>都有的属性,当一个<strong>函数对象</strong>被 new 实例化时,他的 prototype 里的属性和方法都会被复制一份,放到实例化的对象里,并且 prototype 这个对象也有<code>__proto__</code>对象,实例化的时候还会把<code>__proto__</code>指向的对象的 prototype 里的属性和方法也复制一份.也就实现了继承.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> mathBook = <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 但是 mathBook 是没有 prototype 属性的,因为他是一个实例化对象,而不是一个函数,js 中的类是用函数模拟出来的,全依赖这个 prototype</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-的基本数据类型"><a href="#JavaScript-的基本数据类型" class="headerlink" title="JavaScript 的基本数据类型"></a>JavaScript 的基本数据类型</h2><p>JavaScript 的基本数据类型也是通过这种方法实现的.</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">// const a = new Number(1);</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;String&#x27;</span>; <span class="comment">// const str = new String(String);</span></span><br></pre></td></tr></table></figure>
<p>这个时候 a 和 str 就是 Number 和 String 函数(方法,类)的实例化对象.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.<span class="property">__proto__</span> === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">str.<span class="property">__proto__</span> === <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<p>而这些数据类型又都是 Object 对象的子类.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<p>如果你写一个类继承于 Number,例如 <code>class Int extend Number&#123;&#125;</code><br>那么这个类的实例化对象就会有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Int</span> extend <span class="title class_">Number</span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Int</span>()</span><br><span class="line">a.<span class="property">__proto__</span> === <span class="title class_">Int</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">a.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">a.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>经过测试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以 JavaScript 的数据类型都是 Object 类型的子类,所以说 JavaScript 的所有数据都是对象<br>而原型链的终点就是 null</p>
<p>关于函数: JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。<br>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p>
<h2 id="construction-方法"><a href="#construction-方法" class="headerlink" title="construction 方法"></a>construction 方法</h2><p>构造方法,也就是实例化对象时(new)调用的方法.这个方法其实就是一个类的名字指向的地址.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Number</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>而实例化之后的对象也拥有 construction 方法,他指向他的类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a.<span class="property">constructor</span> === <span class="title class_">Number</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这样就可以更容易判断一个对象他由哪个类实例化而来了</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190605193923.png"></p>
<h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><p>new运算符的原理: </p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params"><span class="comment">/* 构造函数 */</span> constructor, <span class="comment">/* 构造函数参数 */</span> params</span>) &#123;</span><br><span class="line">  <span class="comment">// 将 arguments 对象转为数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 取出构造函数</span></span><br><span class="line">  <span class="keyword">var</span> constructor = args.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = constructor.<span class="title function_">apply</span>(context, args);</span><br><span class="line">  <span class="comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">greeting</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person1);</span><br><span class="line"></span><br><span class="line">person2.<span class="property">name</span> <span class="comment">// 张三</span></span><br><span class="line">person2.<span class="title function_">greeting</span>() <span class="comment">// Hi! I&#x27;m 张三.</span></span><br></pre></td></tr></table></figure>

<h2 id="原型链的作用"><a href="#原型链的作用" class="headerlink" title="原型链的作用"></a>原型链的作用</h2><p>在面向对象编程中,子类会继承父类的方法和属性,当一个属性在子类的实例化对象中找不到时,就会去找他父类的属性.JavaScript 的原型链也是这样工作的,查找一个对象的属性或者方法,就会去他的<code>__proto__</code>指向的prototype 中找,如果还没有,就会去 prototype.__proto__指向的 prototype 中找,一直找到 Object.prototype.这也就实现了类的继承.</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190605191625.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2017/11/29/Koa2%20%E4%B8%AD%E9%97%B4%E9%94%AE%E7%9A%84%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>Koa 用的都是中间键,而这些中间键的顺序是压栈.例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">next</span>(); <span class="comment">// next不写会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 打印出1、2、3、4、5</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这里console.log(3)以后会去取最新入栈的 console.log(4), 而不是5</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>使用Koa2做文件下载服务器</title>
    <url>/2018/06/06/Koa2%E5%81%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Koa2做文件下载服务器"><a href="#Koa2做文件下载服务器" class="headerlink" title="Koa2做文件下载服务器"></a>Koa2做文件下载服务器</h1><h2 id="使用-koa-send模块-其核心代码为"><a href="#使用-koa-send模块-其核心代码为" class="headerlink" title="使用 koa-send模块,其核心代码为"></a>使用 koa-send模块,其核心代码为</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> send = <span class="built_in">require</span>(<span class="string">&#x27;koa-send&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">send</span>(ctx, ctx.<span class="property">path</span>, &#123; <span class="attr">root</span>: __dirname + <span class="string">&#x27;/public&#x27;</span> &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>值得一提的是send()方法的第三个参数{root: __dirname + ‘dir’}是必填的,如果不填这个参数,在 path 中填路径,会出现”forbidden”的 error 报错.</p>
<h2 id="koa-send-第三个参数的其他可选项如下"><a href="#koa-send-第三个参数的其他可选项如下" class="headerlink" title="koa-send 第三个参数的其他可选项如下"></a>koa-send 第三个参数的其他可选项如下</h2><ul>
<li><code>maxage</code> Browser cache max-age in milliseconds. (defaults to <code>0</code>)</li>
<li><code>immutable</code> Tell the browser the resource is immutable and can be cached indefinitely. (defaults to <code>false</code>)</li>
<li><code>hidden</code> Allow transfer of hidden files. (defaults to <code>false</code>)</li>
<li><a href="https://segmentfault.com/a/1190000012412400#root-path"><code>root</code></a> Root directory to restrict file access.</li>
<li><code>index</code> Name of the index file to serve automatically when visiting the root location. (defaults to none)</li>
<li><code>gzip</code> Try to serve the gzipped version of a file automatically when <code>gzip</code> is supported by a client and if the requested file with <code>.gz</code> extension exists. (defaults to <code>true</code>).</li>
<li><code>brotli</code> Try to serve the brotli version of a file automatically when <code>brotli</code> is supported by a client and if the requested file with <code>.br</code> extension exists. (defaults to <code>true</code>).</li>
<li><code>format</code> If not <code>false</code> (defaults to <code>true</code>), format the path to serve static file servers and not require a trailing slash for directories, so that you can do both <code>/directory</code> and <code>/directory/</code>.</li>
<li><a href="https://segmentfault.com/a/1190000012412400#setheaders"><code>setHeaders</code></a> Function to set custom headers on response.</li>
<li><code>extensions</code> Try to match extensions from passed array to search for file when no extension is sufficed in URL. First found is served. (defaults to <code>false</code>)</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000012412400">参考资料: segmentfault</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>LeanCloud基础</title>
    <url>/2017/07/25/LeanCloud%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><i class="fab fa-app-store fa-2x"></i><br>构建对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">AV</span>.<span class="property">Object</span>.<span class="title function_">extend</span>(<span class="string">&#x27;className&#x27;</span>) 所需的参数 className 则表示对应的表名</span><br></pre></td></tr></table></figure>

<p>保存对象:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">className.<span class="title function_">save</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">todo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;objectId is &#x27;</span> + todo.<span class="property">id</span>);</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>CQL:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行 CQL 语句实现新增一个 TodoFolder 对象</span></span><br><span class="line">  <span class="variable constant_">AV</span>.<span class="property">Query</span>.<span class="title function_">doCloudQuery</span>(<span class="string">&#x27;insert into TodoFolder(name, priority) values(&quot;工作&quot;, 1)&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// data 中的 results 是本次查询返回的结果，AV.Object 实例列表</span></span><br><span class="line">    <span class="keyword">var</span> results = data.<span class="property">results</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">//查询失败，查看 error</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>获取对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> todo = <span class="variable constant_">AV</span>.<span class="property">Object</span>.<span class="title function_">createWithoutData</span>(<span class="string">&#x27;Todo&#x27;</span>, <span class="string">&#x27;5745557f71cfe40068c6abe0&#x27;</span>);</span><br><span class="line">  todo.<span class="title function_">fetch</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> title = todo.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>);<span class="comment">// 读取 title</span></span><br><span class="line">    <span class="keyword">var</span> content = todo.<span class="title function_">get</span>(<span class="string">&#x27;content&#x27;</span>);<span class="comment">// 读取 content</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>更新对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是 className，第二个参数是 objectId</span></span><br><span class="line"> <span class="keyword">var</span> todo = <span class="variable constant_">AV</span>.<span class="property">Object</span>.<span class="title function_">createWithoutData</span>(<span class="string">&#x27;Todo&#x27;</span>, <span class="string">&#x27;5745557f71cfe40068c6abe0&#x27;</span>);</span><br><span class="line"> <span class="comment">// 修改属性</span></span><br><span class="line"> todo.<span class="title function_">set</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;每周工程师会议，本周改为周三下午3点半。&#x27;</span>);</span><br><span class="line"> <span class="comment">// 保存到云端</span></span><br><span class="line"> todo.<span class="title function_">save</span>();</span><br><span class="line"><span class="comment">//更新操作是覆盖式的，云端会根据最后一次提交到服务器的有效请求来更新数据。更新是字段级别的操作，未更新的字段不会产生变动，这一点请不用担心。</span></span><br></pre></td></tr></table></figure>

<p>CQL：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行 CQL 语句实现更新一个 TodoFolder 对象</span></span><br><span class="line">  <span class="variable constant_">AV</span>.<span class="property">Query</span>.<span class="title function_">doCloudQuery</span>(<span class="string">&#x27;update TodoFolder set name=&quot;家庭&quot; where objectId=&quot;558e20cbe4b060308e3eb36c&quot;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// data 中的 results 是本次查询返回的结果，AV.Object 实例列表</span></span><br><span class="line">    <span class="keyword">var</span> results = data.<span class="property">results</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>删除对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> todo = <span class="variable constant_">AV</span>.<span class="property">Object</span>.<span class="title function_">createWithoutData</span>(<span class="string">&#x27;Todo&#x27;</span>, <span class="string">&#x27;57328ca079bc44005c2472d0&#x27;</span>);</span><br><span class="line">  todo.<span class="title function_">destroy</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">success</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除成功</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除失败</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>CQL：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行 CQL 语句实现删除一个 Todo 对象</span></span><br><span class="line"> <span class="variable constant_">AV</span>.<span class="property">Query</span>.<span class="title function_">doCloudQuery</span>(<span class="string">&#x27;delete from Todo where objectId=&quot;558e20cbe4b060308e3eb36c&quot;&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 删除成功</span></span><br><span class="line"> &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">   <span class="comment">// 异常处理</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>


<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 笔记</title>
    <url>/2020/03/10/LeetCode%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><blockquote>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例 1:<br>输入: 123<br>输出: 321</p>
</blockquote>
<span id="more"></span>

<p>这里想到3种方法:</p>
<ol>
<li>将数字丢进数组里,用数组自带的reverse方法再依次乘以对应10的i次方</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> xAbs = <span class="title class_">Math</span>.<span class="title function_">abs</span>(x)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> xAbs.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(number)</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_">reverse</span>()</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i = arr.<span class="property">length</span>, j = <span class="number">0</span>; i &gt; <span class="number">0</span>; i--, j++) &#123;</span><br><span class="line">        result += arr[j] * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>, i - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">0</span> - result : result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个过程做了2次循环,还做了很多次的指数运算,虽然还是O(lg(n)),但效率相对较低</p>
<ol start="2">
<li>使用取模的办法来获取每一位数,这样就减少了10的指数运算,并且只做了一次循环</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse2 = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> xAbs = x &lt; <span class="number">0</span> ? x * -<span class="number">1</span> : x</span><br><span class="line">    <span class="keyword">while</span> (xAbs !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pop = xAbs % <span class="number">10</span>;</span><br><span class="line">        xAbs = <span class="title class_">Math</span>.<span class="title function_">floor</span>(xAbs / <span class="number">10</span>);</span><br><span class="line">        result = result * <span class="number">10</span> + pop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">0</span> - result : result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种方法依然是做了算计计算,取模,乘除</p>
<ol start="3">
<li>用字符串拼接的方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xAbs = <span class="title class_">Math</span>.<span class="title function_">abs</span>(x).<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xAbs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        result += xAbs[xAbs.<span class="property">length</span> - i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">parseInt</span>(result)</span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">0</span> - result : </span><br></pre></td></tr></table></figure>

<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h2><blockquote>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<blockquote>
<p>例如: <code>nums = [1,1,2] -&gt; [1,2]</code><br><code>return 2</code></p>
</blockquote>
<p>题目要求在原地删除重复出现的元素,不能使用额外的数组空间,所以就不能new Set()来处理,也不能用新数组来存储没有重复的数字.<br>也就是说</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能使用set</span></span><br><span class="line"><span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums)]</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也不能使用</span></span><br><span class="line"><span class="keyword">const</span> arr = [nums[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.<span class="title function_">includes</span>(nums[i])) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用双指针</span></span><br><span class="line"><span class="comment">// 前提是输入的数组是已经排序好的</span></span><br><span class="line"><span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>,j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] !== nums[j]) &#123;</span><br><span class="line">        nums[i + <span class="number">1</span>] = nums[j]</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums.<span class="title function_">slice</span>(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 可以画图理解一下指针的移动过程</span></span><br></pre></td></tr></table></figure>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<p>如果使用遍历叠加的方式,但是又不确定到底是连续几项相加最大,所以暴力法不可取,否则时间复杂度也会非常高.经过分析,如果要连续子数组和最大(子数组元素大于1的情况),那第一项必定是正数,如果元素全为负数,子数组和最大就是最大的子元素.所以找到一个正数就往后叠加,并且把叠加和赋值给当前的位置,再和当前计算出的和最大值比较,取大的数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> maxCount = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums[i] += nums[i - <span class="number">1</span>]; <span class="comment">// 改变原数组,如果这个值是负数,就另找正数开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxCount = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxCount, nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxCount;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB TTL索引实战</title>
    <url>/2020/12/08/MongoDB%20TTL%E7%B4%A2%E5%BC%95%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>分享短链记录表需要定期做清除,由于数据量较大,而且对数据库操作的次数很多,原来使用定时任务的方式来删除,会对数据库造成短时内的性能波动<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20201208170209.png"><br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20201208170231.png"></p>
<p>所以打算使用其他方式来处理这个问题</p>
<h1 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h1><blockquote>
<p>TTL全称是(Time To Live),TTL索引能对一个单列配置过期属性来实现对文档的自动过期删除，我们可以在对字段创建索引时添加expireAfterSeconds选项将索引转换为TTL索引，<strong>该字段需要是date类型</strong></p>
</blockquote>
<h2 id="在以下几种场景下即使索引设置了expireAfterSeconds属性也不会生效"><a href="#在以下几种场景下即使索引设置了expireAfterSeconds属性也不会生效" class="headerlink" title="在以下几种场景下即使索引设置了expireAfterSeconds属性也不会生效"></a>在以下几种场景下即使索引设置了expireAfterSeconds属性也不会生效</h2><ul>
<li>如果该字段不是date类型，则文档不会过期</li>
<li>如果文档没包含索引的这个字段，则文档不会过期</li>
</ul>
<span id="more"></span>


<h1 id="TTL索引的运行逻辑"><a href="#TTL索引的运行逻辑" class="headerlink" title="TTL索引的运行逻辑"></a>TTL索引的运行逻辑</h1><ul>
<li>MongoDB会开启一个后台线程读取该TTL索引的值来判断文档是否过期,TTL值是建立在Date类型的数据上,所以MongoDB可以很轻易的找到过期的数据</li>
<li>但不会保证已过期的数据会立马被删除，因后台线程每60秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间60秒以上的现象</li>
<li>对于副本集而言，TTL索引的后台进程只会在primary节点开启，在从节点会始终处于空闲状态，从节点的数据删除是由主库删除后产生的oplog来做同步</li>
<li>TTL索引除了有expireAfterSeconds属性外，和普通索引一样,都可以提升搜索速度</li>
</ul>
<h1 id="TTL索引的限制"><a href="#TTL索引的限制" class="headerlink" title="TTL索引的限制"></a>TTL索引的限制</h1><ol>
<li>只支持对<strong>单个字段</strong>创建TTL索引，复合索引不支持expireAfterSeconds选项</li>
<li>_id列不支持TTL索引</li>
<li><strong>固定集合</strong>(capped collection)不支持TTL索引</li>
<li>不支持用createIndex() 修改expireAfterSeconds属性，但可以用collMod命令修改，或者重建索引，但重建对于大集合成本较高，建议用collMod方式</li>
<li>一个列只能创建普通索引或TTL索引，<strong>不能同时对一个列创建这2种类型索引</strong>(实际TTL索引本身就是普通索引，只是多了一个过期属性)</li>
<li>如果一个<strong>列已经存在索引，则需要先将该索引drop后才能重建为TTL索引</strong>，不能直接转换</li>
</ol>
<h1 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h1><p>使用<code>createIndex()</code>语句创建索引,只是多了一个参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new Date().getTime() - createdAt &gt;=3600 则认为过期,并删除</span></span><br><span class="line">db.<span class="title function_">getCollection</span>(<span class="string">&#x27;user&#x27;</span>).<span class="title function_">createIndex</span>(&#123; <span class="string">&quot;createdAt&quot;</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">expireAfterSeconds</span>: <span class="number">3600</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="如果需要特定在某个时间定过期"><a href="#如果需要特定在某个时间定过期" class="headerlink" title="如果需要特定在某个时间定过期"></a>如果需要特定在某个时间定过期</h2><blockquote>
<p>该场景是在创建索引时将<code>expireAfterSeconds设置为0</code>，在这种情况下由索引字段的数值来决定文档何时过期,这种场景更加精细化，可灵活的控制文档的过期时间及控制在业务低峰期触发文档过期</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在时间到达文档里expireAt的时候后判定过期,并删除</span></span><br><span class="line"><span class="comment">// expireAt必须是个Date类型的字段,比如new Date(&#x27;2020-12-08 18:00:00&#x27;)</span></span><br><span class="line">db.<span class="title function_">getCollection</span>(<span class="string">&#x27;user&#x27;</span>).<span class="title function_">createIndex</span>(&#123; <span class="string">&quot;expireAt&quot;</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">expireAfterSeconds</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 30天后自动删除</span></span><br><span class="line">db.<span class="title function_">getCollection</span>(<span class="string">&#x27;shortLinks&#x27;</span>).<span class="title function_">createIndex</span>(&#123; <span class="string">&#x27;createdAt&#x27;</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">expireAfterSeconds</span>: <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Mongodump 和 Mongorestore</title>
    <url>/2016/12/13/Mongodump%20%E5%92%8C%20Mongorestore%20/</url>
    <content><![CDATA[<h2 id="mongodump"><a href="#mongodump" class="headerlink" title="mongodump"></a>mongodump</h2><blockquote>
<p>mongodump -h dbhost -d dynamo -c collection -o dbdirectory -u uesrname -p pwd其中-h 是数据库地址，127.0.0.1  -d 是数据库名字 context  -o 存储的地址  如果省略就在当前目录下保存 -u 是用户名 -p 是密码</p>
</blockquote>
<span id="more"></span>
<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h:指明数据库宿主机的IP</span><br><span class="line">-u:指明数据库的用户名</span><br><span class="line">-p:指明数据库的密码</span><br><span class="line">-d:指明数据库的名字</span><br><span class="line">-c:指明collection的名字</span><br><span class="line">-o:指明到要导出的文件名</span><br><span class="line">-q:指明导出数据的过滤条件</span><br></pre></td></tr></table></figure>
<h2 id="mongorestore"><a href="#mongorestore" class="headerlink" title="mongorestore"></a>mongorestore</h2><blockquote>
<p>mongorestore -d context &#x2F;Users&#x2F;hwl&#x2F;code&#x2F;database&#x2F;dump&#x2F;context&#x2F;contexts.bson<br>-h 数据库地址  默认为127.0.0.1 -c为collection</p>
</blockquote>
<h3 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h:指明数据库宿主机的IP</span><br><span class="line">-u:指明数据库的用户名</span><br><span class="line">-p:指明数据库的密码</span><br><span class="line">-d:指明数据库的名字</span><br><span class="line">-c:指明collection的名字</span><br><span class="line">-o:指明到要备份的文件名</span><br><span class="line">-q:指明备份数据的过滤条件</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>Mosca 介绍</title>
    <url>/2018/06/04/Mosca/</url>
    <content><![CDATA[<h1 id="Mosca-是-mqtt-协议-js-实现的一个包。"><a href="#Mosca-是-mqtt-协议-js-实现的一个包。" class="headerlink" title="Mosca 是 mqtt 协议 js 实现的一个包。"></a>Mosca 是 mqtt 协议 js 实现的一个包。</h1><h2 id="Mosca的作用："><a href="#Mosca的作用：" class="headerlink" title="Mosca的作用："></a>Mosca的作用：</h2><ol>
<li>与客户端建立长连接</li>
<li>作为代理服务器</li>
<li>根据发布订阅这模式，响应功能<span id="more"></span>
<h2 id="Mosca本身不做逻辑操作-一切的逻辑都放到他代理触发的事件中去执行"><a href="#Mosca本身不做逻辑操作-一切的逻辑都放到他代理触发的事件中去执行" class="headerlink" title="Mosca本身不做逻辑操作,一切的逻辑都放到他代理触发的事件中去执行"></a>Mosca本身不做逻辑操作,一切的逻辑都放到他代理触发的事件中去执行</h2>比如:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> server = <span class="keyword">new</span> protocolMosca.<span class="title class_">Server</span>(settings)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientConnected&#x27;</span>, <span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">function1</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client connected&#x27;</span>, client.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>function1()</code>就可以是外部引入的一个方法,把逻辑全部放到这个方法里去做</p>
<h2 id="Mosca-的事件-每一个被触发时都会存储数据库"><a href="#Mosca-的事件-每一个被触发时都会存储数据库" class="headerlink" title="Mosca 的事件,每一个被触发时都会存储数据库"></a>Mosca 的事件,每一个被触发时都会存储数据库</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> ObjectId(<span class="string">&quot;5b0d0f2a7bc72238259414b6&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> BinData(<span class="number">0</span><span class="punctuation">,</span> <span class="string">&quot;MTc=&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;temperature&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;qos&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;messageId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oc6MQ_z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clientId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mqttjs_acb34ce1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> ObjectId(<span class="string">&quot;5b0d0f81e5a65238e7705d27&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mqttjs_acb34ce1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$SYS/Yt4U9fd/disconnect/clients&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;qos&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;messageId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;G7ijrko&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果是触发事件,会在 topic 里写事件名,否则就是某个<code>packet.topic </code> client 的订阅事件名.</p>
<h2 id="事件种类如下"><a href="#事件种类如下" class="headerlink" title="事件种类如下:"></a>事件种类如下:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * client about things of connect</span></span><br><span class="line"><span class="comment"> * 1. clientConnected - when a cient is connected</span></span><br><span class="line"><span class="comment"> * 2. clientDisconnecting - when a client is being disconnected</span></span><br><span class="line"><span class="comment"> * 3. clientDisconnected - when a client is disconnected</span></span><br><span class="line"><span class="comment"> * 4. clientError - when the server identifies a client connection error</span></span><br><span class="line"><span class="comment"> /********************************************************************/</span></span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientConnected&#x27;</span>, <span class="keyword">function</span> (<span class="params">client</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client connected&#x27;</span>, client.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientDisconnecting&#x27;</span>, <span class="keyword">function</span> (<span class="params">client</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client client disconnecting&#x27;</span>, client.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientDisconnected&#x27;</span>, <span class="keyword">function</span> (<span class="params">client</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client is disconnected&#x27;</span>, client.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>, <span class="keyword">function</span> (<span class="params">client</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client identifies error&#x27;</span>, client.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * client about published and subscribed</span></span><br><span class="line"><span class="comment"> * 1. published - when a new message is published</span></span><br><span class="line"><span class="comment"> * 2. subscribed - when a client is subscribed to a topic</span></span><br><span class="line"><span class="comment"> * 3. unsubscribed - when a client is unsubscribed to a topic</span></span><br><span class="line"><span class="comment"> /********************************************************************/</span></span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;published&#x27;</span>, <span class="keyword">function</span> (<span class="params">packet, client</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Published Topic&#x27;</span>, packet.<span class="property">topic</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Published Payload&#x27;</span>, packet.<span class="property">payload</span>.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;subscribed&#x27;</span>, <span class="keyword">async</span> (topic) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="keyword">await</span> <span class="title function_">moscaHandle</span>(topic, <span class="number">100</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Subscribed&#x27;</span>, topic, ret)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;unsubscribed&#x27;</span>, <span class="keyword">function</span> (<span class="params">topic</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Ubsubscribed&#x27;</span>, topic)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;ready&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is running&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Mosca-的-setting"><a href="#Mosca-的-setting" class="headerlink" title="Mosca 的 setting"></a>Mosca 的 setting</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> settings = &#123;</span><br><span class="line">  <span class="attr">port</span>: confAddress.<span class="property">port</span>, <span class="comment">// mosca 服务的端口号</span></span><br><span class="line">  <span class="attr">backend</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;mongo&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;mongodb://localhost:27017/mqtt&#x27;</span>,</span><br><span class="line">    <span class="attr">pubsubCollection</span>: <span class="string">&#x27;mqtt201805&#x27;</span>,</span><br><span class="line">    <span class="attr">mongo</span>: &#123;&#125;</span><br><span class="line">  &#125;  <span class="comment">// 数据存储的方式,这里不仅可以用 mongodb 也可以用 MySQL, redis 等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 分页</title>
    <url>/2017/11/29/MySQL%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="一：分页需求："><a href="#一：分页需求：" class="headerlink" title="一：分页需求："></a>一：分页需求：</h2><p>客户端通过传递start(页码)，limit(每页显示的条数)两个参数去分页查询数据库表中的数据，那我们知道mysql数据库提供了分页的函数limit m,n，但是该函数的用法和我们的需求不一样，所以就需要我们根据实际情况去改写适合我们自己的分页语句，具体的分析如下：<br>比如：<br>查询第1条到第10条的数据的sql是：<code>select * from table limit 0,10;  </code></p>
<blockquote>
<p>对应我们的需求就是查询第一页的数据：select * from table limit (1-1)*10,10;</p>
</blockquote>
<p>查询第10条到第20条的数据的sql是：<code>select * from table limit 10,20;</code></p>
<blockquote>
<p>对应我们的需求就是查询第二页的数据：select * from table limit (2-1)*10,10;</p>
</blockquote>
<p>查询第20条到第30条的数据的sql是：<code>select * from table limit 20,30; </code></p>
<blockquote>
<p>对应我们的需求就是查询第三页的数据：select * from table limit (3-1)*10,10;</p>
</blockquote>
<h2 id="二：通过上面的分析，可以得出符合我们自己需求的分页sql格式是："><a href="#二：通过上面的分析，可以得出符合我们自己需求的分页sql格式是：" class="headerlink" title="二：通过上面的分析，可以得出符合我们自己需求的分页sql格式是："></a>二：通过上面的分析，可以得出符合我们自己需求的分页sql格式是：</h2><blockquote>
<p>select * from table limit (start-1)*limit,limit; 其中start是页码，limit是每页显示的条数。</p>
</blockquote>
]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL连接池</title>
    <url>/2017/11/29/MySQL%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>MySQL断线重连</p>
<p>分别模拟3种错误</p>
<p>登陆密码错误<br>数据库宕机<br>数据库连接超时<br>新增文件：app-reconnect.js</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~ vi app-reconnect.<span class="property">js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> conn;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleError</span> () &#123;</span><br><span class="line">    conn = mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        <span class="attr">user</span>: <span class="string">&#x27;nodejs&#x27;</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;nodejs&#x27;</span>,</span><br><span class="line">        <span class="attr">database</span>: <span class="string">&#x27;nodejs&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">3306</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接错误，2秒重试</span></span><br><span class="line">    conn.<span class="title function_">connect</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error when connecting to db:&#x27;</span>, err);</span><br><span class="line">            <span class="built_in">setTimeout</span>(handleError , <span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    conn.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;db error&#x27;</span>, err);</span><br><span class="line">        <span class="comment">// 如果是连接断开，自动重新连接</span></span><br><span class="line">        <span class="keyword">if</span> (err.<span class="property">code</span> === <span class="string">&#x27;PROTOCOL_CONNECTION_LOST&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">handleError</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">handleError</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="a-模拟密码错误"><a href="#a-模拟密码错误" class="headerlink" title="a. 模拟密码错误"></a>a. 模拟密码错误</h2><p>修改password: ‘nodejs11’</p>
<p>控制台输出。</p>
<blockquote>
<p>D:\workspace\javascript\nodejs-node-mysql&gt;node app-reconnect.js<br>error when connecting to db: { [Error: ER_ACCESS_DENIED_ERROR: Access denied for user ‘nodejs‘@’localhost’ (using pass<br>rd: YES)]<br>  code: ‘ER_ACCESS_DENIED_ERROR’,<br>  errno: 1045,<br>  sqlState: ‘28000’,<br>  fatal: true }<br>error when connecting to db: { [Error: ER_ACCESS_DENIED_ERROR: Access denied for user ‘nodejs‘@’localhost’ (using pass<br>rd: YES)]<br>  code: ‘ER_ACCESS_DENIED_ERROR’,<br>  errno: 1045,<br>  sqlState: ‘28000’,<br>  fatal: true }<br>b. 模拟数据库宕机<br>正常启动node，然后杀掉mysqld的进程。</p>
</blockquote>
<p>控制台输出。</p>
<blockquote>
<p>D:\workspace\javascript\nodejs-node-mysql&gt;node app-reconnect.js<br>db error { [Error: read ECONNRESET]<br>  code: ‘ECONNRESET’,<br>  errno: ‘ECONNRESET’,<br>  syscall: ‘read’,<br>  fatal: true }</p>
</blockquote>
<blockquote>
<p>Error: read ECONNRESET<br>    at errnoException (net.js:884:11)<br>    at TCP.onread (net.js:539:19)</p>
</blockquote>
<pre><code>这个异常，直接导致node程序被杀死！
</code></pre>
<h2 id="c-模拟连接超时，PROTOCOL-CONNECTION-LOST"><a href="#c-模拟连接超时，PROTOCOL-CONNECTION-LOST" class="headerlink" title="c. 模拟连接超时，PROTOCOL_CONNECTION_LOST"></a>c. 模拟连接超时，PROTOCOL_CONNECTION_LOST</h2><p>切换到root账户, 修改MySQL的wait_timeout参数，设置为10毫秒超时。</p>
<p>~ mysql -uroot -p<br>mysql&gt; show variables like ‘wait_timeout’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| wait_timeout  | 28800 |<br>+—————+——-+<br>1 row in set (0.00 sec)</p>
<p>mysql&gt; set global wait_timeout&#x3D;10;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; show variables like ‘wait_timeout’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| wait_timeout  | 10    |<br>+—————+——-+<br>1 row in set (0.00 sec)<br>修改文件：app-reconnection.js，在最后增加代码</p>
<p>~ vi app-reconnection.js</p>
<p>function query(){<br>    console.log(new Date());<br>    var sql &#x3D; “show variables like ‘wait_timeout’”;<br>    conn.query(sql, function (err, res) {<br>        console.log(res);<br>    });<br>}</p>
<p>query();<br>setInterval(query, 15*1000);<br>程序会每融15秒，做一次查询。</p>
<h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><blockquote>
<p>D:\workspace\javascript\nodejs-node-mysql&gt;node app-reconnect.js<br>Wed Sep 11 2013 15:21:14 GMT+0800 (中国标准时间)<br>[ { Variable_name: ‘wait_timeout’, Value: ‘10’ } ]<br>db error { [Error: Connection lost: The server closed the connection.] fatal: true, code: ‘PROTOCOL_CONNECTION_LOST’ }<br>Wed Sep 11 2013 15:21:28 GMT+0800 (中国标准时间)<br>[ { Variable_name: ‘wait_timeout’, Value: ‘10’ } ]<br>db error { [Error: Connection lost: The server closed the connection.] fatal: true, code: ‘PROTOCOL_CONNECTION_LOST’ }<br>Wed Sep 11 2013 15:21:43 GMT+0800 (中国标准时间)<br>[ { Variable_name: ‘wait_timeout’, Value: ‘10’ } ]<br>我们自己的程序捕获了“PROTOCOL_CONNECTION_LOST”异常，并自动的实现了数据库重连。</p>
</blockquote>
<h2 id="4-MySQL连接池的超时测试"><a href="#4-MySQL连接池的超时测试" class="headerlink" title="4). MySQL连接池的超时测试"></a>4). MySQL连接池的超时测试</h2><p>针对wait_timeout问题，我们再对连接做一下测试。</p>
<p>修改app-pooling.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> pool = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;nodejs&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;nodejs&#x27;</span>,</span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;nodejs&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3306</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> selectSQL =<span class="string">&quot;show variables like &#x27;wait_timeout&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">pool.<span class="title function_">getConnection</span>(<span class="keyword">function</span> (<span class="params">err, conn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;POOL ==&gt; &quot;</span> + err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">query</span>(<span class="params"></span>)&#123;</span><br><span class="line">        conn.<span class="title function_">query</span>(selectSQL, <span class="keyword">function</span> (<span class="params">err, res</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">            conn.<span class="title function_">release</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">query</span>();</span><br><span class="line">    <span class="built_in">setInterval</span>(query, <span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<blockquote>
<p>D:\workspace\javascript\nodejs-node-mysql&gt;node app-pooling.js<br>Wed Sep 11 2013 15:32:25 GMT+0800 (中国标准时间)<br>[ { Variable_name: ‘wait_timeout’, Value: ‘10’ } ]<br>Wed Sep 11 2013 15:32:30 GMT+0800 (中国标准时间)<br>[ { Variable_name: ‘wait_timeout’, Value: ‘10’ } ]<br>Wed Sep 11 2013 15:32:35 GMT+0800 (中国标准时间)<br>[ { Variable_name: ‘wait_timeout’, Value: ‘10’ } ]<br>连接池，已经解决了自动重连的问题了，后面我们的开发，可以尽量使用pooling的方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx 配置</title>
    <url>/2017/11/27/Nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Nginx配置参数中文说明"><a href="#Nginx配置参数中文说明" class="headerlink" title="Nginx配置参数中文说明"></a>Nginx配置参数中文说明</h2><blockquote>
<p>.\conf\ - 配置文件目录<br>.\conf\nginx.conf - 主配置文件<br>.\html\ - 默认网站文件位置<br>.\log\ - 默认日志文件位置<br>HTTP默认端口： TCP 80<br>HTTPS默认端口：* TCP 443</p>
</blockquote>
<span id="more"></span>
<h2 id="nginx-conf配置介绍"><a href="#nginx-conf配置介绍" class="headerlink" title="nginx.conf配置介绍"></a>nginx.conf配置介绍</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#定义<span class="title class_">Nginx</span>运行的用户和用户组</span><br><span class="line">#user  nobody; </span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于<span class="variable constant_">CPU</span>总核心数。</span><br><span class="line">worker_processes  <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">#error_log  logs/error.<span class="property">log</span>;</span><br><span class="line">#error_log  logs/error.<span class="property">log</span>  notice;</span><br><span class="line">#error_log  logs/error.<span class="property">log</span>  info;</span><br><span class="line"></span><br><span class="line">#进程文件</span><br><span class="line">#pid        logs/nginx.<span class="property">pid</span>;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定http服务器</span><br><span class="line">http &#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include       mime.<span class="property">types</span>;</span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    #                  <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    #                  <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.<span class="property">log</span>  main;</span><br><span class="line"></span><br><span class="line">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘<span class="variable constant_">IO</span>重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改 成off。</span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    #防止网络阻塞</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    #keepalive_timeout  <span class="number">0</span>;</span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    #开启gzip压缩输出</span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #默认编码</span><br><span class="line">        #charset utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        #定义本虚拟主机的访问日志</span><br><span class="line">        #access_log  logs/host.<span class="property">access</span>.<span class="property">log</span>  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the <span class="keyword">static</span> page /50x.<span class="property">html</span></span><br><span class="line">        #</span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.<span class="property">html</span>;</span><br><span class="line">        location = /50x.<span class="property">html</span> &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the <span class="variable constant_">PHP</span> scripts to <span class="title class_">Apache</span> listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">80</span></span><br><span class="line">        #</span><br><span class="line">        #location ~ \.<span class="property">php$</span> &#123;</span><br><span class="line">        #    proxy_pass   <span class="attr">http</span>:<span class="comment">//127.0.0.1;</span></span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the <span class="variable constant_">PHP</span> scripts to <span class="title class_">FastCGI</span> server listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span></span><br><span class="line">        #</span><br><span class="line">        #location ~ \.<span class="property">php$</span> &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span>;</span><br><span class="line">        #    fastcgi_index  index.<span class="property">php</span>;</span><br><span class="line">        #    fastcgi_param  <span class="variable constant_">SCRIPT_FILENAME</span>  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .<span class="property">htaccess</span> files, <span class="keyword">if</span> <span class="title class_">Apache</span><span class="string">&#x27;s document root</span></span><br><span class="line"><span class="string">        # concurs with nginx&#x27;</span>s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.<span class="property">ht</span> &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix <span class="keyword">of</span> <span class="variable constant_">IP</span>-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       <span class="number">8000</span>;</span><br><span class="line">    #    listen       <span class="attr">somename</span>:<span class="number">8080</span>;</span><br><span class="line">    #    server_name  somename  alias  another.<span class="property">alias</span>;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # <span class="variable constant_">HTTPS</span> server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       <span class="number">443</span> ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.<span class="property">pem</span>;</span><br><span class="line">    #    ssl_certificate_key  cert.<span class="property">key</span>;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    <span class="attr">shared</span>:<span class="attr">SSL</span>:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  <span class="attr">HIGH</span>:!<span class="attr">aNULL</span>:!<span class="title class_">MD5</span>;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>Node.js EventEmitter</title>
    <url>/2020/02/27/Node.js%20EventEmitter/</url>
    <content><![CDATA[<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><blockquote>
<p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。Node.js 里面的许多对象都会分发事件,而这所有这些产生事件的对象都是 events.EventEmitter 的实例.events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装.了解EventEmitter对象可以帮助理解 node是怎么运作的,也可以自己写事件监听和触发.</p>
</blockquote>
<span id="more"></span>

<h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码:"></a>样例代码:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> events.<span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器1</span></span><br><span class="line"><span class="keyword">const</span> listener1 = <span class="keyword">function</span> <span class="title function_">listener1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听器 listener1 执行。&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器2</span></span><br><span class="line"><span class="keyword">const</span> listener2 = <span class="keyword">function</span> <span class="title function_">listener2</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听器 listener2 执行。args=&#x27;</span>,args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 connection 事件，处理函数为 listener1</span></span><br><span class="line">eventEmitter.<span class="title function_">addListener</span>(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 connection 事件，处理函数为 listener2</span></span><br><span class="line"><span class="comment">// eventEmitter.addListener === eventEmitter.on</span></span><br><span class="line"><span class="comment">// eventEmitter.addListener是emitter.on() 的别名</span></span><br><span class="line"><span class="comment">// 注册事件时推荐使用 Symbol对象,这样事件名就不会重复了</span></span><br><span class="line">eventEmitter.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件监听者个数</span></span><br><span class="line"><span class="keyword">const</span> eventListeners = eventEmitter.<span class="title function_">listenerCount</span>(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(eventListeners + <span class="string">&#x27; 个监听器监听连接事件。&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 connection 事件</span></span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除监绑定的 listener1 函数</span></span><br><span class="line">eventEmitter.<span class="title function_">removeListener</span>(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listener1 不再受监听。&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 connection 事件</span></span><br><span class="line"><span class="comment">// emit 方法还可以传多个参数</span></span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件监听者个数</span></span><br><span class="line">eventListeners = eventEmitter.<span class="title function_">listenerCount</span>(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(eventListeners + <span class="string">&#x27; 个监听器监听连接事件。&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;程序执行完毕。&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ node main.<span class="property">js</span></span><br><span class="line"><span class="number">2</span> 个监听器监听连接事件。</span><br><span class="line"><span class="comment">// 注意这里响应事件监听者的执行也是有顺序的</span></span><br><span class="line">监听器 listener1 执行。</span><br><span class="line">监听器 listener2 执行。args=</span><br><span class="line">listener1 不再受监听。</span><br><span class="line">监听器 listener2 执行。args=<span class="number">123</span></span><br><span class="line"><span class="number">1</span> 个监听器监听连接事件。</span><br><span class="line">程序执行完毕。</span><br></pre></td></tr></table></figure>
<h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如<code>catch (err)&#123;&#125;</code></p>
<h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<ol>
<li><p>具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>
</li>
<li><p>JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
</li>
</ol>
<p><a href="http://nodejs.cn/api/events.html#events_emitter_addlistener_eventname_listener">详细 API 文档</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>PM2命令表</title>
    <url>/2017/11/29/PM2/</url>
    <content><![CDATA[<p><img src="http://p04c6djlz.bkt.clouddn.com//17-11-29/66585958.jpg"></p>
<span id="more"></span>
<h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><p>$ npm install pm2 -g # Install PM2<br> $ pm2 start app.js # Start, Daemonize and auto-restart application (Node)<br> $ pm2 start <a href="http://app.py/">app.py</a> # Start, Daemonize and auto-restart application (Python)<br> $ pm2 start npm – start # Start, Daemonize and auto-restart Node application</p>
<h1 id="Cluster-Mode-Node-js-only"><a href="#Cluster-Mode-Node-js-only" class="headerlink" title="Cluster Mode (Node.js only)"></a>Cluster Mode (Node.js only)</h1><p>$ pm2 start app.js -i 4 # Start 4 instances of application in cluster mode<br> # it will load balance network queries to each app<br> $ pm2 reload all # Zero Second Downtime Reload<br> $ pm2 scale [app-name] 10 # Scale Cluster app to 10 process</p>
<h1 id="Process-Monitoring"><a href="#Process-Monitoring" class="headerlink" title="Process Monitoring"></a>Process Monitoring</h1><p>$ pm2 list # List all processes started with PM2<br> $ pm2 monit # Display memory and cpu usage of each app<br> $ pm2 show [app-name] # Show all information about application</p>
<h1 id="Log-management"><a href="#Log-management" class="headerlink" title="Log management"></a>Log management</h1><p>$ pm2 logs # Display logs of all apps<br> $ pm2 logs [app-name] # Display logs for a specific app<br> $ pm2 logs –json # Logs in JSON format<br> $ pm2 flush<br> $ pm2 reloadLogs</p>
<h1 id="Process-State-Management"><a href="#Process-State-Management" class="headerlink" title="Process State Management"></a>Process State Management</h1><p>$ pm2 start app.js –name&#x3D;”api” # Start application and name it “api”<br> $ pm2 start app.js – -a 34 # Start app and pass option “-a 34” as argument<br> $ pm2 start app.js –watch # Restart application on file change<br> $ pm2 start <a href="http://script.sh/">script.sh</a> # Start bash script<br> $ pm2 start app.json # Start all applications declared in app.json<br> $ pm2 reset [app-name] # Reset all counters<br> $ pm2 stop all # Stop all apps<br> $ pm2 stop 0 # Stop process with id 0<br> $ pm2 restart all # Restart all apps<br> $ pm2 gracefulReload all # Gracefully reload all apps in cluster mode<br> $ pm2 delete all # Kill and delete all apps<br> $ pm2 delete 0 # Delete app with id 0</p>
<h1 id="Startup-x2F-Boot-management"><a href="#Startup-x2F-Boot-management" class="headerlink" title="Startup&#x2F;Boot management"></a>Startup&#x2F;Boot management</h1><p>$ pm2 startup # Detect init system, generate and configure pm2 boot on startup<br> $ pm2 save # Save current process list<br> $ pm2 resurrect # Restore previously saved processes<br> $ pm2 unstartup # Disable and remove startup system</p>
<p>$ pm2 update # Save processes, kill PM2 and restore processes<br> $ pm2 generate # Generate a sample json configuration file</p>
<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>$ pm2 deploy app.json prod setup # Setup “prod” remote server<br> $ pm2 deploy app.json prod # Update “prod” remote server<br> $ pm2 deploy app.json prod revert 2 # Revert “prod” remote server by 2</p>
<h1 id="Module-system"><a href="#Module-system" class="headerlink" title="Module system"></a>Module system</h1><p>$ pm2 module:generate [name] # Generate sample module with name [name]</p>
<p> $ pm2 install pm2-logrotate # Install module (here a log rotation system)<br> $ pm2 uninstall pm2-logrotate # Uninstall module<br> $ pm2 publish # Increment version, git push and npm publish</p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2017/11/29/Promise/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getApplyQueue</span> = (<span class="params">ownerId, channelId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sql = <span class="string">`select * from ApplyQueue where channelId=&quot;<span class="subst">$&#123;channelId&#125;</span>&quot; and ownerId=&quot;<span class="subst">$&#123;ownerId&#125;</span>&quot;order by time`</span>;</span><br><span class="line">    db.<span class="title function_">query</span>(sql, <span class="function">(<span class="params">err, userList</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(userList.<span class="property">length</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="string">`null`</span>) <span class="comment">// 这里如果不加 return 代码会向下执行</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`userList is <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(userList)&#125;</span>`</span>)</span><br><span class="line">      <span class="title function_">getUserInfoByArray</span>(userList).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(data)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`err is <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="Promise-resolve和reject的数据都是要在后续的-then-或者-catch-中才能会获取到"><a href="#Promise-resolve和reject的数据都是要在后续的-then-或者-catch-中才能会获取到" class="headerlink" title="Promise resolve和reject的数据都是要在后续的.then()或者.catch()中才能会获取到"></a>Promise resolve和reject的数据都是要在后续的.then()或者.catch()中才能会获取到</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promise</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">promise</span>(-<span class="number">1</span>))    <span class="comment">//输出Promise &#123; 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>promise(-1)执行的结果应该是resolve(1)，但是打印出来的并不是1，而是Promise{1}，这是经过Promise对象封装过的，他是不等于1的</p>
<blockquote>
<p>promise(-1) &#x3D;&#x3D; 1  &#x2F;&#x2F;false</p>
</blockquote>
<p>所以resolve和reject的数据和直接return还是有不一样的</p>
<p>如果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return new Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>
<p>这样写，那么Promise里的数据只有用resolve()或者reject()才能传到.then()里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.then((v) =&gt; &#123;</span><br><span class="line">  return 123;</span><br><span class="line">&#125;).then(v =&gt; &#123;</span><br><span class="line">console.log(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果then里的是一个function，那么它return的数据可以直接传到下一个then里。</p>
<h2 id="Promise-的链式写法"><a href="#Promise-的链式写法" class="headerlink" title="Promise 的链式写法"></a>Promise 的链式写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">runAsync1</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">runAsync2</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">runAsync3</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="如果提前把函数用Promise封装好，那么就可以在then里写一个函数然后return那个用Promise封装好的函数，这样下一个then里接收的就是上一个return的Promise函数的resolve"><a href="#如果提前把函数用Promise封装好，那么就可以在then里写一个函数然后return那个用Promise封装好的函数，这样下一个then里接收的就是上一个return的Promise函数的resolve" class="headerlink" title="如果提前把函数用Promise封装好，那么就可以在then里写一个函数然后return那个用Promise封装好的函数，这样下一个then里接收的就是上一个return的Promise函数的resolve"></a>如果提前把函数用Promise封装好，那么就可以在then里写一个函数然后return那个用Promise封装好的函数，这样下一个then里接收的就是上一个return的Promise函数的resolve</h2><p>.then()函数其实接收2个参数，第一个是上一个Promise的resolve，第二个就是reject。而.catch()其实是一个类似语法糖的东西，他接收的也是err，这是为了让代码看起来逻辑更加清晰。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fuc</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data&gt;<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fuc</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line">完全等同于</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fuc</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data&gt;<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fuc</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。也就是说-catch-不仅仅接收上一个Promise的reject或者错误，还接收上一个-then-的错误"><a href="#不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。也就是说-catch-不仅仅接收上一个Promise的reject或者错误，还接收上一个-then-的错误" class="headerlink" title="不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。也就是说.catch()不仅仅接收上一个Promise的reject或者错误，还接收上一个.then()的错误"></a>不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。也就是说.catch()不仅仅接收上一个Promise的reject或者错误，还接收上一个.then()的错误</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getNumber</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(somedata); <span class="comment">//此处的somedata未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.all()是一个遍历Promise对象的方法，他的参数就是装着Promise对象的数组。然后在并发的执行参数里的Promise，最后会依次的把各个Promise resolve的结果返回到最后的then里，依次的装到数组里。如果有其中任何一个 Promise reject 了,那 Promise.all() 返回的将会是空{}.</li>
<li>如果这个promise队列里出现了reject，那么Promise.all()返回的结果会被一个reject而报销（其他正常返回也没用了），所以为此你最好使队列每一个ajax封装一个:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.race(ajax,()=&gt;new Promise(resolve=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;reslove(&#x27;timeout&#x27;),3000)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>这样也可以解决某一个ajax响应时间巨长，导致Promise.all()一直pending的问题</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 学习笔记</title>
    <url>/2021/03/24/TypeScript%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="TypeScript笔记"><a href="#TypeScript笔记" class="headerlink" title="TypeScript笔记"></a>TypeScript笔记</h1><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="unknown类型"><a href="#unknown类型" class="headerlink" title="unknown类型"></a>unknown类型</h3><p>unknown 类型用于解决any类型使用过于宽松的问题, unknown可以赋任何值,但是unknown不能赋值给其他参数(any和unknown除外)<br>any类型甚至可以是function,但是unknown类型在赋值之前无法当做方法或者数组来使用</p>
<h3 id="tuple元祖"><a href="#tuple元祖" class="headerlink" title="tuple元祖"></a>tuple元祖</h3><p>TS的数据要求是同种类型的值组成,当需要不同类型的值组成组数时,就需要用到tuple<br>元祖需要在申明变量时就固定值类型与数量比如:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能不符合类型,也不能多不能少</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tupleValue</span>: [<span class="built_in">string</span>, <span class="built_in">boolean</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;abc&#x27;</span>, <span class="literal">false</span>, <span class="number">123</span>];</span><br></pre></td></tr></table></figure>

<h3 id="object-Object-的区别"><a href="#object-Object-的区别" class="headerlink" title="object,Object,{}的区别"></a>object,Object,{}的区别</h3><h4 id="object是一个数据类型-可用于声明变量-但是微软现在不建议这样使用-而是建议使用Record-lt-string-unknown-gt"><a href="#object是一个数据类型-可用于声明变量-但是微软现在不建议这样使用-而是建议使用Record-lt-string-unknown-gt" class="headerlink" title="object是一个数据类型,可用于声明变量,但是微软现在不建议这样使用,而是建议使用Record&lt;string, unknown&gt;"></a>object是一个数据类型,可用于声明变量,但是微软现在不建议这样使用,而是建议使用<code>Record&lt;string, unknown&gt;</code></h4><h4 id="Object-是所有-Object-类的实例类型-与JS的Object使用类似"><a href="#Object-是所有-Object-类的实例类型-与JS的Object使用类似" class="headerlink" title="Object 是所有 Object 类的实例类型,与JS的Object使用类似"></a>Object 是所有 Object 类的实例类型,与JS的Object使用类似</h4><h4 id="是一个没有成员的对象-是一个具体的对象数据-不是一个类型"><a href="#是一个没有成员的对象-是一个具体的对象数据-不是一个类型" class="headerlink" title="{} 是一个没有成员的对象,是一个具体的对象数据,不是一个类型"></a>{} 是一个没有成员的对象,是一个具体的对象数据,不是一个类型</h4><h3 id="Never-类型"><a href="#Never-类型" class="headerlink" title="Never 类型"></a>Never 类型</h3><p>never 表示那些用不存在的值的类型,常用于断言或者保证方法逻辑性<br><strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码</strong></p>
<span id="more"></span>

<h2 id="TypeScript-断言"><a href="#TypeScript-断言" class="headerlink" title="TypeScript 断言"></a>TypeScript 断言</h2><p>可以在变量的前面加上<type>,或者在变量后加上 as type,强调变量的类型.<br>如果想变量不为 undefined 或者 null,可以在赋值的时候后面加上!,例如:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params">maybeString: <span class="built_in">string</span> | <span class="literal">undefined</span> | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">onlyString</span>: <span class="built_in">string</span> = maybeString; <span class="comment">// Error 不能将类型“string | null | undefined”分配给类型“string”。不能将类型“undefined”分配给类型“string”。ts(2322)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">ignoreUndefinedAndNull</span>: <span class="built_in">string</span> = maybeString!; <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>TS 中可以通过&amp;符号将 2 个类型合并成一个新类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointX</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="title class_">PartialPointX</span> &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">point</span>: <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果有同名变量但是类型(基础类型)不一致时,该变量类型会变成 never<br>如果是非基础类型,例如重新构建的对象类型,就可以同时接受多种类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> D &#123; <span class="attr">d</span>: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> E &#123; <span class="attr">e</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> F &#123; <span class="attr">f</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">x</span>: D; &#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123; <span class="attr">x</span>: E; &#125;</span><br><span class="line"><span class="keyword">interface</span> C &#123; <span class="attr">x</span>: F; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ABC</span> = A &amp; B &amp; C;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时x 可以接受 boolean,string,number三种类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">abc</span>: <span class="variable constant_">ABC</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&#x27;semlinker&#x27;</span>,</span><br><span class="line">    <span class="attr">f</span>: <span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abc:&#x27;</span>, abc);</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-函数"><a href="#TypeScript-函数" class="headerlink" title="TypeScript 函数"></a>TypeScript 函数</h2><h3 id="与-JavaScript-的区别"><a href="#与-JavaScript-的区别" class="headerlink" title="与 JavaScript 的区别"></a>与 JavaScript 的区别</h3><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210319142042.png"></p>
<h4 id="ts-函数参数需要声明类型-函数的返回值类型也需要声明-可选参数也需要声明"><a href="#ts-函数参数需要声明类型-函数的返回值类型也需要声明-可选参数也需要声明" class="headerlink" title="ts 函数参数需要声明类型,函数的返回值类型也需要声明,可选参数也需要声明"></a>ts 函数参数需要声明类型,函数的返回值类型也需要声明,可选参数也需要声明</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里声明了age 是可选参数,性别的默认值是女性,函数无返回值</span></span><br><span class="line"><span class="comment">// 可选参数一般放在最后位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">name: <span class="built_in">string</span>, gender: <span class="built_in">string</span> = <span class="string">&#x27;female, age?: number): void &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="有了严格的方法参数定义后-TS-就有了函数重载"><a href="#有了严格的方法参数定义后-TS-就有了函数重载" class="headerlink" title="有了严格的方法参数定义后,TS 就有了函数重载"></a>有了严格的方法参数定义后,TS 就有了函数重载</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="comment">// type Combinable = string | number;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-接口"><a href="#TypeScript-接口" class="headerlink" title="TypeScript 接口"></a>TypeScript 接口</h2><p>TS 比 JS 更加的面向对象,它是支持接口 interface 的.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">semlinker</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以在声明接口的时候设定变量为可读(readonly),同时也可以设置可选(!)变量</p>
<h3 id="interface-与-type-的区别"><a href="#interface-与-type-的区别" class="headerlink" title="interface 与 type 的区别"></a>interface 与 type 的区别</h3><p>两者都是用来描述对象的形状或者函数签名,与接口类型不一样，类型别名可以用于一些其他类型，比如原始类型、联合类型和元组,interface 主要用于描述对象和函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// primitive</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointX</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointY</span> = &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPoint</span> = <span class="title class_">PartialPointX</span> | <span class="title class_">PartialPointY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br></pre></td></tr></table></figure>

<p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>


<h3 id="继承extends与实现Implements"><a href="#继承extends与实现Implements" class="headerlink" title="继承extends与实现Implements"></a>继承extends与实现Implements</h3><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>TS 对象的继承就类似于&amp; 交叉合并,但是 extends 可读性更好</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PartialPointX</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">PartialPointX</span> &#123; </span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointX</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="title class_">PartialPointX</span> &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>不过一般情况下extends更加倾向于一个对象或者方法继承了父类,是面向对象的一种理念,而不是单纯的交叉合并.</p>
<h4 id="Implements"><a href="#Implements" class="headerlink" title="Implements"></a>Implements</h4><p>实现 interface,但类不能实现使用类型别名定义的联合类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomePoint</span> <span class="keyword">implements</span> <span class="title class_">Point</span> &#123; <span class="comment">// OK</span></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPoint</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125; | &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="comment">// A class can only implement an object type or </span></span><br><span class="line"><span class="comment">// intersection of object types with statically known members.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomePartialPoint</span> <span class="keyword">implements</span> <span class="title class_">PartialPoint</span> &#123; <span class="comment">// Error</span></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-的面向对象"><a href="#TypeScript-的面向对象" class="headerlink" title="TypeScript 的面向对象"></a>TypeScript 的面向对象</h2><p>首先是支持静态变量和静态方法 static<br>静态就是所有的实例对象都公共的,例如:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="attr">time</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里所有的人类实例都共享一个共同的 time 变量,但是 name 变量就是每个实例自己的,方法也是同理,而且静态变量和静态方法一般不要改动</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-ECMAScript-私有字段"><a href="#11-2-ECMAScript-私有字段" class="headerlink" title="11.2 ECMAScript 私有字段"></a>11.2 ECMAScript 私有字段</h3><p>在 TypeScript 3.8 版本就开始支持ECMAScript 私有字段，使用方式如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"></span><br><span class="line">semlinker.#name; <span class="comment">// ERROR</span></span><br><span class="line"><span class="comment">// Property #name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure>

<p>与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：</p>
<ol>
<li>私有字段以 # 字符开头，有时我们称之为私有名称；</li>
<li>每个私有字段名称都唯一地限定于其包含的类；</li>
<li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li>
<li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li>
</ol>
<p><a href="https://qastack.cn/programming/59641564/what-are-the-differences-between-the-private-keyword-and-private-fields-in-types">private 与# 的区别</a></p>
<p>私有变量可以使用 getter 和 setter 方法来访问或者修改私有变量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&quot;Hello TypeScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&quot;Hello TypeScript&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&quot;Semlinker&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-支持抽象-abstract"><a href="#TypeScript-支持抽象-abstract" class="headerlink" title="TypeScript 支持抽象 abstract"></a>TypeScript 支持抽象 abstract</h3><p>使用 abstract 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">say</span>(<span class="attr">words</span>: <span class="built_in">string</span>) :<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot create an instance of an abstract class.(2511)</span></span><br><span class="line"><span class="keyword">const</span> lolo = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。具体如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">say</span>(<span class="attr">words</span>: <span class="built_in">string</span>) :<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Developer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">say</span>(<span class="attr">words</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says <span class="subst">$&#123;words&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lolo = <span class="keyword">new</span> <span class="title class_">Developer</span>(<span class="string">&quot;lolo&quot;</span>);</span><br><span class="line">lolo.<span class="title function_">say</span>(<span class="string">&quot;I love ts!&quot;</span>); <span class="comment">// lolo says I love ts!</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-类方法支持重载"><a href="#TypeScript-类方法支持重载" class="headerlink" title="TypeScript 类方法支持重载"></a>TypeScript 类方法支持重载</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    <span class="title function_">getProducts</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">getProducts</span>(<span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">getProducts</span>(<span class="params">id?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> id === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取id为 <span class="subst">$&#123;id&#125;</span> 的产品信息`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取所有的产品信息`</span>);</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> productService = <span class="keyword">new</span> <span class="title class_">ProductService</span>();</span><br><span class="line">productService.<span class="title function_">getProducts</span>(<span class="number">666</span>); <span class="comment">// 获取id为 666 的产品信息</span></span><br><span class="line">productService.<span class="title function_">getProducts</span>(); <span class="comment">// 获取所有的产品信息 </span></span><br></pre></td></tr></table></figure>

<h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><p>泛型顾名思义就是广泛的类型,不特指某种类型.语法上表现为<T>.例如:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity &lt;T, U&gt;(<span class="attr">value</span>: T, <span class="attr">message</span>: U) : T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(identity&lt;<span class="title class_">Number</span>, <span class="built_in">string</span>&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码中的&lt;T, U&gt; 其实只是一个占位符,或者说是一个类型参数,当调用 identity 方法时,传入该位置的&lt;Number, string&gt;就取代了方法中 T 和 U 的位置,也就是说identity 方法就变成了:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity &lt;<span class="title class_">Number</span>, <span class="built_in">string</span>&gt;(<span class="attr">value</span>: <span class="title class_">Number</span>, <span class="attr">message</span>: <span class="built_in">string</span>) : <span class="title class_">Number</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为泛型只是个占位符,所以定义的时候用什么符号其实都可以,你也可以用<code>&lt;A&gt;&lt;B&gt;&lt;C&gt;</code>, 但是使用上习惯用<code>&lt;T&gt;</code>. 表示 Type<br>除了 T 之外，以下是常见泛型变量代表的意思：</p>
<ul>
<li>K（Key）：表示对象中的键类型；</li>
<li>V（Value）：表示对象中的值类型；</li>
<li>E（Element）：表示元素类型。</li>
</ul>
<p>泛型可以使用在接口,类,方法.</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么?"></a>装饰器是什么?</h3><p>首先看代码例子</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">greeting: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span>(<span class="string">&quot;Hello TS!&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 内部实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">(myGreeting <span class="keyword">as</span> <span class="built_in">any</span>).<span class="title function_">greet</span>(); <span class="comment">// console output: &#x27;Hello TS!&#x27;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的@Greeter 就类似于当前的 Greeting 类继承了@Greeter</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，若要启用实验性的装饰器特性，你必须在命令行或 tsconfig.json 里启用 experimentalDecorators 编译器选项：</p>
<p>命令行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure>

<p>tsconfig.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES5&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="装饰器分类"><a href="#装饰器分类" class="headerlink" title="装饰器分类"></a>装饰器分类</h3><p>装饰器大致上可以分为以下几种:</p>
<ol>
<li>类装饰器</li>
<li>属性装饰器</li>
<li>方法装饰器</li>
<li>方法参数装饰器</li>
</ol>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>对类使用,可传入一个隐式参数作为类的构造参数,或者不传<br>但是默认会将被装饰的类做为参数传入</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logClz</span>(<span class="params">注意：参数装饰器只能用来监视一个方法的参数是否被传入；:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    params.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">url</span> = <span class="string">&#x27;xxxx&#x27;</span>;</span><br><span class="line">    params.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run...&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@logClz</span> <span class="comment">// 这里将 HttpClient 类传到 logClz</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpClient</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">http</span>:<span class="built_in">any</span> = <span class="keyword">new</span> <span class="title class_">HttpClient</span>();</span><br><span class="line">http.<span class="title function_">run</span>(); <span class="comment">// run...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logClz</span>(<span class="params">params:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;params:&#x27;</span>, params);  <span class="comment">//params: hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;target:&#x27;</span>, target);  <span class="comment">//target: class HttpClient</span></span><br><span class="line">        target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">url</span> = params;  <span class="comment">//扩展一个url属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入参数,target 就是 HttpClient</span></span><br><span class="line"><span class="meta">@logClz</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpClient</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">http</span>:<span class="built_in">any</span> = <span class="keyword">new</span> <span class="title class_">HttpClient</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(http.<span class="property">url</span>);  <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>


<h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>对类的属性装饰的叫属性装饰器,有 2 个隐式参数:</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象；其实就是当前类</li>
<li>属性成员名</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProp</span>(<span class="params">params:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, attr:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(target)  <span class="comment">// &#123; constructor:f, getData:f &#125; (HttpClient)</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(attr)  <span class="comment">// url</span></span><br><span class="line">        target[attr] = params;  <span class="comment">//通过原型对象修改属性值 = 装饰器传入的参数</span></span><br><span class="line">        target.<span class="property">api</span> = <span class="string">&#x27;xxxxx&#x27;</span>;  <span class="comment">//扩展属性</span></span><br><span class="line">        target.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">//扩展方法</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run...&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpClient</span> &#123;</span><br><span class="line">    <span class="meta">@logProp</span>(<span class="string">&#x27;http://baidu.com&#x27;</span>) <span class="comment">// target: HttpClient, attr: url</span></span><br><span class="line">    <span class="keyword">public</span> <span class="attr">url</span>:<span class="built_in">any</span>|<span class="literal">undefined</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">http</span>:<span class="built_in">any</span> = <span class="keyword">new</span> <span class="title class_">HttpClient</span>();</span><br><span class="line">http.<span class="title function_">getData</span>();  <span class="comment">// http://baidu.com</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(http.<span class="property">api</span>);  <span class="comment">// xxxxx</span></span><br><span class="line">http.<span class="title function_">run</span>();  <span class="comment">// run...</span></span><br></pre></td></tr></table></figure>

<h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><ul>
<li>方法装饰器被应用到方法的属性描述符上，可以用来监视、修改、替换方法的定义；</li>
<li>方法装饰器会在运行时传入3个参数：</li>
</ul>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象；(当前类)</li>
<li>成员的名字；(方法名)</li>
<li>成员的属性描述符；({value: ƒ, writable: true, enumerable: false, configurable: true} value就是方法体)</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">params:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(params) <span class="comment">// 装饰器传入的参数：http://baidu.com</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, desc:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(target)  <span class="comment">// &#123; constructor:f, getData:f &#125; </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(methodName)  <span class="comment">// getData</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(desc)  <span class="comment">// &#123;value: ƒ, writable: true, enumerable: false, configurable: true&#125; value就是方法体</span></span><br><span class="line">        <span class="comment">/* 修改被装饰的方法 */</span></span><br><span class="line">        <span class="comment">//1. 保存原方法体</span></span><br><span class="line">        <span class="keyword">var</span> oldMethod = desc.<span class="property">value</span>;</span><br><span class="line">        <span class="comment">//2. 重新定义方法体</span></span><br><span class="line">        desc.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">            <span class="comment">//3. 把传入的数组元素都转为字符串</span></span><br><span class="line">            <span class="keyword">let</span> newArgs = args.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">String</span>(item);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//4. 执行原来的方法体</span></span><br><span class="line">            oldMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, newArgs);</span><br><span class="line">            <span class="comment">// 等效于 oldMethod.call(this, ...newArgs);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpClient</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="meta">@get</span>(<span class="string">&#x27;http://baidu.com&#x27;</span>)</span><br><span class="line">    <span class="title function_">getData</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getData: &#x27;</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> <span class="title class_">HttpClient</span>();</span><br><span class="line">http.<span class="title function_">getData</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>);  <span class="comment">// getData: [&quot;1&quot;, &quot;2&quot;, &quot;true&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="方法参数装饰器"><a href="#方法参数装饰器" class="headerlink" title="方法参数装饰器"></a>方法参数装饰器</h3><ul>
<li>参数装饰器表达式会在运行时被调用，可以为类的原型增加一些元素数据，传入3个参数：</li>
</ul>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型(类)</li>
<li>方法名称，如果装饰的是构造函数的参数，则值为undefined(functionName)</li>
<li>参数在函数参数列表中的索引；(参数下标)</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logParams</span>(<span class="params">params:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(params)  <span class="comment">// 装饰器传入的参数：uuid</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, paramIndex:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(target)  <span class="comment">// &#123; constructor:f, getData:f &#125; </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(methodName)  <span class="comment">// getData</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(paramIndex)  <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpClient</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">getData</span>(<span class="params"><span class="meta">@logParams</span>(<span class="string">&#x27;uuid&#x27;</span>) uuid:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="keyword">new</span> <span class="title class_">HttpClient</span>();</span><br><span class="line">http.<span class="title function_">getData</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：参数装饰器只能用来监视一个方法的参数是否被传入；</li>
</ul>
<h3 id="装饰器的执行顺序"><a href="#装饰器的执行顺序" class="headerlink" title="装饰器的执行顺序"></a>装饰器的执行顺序</h3><ul>
<li>装饰器组合：TS支持多个装饰器同时装饰到一个声明上，语法支持从左到右，或从上到下书写；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@f @g x</span><br><span class="line"></span><br><span class="line">@f</span><br><span class="line">@g</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p>
<ol>
<li>由上至下依次对装饰器表达式求值;</li>
<li>求值的结果会被当作函数，由下至上依次调用.</li>
</ol>
</li>
<li><p>不同装饰器的执行顺序：属性装饰器 &gt; 方法装饰器 &gt; 参数装饰器 &gt; 类装饰器</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logClz11</span>(<span class="params">params:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logClz11&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logClz22</span>(<span class="params">params?:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logClz22&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logAttr</span>(<span class="params">params?:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, attrName:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logAttr&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logMethod</span>(<span class="params">params?:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, desc:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logMethod&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logParam11</span>(<span class="params">params?:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, paramIndex:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logParam11&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logParam22</span>(<span class="params">params?:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, paramIndex:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logParam22&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClz11</span>(<span class="string">&#x27;http://baidu.com&#x27;</span>)</span><br><span class="line"><span class="meta">@logClz22</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpClient</span> &#123;</span><br><span class="line">    <span class="meta">@logAttr</span>()</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">url</span>:<span class="built_in">string</span>|<span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@logMethod</span>()</span><br><span class="line">    <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get data&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setData</span>(<span class="params"><span class="meta">@logParam11</span>() param1:<span class="built_in">any</span>, <span class="meta">@logParam22</span>() param2:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set data&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logAttr --&gt; logMethod --&gt; logParam22 --&gt; logParam11 --&gt; logClz22 --&gt; logClz11</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.jianshu.com/p/f4c961cbb074">装饰器参考链接</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 教程</title>
    <url>/2017/11/29/Vim%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="http://www.jianshu.com/p/bcbe916f97e1">Vim 简书</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 的各种 v-方法</title>
    <url>/2018/06/26/Vue%20v-function/</url>
    <content><![CDATA[<h1 id="Vue-v-event"><a href="#Vue-v-event" class="headerlink" title="Vue v-event"></a>Vue v-event</h1><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>   绑定属性，一旦生效，属性固定不再变</p>
<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>  绑定值为 HTML 代码</p>
<span id="more"></span>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>  绑定HTML 属性的值，例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span>html属性不能使用双大括号形式绑定，只能使用v-bind指令<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;title content&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<!--more-->

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>  用于监听子组件触发的事件 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;counter-event-example&quot;</span></span></span><br><span class="line"><span class="tag">   &lt;<span class="attr">p</span>&gt;</span>&#123;&#123; total &#125;&#125;&lt;/p</span><br><span class="line"> &gt; <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">&quot;incrementTotal&quot;</span>&gt;</span>&lt;/button-counter</span><br><span class="line">   <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">&quot;incrementTotal&quot;</span>&gt;</span>&lt;/button-counter</span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;button-counter&#x27;</span>, </span><br><span class="line">   <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&#x27;</span></span><br><span class="line">   <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) </span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">methods</span>: </span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span> (<span class="params"></span>) </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">counter</span> += <span class="number">1</span> </span><br><span class="line">     <span class="variable language_">this</span>.$emit(<span class="string">&#x27;increment&#x27;</span>) &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Vue</span>(</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#counter-event-example&#x27;</span></span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">total</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="attr">methods</span>: </span><br><span class="line">    <span class="attr">incrementTotal</span>: <span class="keyword">function</span> (<span class="params"></span>) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">total</span> += <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>this.$emit(&#39;increment&#39;)</code><br>通过这句函数可以让父组件知道子组件调用了什么函数，this.$emit(‘increment’) 即类似于子组件跟父组件说了一声“hi，爸爸 我调用了我自己的increment函数”，通知父组件</p>
<p><code>v-on:increment=&quot;incrementTotal&quot;</code><br>就是说“孩子，当你调用了increment函数的时候，我将调用incrementTotal函数来回应你”</p>
<blockquote>
<p>在子组件我们已经使用emit来进行通知，所以，这样就形成父子组件间的相互呼应传递信息，其实在开发的过程中父子组件通讯也都是使用这样的方法，父组件传递信息给子组件的时候会通过props参数，通常不会直接在子组件中修改父组件传递下来的信息，而且通过这样的一个钩子去通知父组件对某些参数进行改变</p>
</blockquote>
<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>  绑定的参数如果是真值 truthy， 就渲染，否则就不渲染.</p>
<h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h2><p>  和 v-if 一起使用</p>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>  效果和 v-if&#x3D;‘false’一样，不过代码层面， v-if&#x3D;‘false’ 是直接不渲染，而 v-show&#x3D;‘false’ 是&#96;&#96;diplay: noneb</p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">items</span>:[</span><br><span class="line">        &#123;<span class="attr">text</span>:<span class="string">&quot;第一组&quot;</span>&#125;，</span><br><span class="line">        &#123;<span class="attr">text</span>:<span class="string">&quot;第二组&quot;</span>&#125;，</span><br><span class="line">        &#123;<span class="attr">text</span>:<span class="string">&quot;第三组&quot;</span>&#125;，</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样渲染出来的就是</p>
<ul>
<li>第一组</li>
<li>第二组</li>
<li>第三组</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;todo-list-example&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;addNewTodo&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;new-todo&quot;</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">v-model</span>=<span class="string">&quot;newTodoText&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">&quot;new-todo&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">placeholder</span>=<span class="string">&quot;E.g. Feed the cat&quot;</span></span></span><br><span class="line"><span class="tag">     &gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">     <span class="attr">is</span>=<span class="string">&quot;todo-item&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-for</span>=<span class="string">&quot;(todo, index) in todos&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-bind:title</span>=<span class="string">&quot;todo.title&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-on:remove</span>=<span class="string">&quot;todos.splice(index, 1)&quot;</span></span></span><br><span class="line"><span class="tag">     &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">template</span>: <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">   &lt;li&gt;\</span></span><br><span class="line"><span class="string">   &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">   &lt;button v-on:click=&quot;$emit(\&#x27;remove\&#x27;)&quot;&gt;Remove&lt;/button&gt;\</span></span><br><span class="line"><span class="string">   &lt;/li&gt;\</span></span><br><span class="line"><span class="string">   &#x27;</span>,</span><br><span class="line">   <span class="attr">props</span>: [<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">   <span class="attr">el</span>: <span class="string">&#x27;#todo-list-example&#x27;</span>,</span><br><span class="line">   <span class="attr">data</span>: &#123;</span><br><span class="line">   <span class="attr">newTodoText</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">   <span class="attr">todos</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&#x27;Do the dishes&#x27;</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&#x27;Take out the trash&#x27;</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&#x27;Mow the lawn&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">nextTodoId</span>: <span class="number">4</span></span><br><span class="line"> &#125;,</span><br><span class="line">   <span class="attr">methods</span>: &#123;</span><br><span class="line">   <span class="attr">addNewTodo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">todos</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="variable language_">this</span>.<span class="property">nextTodoId</span>++,</span><br><span class="line">   <span class="attr">title</span>: <span class="variable language_">this</span>.<span class="property">newTodoText</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">newTodoText</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="http://p04c6djlz.bkt.clouddn.com//18-6-27/86590836.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 传参与watch</title>
    <url>/2019/09/17/Vue%20%E4%BC%A0%E5%8F%82%E4%B8%8Ewatch/</url>
    <content><![CDATA[<h1 id="模块间传参"><a href="#模块间传参" class="headerlink" title="模块间传参"></a>模块间传参</h1><p>传参用的字段名不能用驼峰或者下划线,要全小写<br>到 B页面用 props 声明,字段名要加引号,之后使用方式和 data 声明的变量一样,在 js 内用 this.引用,在 HTML 内直接引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// A 模块中引用 B 模块</span><br><span class="line"><span class="tag">&lt;<span class="name">videoRegionStatCharts</span> <span class="attr">:topicid</span>=<span class="string">&quot;topicId&quot;</span> <span class="attr">:timestamp</span>=<span class="string">&quot;listQuery.timestamp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; timePicker &#125;,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;topicid&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>],</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">listQuery</span>: &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="watch-方法"><a href="#watch-方法" class="headerlink" title="watch 方法"></a>watch 方法</h1><p>watch 监听的字段不能是 data 声明的字段<br>用 computed或者 props 声明的字段可以被 watch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;topicid&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>,<span class="string">&#x27;regionparam&#x27;</span>],</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">listQuery</span>: &#123;</span><br><span class="line">      <span class="attr">region</span>: <span class="variable language_">this</span>.<span class="property">regionparam</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>: &#123; <span class="comment">// 这里要监听 this.listQuery.region,不能直接监听 data 声明的变量,要用 computed 声明并返回 this.listQuery.region 实现绑定</span></span><br><span class="line">  <span class="attr">region</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">listQuery</span>.<span class="property">region</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">topicid</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listQuery</span>.<span class="property">topicId</span> = val</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">drawLine</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">region</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123; <span class="comment">// 这里监听的其实是 this.listQuery.region</span></span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;changeRegion&#x27;</span>, val) <span class="comment">// 向父组件传参</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">timestamp</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listQuery</span>.<span class="property">timestamp</span> = val</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">drawLine</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子组件向父组件传参"><a href="#子组件向父组件传参" class="headerlink" title="子组件向父组件传参"></a>子组件向父组件传参</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">videoRegionStatCharts</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:topicid</span>=<span class="string">&quot;topicId&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:regionparam</span>=<span class="string">&quot;listQuery.region&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:timestamp</span>=<span class="string">&quot;listQuery.timestamp&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">changeRegion</span>=<span class="string">&quot;handleChangeRegion&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--子组件传参--&gt;</span><br><span class="line"><span class="attr">region</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&#x27;changeRegion&#x27;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--父组件响应--&gt;</span><br><span class="line"><span class="title function_">handleChangeRegion</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">listQuery</span>.<span class="property">region</span> = val</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">handleFilter</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过<code>:regionparam</code>向子组件传参,子组件再通过<code>listQuery.region: this.regionparam</code>绑定参数,然后通过 computed 声明一个新变量来监听子组件参数的变化,如果子组件的这个参数变了会通过<code>this.$emit(&#39;changeRegion&#39;, val)</code>向父组件发送通知,父组件用<code>handleChangeRegion</code>响应子组件的传参<br>最终实现双向绑定</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 表单输入绑定</title>
    <url>/2018/06/28/Vue%20%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><p>在很多的 v-function 里有一个很特别，就是 v-model， 他就专门用于表单<code>&lt; input&gt;</code>和<code>&lt; textarea</code>元素上创建双向绑定的.</p>
<p>每个表单绑定了 v-model 以后，vue 就会根据表单的特性去执行一些提交或者传值:</p>
<ul>
<li>input textarea v-model&#x3D;‘message’ 这样<code>&#123;&#123;message&#125;&#125;</code>就会等于 input 输入框的值</li>
<li>CheckBox -&gt;v-model&#x3D; ‘checked’ 这样<code>&#123;&#123;checked&#125;&#125;</code>就是这个单选框是否被选</li>
<li>CheckBox -&gt;v-model&#x3D; ‘checkName’ 这样每选一个 Check就会把 value push到<code>&#123;&#123;checkName&#125;&#125;</code>中</li>
<li>radio -&gt; v-model&#x3D;‘picked’ 和 CheckBox 很像，不过不是 push 是赋值&#x3D;</li>
<li>select -&gt; v-model&#x3D;‘selected’， <code>&#123;&#123;selected&#125;&#125;</code> 等于<code>&lt;option&gt;</code>的值</li>
</ul>
<h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串 (对于复选框也可以是布尔值), 也就是设置一个默认值</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag"> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">v-model</span>=<span class="string">&quot;toggle&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">true-value</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">false-value</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.<span class="property">toggle</span> === <span class="string">&#x27;yes&#x27;</span></span><br><span class="line"><span class="comment">// 当没有选中时</span></span><br><span class="line">vm.<span class="property">toggle</span> === <span class="string">&#x27;no&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>true-value</code> 和 <code>false-value</code> 特性并不会影响输入控件的 <code>value</code> 特性，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮</p>
</blockquote>
<h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pick&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.<span class="property">pick</span> === vm.<span class="property">a</span></span><br></pre></td></tr></table></figure>

<h3 id="选择框的选项"><a href="#选择框的选项" class="headerlink" title="选择框的选项"></a>选择框的选项</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;&#123; number: 123 &#125;&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line"><span class="keyword">typeof</span> vm.<span class="property">selected</span> <span class="comment">// =&gt; &#x27;object&#x27;</span></span><br><span class="line">vm.<span class="property">selected</span>.<span class="property">number</span> <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h3><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了<a href="https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip">上述</a>输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转变为使用 <code>change</code> 事件进行同步：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><p>这样输入框输入的值会自动转化成数字类型</p>
<h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完以后会发现，其实 v-model 就是一个语法糖而已，实质是 v-bind，把表单输入的绑定值做了一层封装</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-store 笔记</title>
    <url>/2019/06/14/Vue-store%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vue-store"><a href="#Vue-store" class="headerlink" title="Vue-store"></a>Vue-store</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有些时候需要在当前页面去修改其他页面的数据,如果使用 localStorage那需要页面重新加载,因为localStorage是数据不是在 Vue 项目本身的,而是存放在浏览器中的,这需要页面重新加载,样式才会重新加载数据并渲染.这在用户体验上是很不友好的事,这个时候就需要使用 store.</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>store 你可以理解为一个全局变量池,其中可以存放变量或者方法.<br>首先需要在 store里注册这个变量和改变它的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.modules</span></span><br><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">isTopMenu</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">distributorNo</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">SWITCH_MENU</span>: <span class="function">(<span class="params">state, isTopMenu</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">isTopMenu</span> = isTopMenu</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">CHANGE_DISTRIBUTORNO</span>: <span class="function">(<span class="params">state, distributorNo</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">distributorNo</span> = distributorNo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title class_">SwitchMenu</span>(&#123; commit &#125;, isTopMenu) &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;SWITCH_MENU&#x27;</span>, isTopMenu)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title class_">ChangeDistributorNo</span>(&#123; commit &#125;, distributorNo) &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;CHANGE_DISTRIBUTORNO&#x27;</span>, distributorNo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在store-&gt;index.js 里初始化对象</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&#x27;./modules/app&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    app</span><br><span class="line">  &#125;,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>这样我们就有了 state.distributorNo, ChangeDistributorNo(), CHANGE_DISTRIBUTORNO</p>
<h2 id="store-dispatch-调用"><a href="#store-dispatch-调用" class="headerlink" title="store.dispatch 调用"></a>store.dispatch 调用</h2><span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;ChangeDistributorNo&#x27;</span>, <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">distributorNo</span>)</span><br></pre></td></tr></table></figure>
<p>在需要改变state.distributorNo时这样调用,第一个参数是方法名,第二个参数是方法对应的参数.这样就改变了 store 里的 distributorNo</p>
<h3 id="store-dispatch和store-commit的区别"><a href="#store-dispatch和store-commit的区别" class="headerlink" title="store.dispatch和store.commit的区别"></a>store.dispatch和store.commit的区别</h3><p>dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch(‘mutations方法名’,值)</p>
<p>commit：同步操作，写法：this.$store.commit(‘mutations方法名’,值)</p>
<h2 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h2><p>mapGetters是 Vue里自带,它用于引入 store.getters 里注册的(全局)变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="attr">isTopMenu</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">app</span>.<span class="property">isTopMenu</span>,</span><br><span class="line">  <span class="attr">distributorNo</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">app</span>.<span class="property">distributorNo</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br></pre></td></tr></table></figure>

<p>这样在其他页面引入 mapGetters,就会获取这个对象<br>如果使用这样的代码引入,就会获得对应的变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapGetters</span>([</span><br><span class="line">  <span class="string">&#x27;isTopMenu&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;distributorNo&#x27;</span></span><br><span class="line">])</span><br><span class="line"><span class="comment">// [state.app.isTopMenu, state.app.distributorNo]</span></span><br></pre></td></tr></table></figure>

<h2 id="watch-事件"><a href="#watch-事件" class="headerlink" title="watch 事件"></a>watch 事件</h2><p>在需要改变的样式页面里监听数据<br>监听数据需要先向computed注册,而不是向 data注册</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapGetters</span>([</span><br><span class="line">      <span class="string">&#x27;isTopMenu&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;distributorNo&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">distributorNo</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;distributorNo&#x27;</span>, val)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">distributorList</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">distributorNo</span> === val) &#123;</span><br><span class="line">          <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;distributorName&#x27;</span>, item.<span class="property">name</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">chooseDistributor</span> = item.<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">distributorNo</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>这样当 distributorNo 变量改变时,就会触发事件,执行方法,这里的 val 就是改变后的新数值,<br>这样该页面的数据就变了,Vue 就会重新渲染该页面,不会重新加载整个页面,用户体验好的多</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 如何通过索引修改数组的值</title>
    <url>/2018/07/04/Vue%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E5%80%BC/</url>
    <content><![CDATA[<h1 id="Vue通过索引修改数组值"><a href="#Vue通过索引修改数组值" class="headerlink" title="Vue通过索引修改数组值"></a>Vue通过索引修改数组值</h1><h2 id="最近在写通过-data-slide-数组动态生成列表的时候遇到了一个问题"><a href="#最近在写通过-data-slide-数组动态生成列表的时候遇到了一个问题" class="headerlink" title="最近在写通过 data.slide 数组动态生成列表的时候遇到了一个问题:"></a>最近在写通过 data.slide 数组动态生成列表的时候遇到了一个问题:</h2>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-level-one&quot;</span>  <span class="attr">v-for</span>=<span class="string">&quot;(item, index) of slide&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;slideClick(index)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>  <span class="attr">v-show</span>=<span class="string">&quot;arr[index]&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>  <span class="attr">class</span>=<span class="string">&quot;title-level-two&quot;</span>  <span class="attr">v-for</span>=<span class="string">&quot;(subtitle, index2) of item.data&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index2&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;subtitle&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  这样写没有问题，的确会根据 slide 和 slide.data 的数组去生成对应数量的列表.但是此时我想对列表做一个隐藏和显示 CSS 时， 遇到了问题:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">slideClick (index) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">arr</span>[index] = !<span class="variable language_">this</span>.<span class="property">arr</span>[index])</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`arr`</span>, <span class="variable language_">this</span>.<span class="property">arr</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">arr</span>  =  <span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">slide</span>.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>此时我打印 arr，发现 this.arr 的确是变了，但是 Vue 并没有响应，也就是 v-show 并没有变化.一开始我以为是 this.arr 在 fill 的时候被附了一个新对象，但是仔细一想就发现不是，在初始化的时候列表已经被隐藏了，所以肯定是因为某个原因 Vue 没有响应到<code>this.arr[index] = !this.arr[index])</code>.</p>
<h2 id="再仔细查了一遍官方教程以后发现了这么一段话"><a href="#再仔细查了一遍官方教程以后发现了这么一段话" class="headerlink" title="再仔细查了一遍官方教程以后发现了这么一段话:"></a>再仔细查了一遍官方教程以后发现了这么一段话:</h2><blockquote>
<p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p>
<ol>
<li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
</blockquote>
<h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"> <span class="attr">data</span>: &#123;</span><br><span class="line"> <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.<span class="property">items</span>[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.<span class="property">items</span>.<span class="property">length</span> = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<h3 id="为了解决第一类问题，以下两种方式都可以实现和-vm-items-indexOfItem-newValue-相同的效果，同时也将触发状态更新："><a href="#为了解决第一类问题，以下两种方式都可以实现和-vm-items-indexOfItem-newValue-相同的效果，同时也将触发状态更新：" class="headerlink" title="为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新："></a>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将触发状态更新：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.<span class="property">items</span>.<span class="title function_">splice</span>(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>

<h3 id="你也可以使用-vm-set-实例方法，该方法是全局方法-Vue-set-的一个别名："><a href="#你也可以使用-vm-set-实例方法，该方法是全局方法-Vue-set-的一个别名：" class="headerlink" title="你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名："></a>你也可以使用 <a href="https://vuejs.org/v2/api/#vm-set"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</h3><p><code>vm.$set(vm.items, indexOfItem, newValue)</code><br>为了解决第二类问题，你可以使用 <code>splice</code>：<br><code>vm.items.splice(newLength)</code></p>
<h2 id="原因是"><a href="#原因是" class="headerlink" title="原因是:"></a>原因是:</h2><blockquote>
<p>因为vue的底层是通过Object.defineProperty来实现数据监听更新视图的，通过索引设置数组的值不能被这个方法监听到，所以无法触发更新</p>
</blockquote>
<h2 id="所以我这里虽然修改了-this-arr-的值，但并没被-Vue-响应到"><a href="#所以我这里虽然修改了-this-arr-的值，但并没被-Vue-响应到" class="headerlink" title="所以我这里虽然修改了 this.arr 的值，但并没被 Vue 响应到."></a>所以我这里虽然修改了 this.arr 的值，但并没被 Vue 响应到.</h2><p>我用数组的 splice 方法改写成如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>, !<span class="variable language_">this</span>.<span class="property">arr</span>[index])</span><br></pre></td></tr></table></figure>
<p>这样就可以了</p>
<h1 id="查官方教程的时候还看到了-对象更改检测注意事项"><a href="#查官方教程的时候还看到了-对象更改检测注意事项" class="headerlink" title="查官方教程的时候还看到了: 对象更改检测注意事项"></a>查官方教程的时候还看到了: <a href="https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" title="对象更改检测注意事项">对象更改检测注意事项</a></h1><p>还是由于 JavaScript 的限制，<strong>Vue 不能检测对象属性的添加或删除</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"> <span class="attr">data</span>: &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure>

<p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。例如，对于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">   <span class="attr">data</span>: &#123;</span><br><span class="line">     <span class="attr">userProfile</span>: &#123;</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&#x27;Anika&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以添加一个新的 <code>age</code> 属性到嵌套的 <code>userProfile</code> 对象：<br>Vue.set(vm.userProfile, ‘age’, 27)<br>你还可以使用 <code>vm.$set</code> 实例方法，它只是全局 <code>Vue.set</code> 的别名：<br>vm.$set(vm.userProfile, ‘age’, 27)<br>有时你可能需要为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(vm.<span class="property">userProfile</span>, &#123;</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="attr">favoriteColor</span>: <span class="string">&#x27;Vue Green&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="你应该这样做："><a href="#你应该这样做：" class="headerlink" title="你应该这样做："></a>你应该这样做：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.<span class="property">userProfile</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, vm.<span class="property">userProfile</span>, &#123;</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="attr">favoriteColor</span>: <span class="string">&#x27;Vue Green&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>YAML</title>
    <url>/2017/11/29/YAML/</url>
    <content><![CDATA[<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><ul>
<li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li>
<li>纯量（scalars）：单个的、不可再分的值</li>
</ul>
<span id="more"></span>

<h2 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h2><p>就是 由冒号连接的键值对</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animal :</span> <span class="string">pets</span>	</span><br></pre></td></tr></table></figure>

<p>转为JavaScript就是</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; animal : pets &#125;</span><br></pre></td></tr></table></figure>

<p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hash:</span> &#123; <span class="attr">name:</span> <span class="string">Steve</span>, <span class="attr">foo:</span> <span class="string">bar</span> &#125; </span><br></pre></td></tr></table></figure>

<p>转为 JavaScript 如下。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">hash</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;Steve&#x27;</span>, <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h2><p>一组连词线开头的行，构成一个数组。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>



<p>转为 JavaScript 如下。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&#x27;Cat&#x27;</span>, <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;Goldfish&#x27;</span> ]</span><br></pre></td></tr></table></figure>

<p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>

<p>转为 JavaScript 如下。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[ [ <span class="string">&#x27;Cat&#x27;</span>, <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;Goldfish&#x27;</span> ] ]</span><br></pre></td></tr></table></figure>

<p>数组也可以采用行内表示法。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animal:</span> [<span class="string">Cat</span>, <span class="string">Dog</span>]</span><br></pre></td></tr></table></figure>

<p>转为 JavaScript 如下。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">animal</span>: [ <span class="string">&#x27;Cat&#x27;</span>, <span class="string">&#x27;Dog&#x27;</span> ] &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、混合结构"><a href="#三、混合结构" class="headerlink" title="三、混合结构"></a>三、混合结构</h2><p>对象和数组可以结合使用，形成复合结构。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Ruby</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Perl</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"> <span class="attr">YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line"> <span class="attr">Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line"> <span class="attr">Python:</span> <span class="string">python.org</span> </span><br><span class="line"> <span class="attr">Perl:</span> <span class="string">use.perl.org</span> </span><br></pre></td></tr></table></figure>

<p>转为 JavaScript 如下。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &#123; <span class="attr">languages</span>: [ <span class="string">&#x27;Ruby&#x27;</span>, <span class="string">&#x27;Perl&#x27;</span>, <span class="string">&#x27;Python&#x27;</span> ],</span><br><span class="line">   <span class="attr">websites</span>: </span><br><span class="line">    &#123; <span class="attr">YAML</span>: <span class="string">&#x27;yaml.org&#x27;</span>,</span><br><span class="line">      <span class="title class_">Ruby</span>: <span class="string">&#x27;ruby-lang.org&#x27;</span>,</span><br><span class="line">      <span class="title class_">Python</span>: <span class="string">&#x27;python.org&#x27;</span>,</span><br><span class="line">      <span class="title class_">Perl</span>: <span class="string">&#x27;use.perl.org&#x27;</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、纯量"><a href="#四、纯量" class="headerlink" title="四、纯量"></a>四、纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p>基本都是用对象的形式来表示</p>
<p> number : 12.3</p>
<p> isSet : true</p>
<p> friend : ~ &#x2F;&#x2F;~代表null</p>
<p> date : 1976-07-31</p>
<p> t: !!str true &#x2F;&#x2F;强制转换数据类型</p>
<h2 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h2><p>  <strong>最复杂</strong></p>
<p>字符串默认不适用引号，但是如果字符串中有特殊字符就需要加引号，无论单双</p>
<p>单引号之中如果还有单引号，必须连续使用两个单引号转义。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">&#x27;labor&#x27;</span><span class="string">&#x27;s day&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>转为 JavaScript 如下。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">str</span>: <span class="string">&#x27;labor\&#x27;s day&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>多行字符串可以使用<code>|</code>保留换行符，也可以使用&#96;&#96;折叠换行。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br><span class="line"><span class="string"></span><span class="attr">that:</span> </span><br><span class="line">  <span class="string">Foo</span></span><br><span class="line">  <span class="string">Bar</span></span><br></pre></td></tr></table></figure>

<p>转为 JavaScript 代码如下。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">this</span>: <span class="string">&#x27;Foo\nBar\n&#x27;</span>, <span class="attr">that</span>: <span class="string">&#x27;Foo Bar\n&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>language</category>
      </categories>
  </entry>
  <entry>
    <title>.bashrc_profile 和.bashrc的区别</title>
    <url>/2017/11/29/bashrc_profile%E5%92%8Cbashrc/</url>
    <content><![CDATA[<ul>
<li>&#x2F;etc&#x2F;profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置.</li>
<li>&#x2F;etc&#x2F;bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</li>
<li>~&#x2F;.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</li>
<li>~&#x2F;.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.</li>
<li>~&#x2F;.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. <span id="more"></span>
另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而~&#x2F;.bashrc等中设定的变量(局部)只能继承&#x2F;etc&#x2F;profile中的变量,他们是”父子”关系.</li>
</ul>
<p>~&#x2F;.bash_profile 是交互式、login 方式进入 bash 运行的<br>~&#x2F;.bashrc 是交互式 non-login 方式进入 bash 运行的<br>通常二者设置大致相同，所以通常前者会调用后者。</p>
<p>设置生效：可以重启生效，也可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source alias php=/var/eyouim/pub/php/bin/php</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="2-3-用户环境配置"><a href="#2-3-用户环境配置" class="headerlink" title="2.3. 用户环境配置"></a>2.3. 用户环境配置</h2><p>为使Bash更好地为我们服务，我们需定制bash shell环境。</p>
<h3 id="2-3-1-bash-profile、-bashrc、和-bash-logout"><a href="#2-3-1-bash-profile、-bashrc、和-bash-logout" class="headerlink" title="2.3.1. .bash_profile、.bashrc、和.bash_logout"></a>2.3.1. .bash_profile、.bashrc、和.bash_logout</h3><p>上 面这三个文件是bash shell的用户环境配置文件，位于用户的主目录下。其中.bash_profile是最重要的一个配置文件，它在用户每次登录系统时被读取，里面的所有 命令都会被bash执行。.profile(由Bourne Shell和Korn Shell使用)和.login(由C Shell使用)两个文件是.bash_profile的同义词，目的是为了兼容其它Shell。在Debian中使用.profile文件代 替.bash_profile文件。</p>
<p>.bashrc文件会在bash shell调用另一个bash shell时读取，也就是在shell中再键入bash命令启动一个新shell时就会去读该文件。这样可有效分离登录和子shell所需的环境。但一般 来说都会在.bash_profile里调用.bashrc脚本以便统一配置用户环境。</p>
<p>.bash_logout在退出shell时被读取。所以我们可把一些清理工作的命令放到这文件中。</p>
<p>在 &#x2F;etc目录的bash.bashrc和profile是系统级（全局）的配置文件，当在用户主目录下找不到.bash_profile 和.bashrc\时，就会读取这两个文件。.bash_history是bash shell的历史记录文件，里面记录了你在bash shell中输入的所有命令。可通过HISSIZE环境变量设置在历史记录文件里保存记录的条数。alias l &#x3D; ‘ls -l’是设置别名的语句，把它放在这些配置文档中就可使我们能用简单的’l’命令，代替’ls -l’命令。</p>
<p><strong>当我们修改了这些配置件后，可用source .bash_profile命令使它修改内容马上生效。</strong></p>
<h3 id="2-3-2-选项"><a href="#2-3-2-选项" class="headerlink" title="2.3.2. 选项"></a>2.3.2. 选项</h3><p>bash shell中的选项可控制shell的行为和功能，我们可以通过shopt命令来设置。使用set命令也可以，但它已被shopt替代，但为了向下兼 容，set命令还是可以使用的。使用不带参数的shopt命令可以列出当前shell中只能由shopt设置的选项，用shopt -o可列出可由set命令设置的选项。</p>
<ul>
<li>下面是一些可由set命令基本的选项，默认是关闭的。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">emacs</td>
<td align="left">进入emacs编辑模式</td>
</tr>
<tr>
<td align="left">vi</td>
<td align="left">进入vi编辑模式</td>
</tr>
<tr>
<td align="left">ignoreeof</td>
<td align="left">不允许单独使用Ctrl_D退出的用法，要使用exit。与IGNOREEOF&#x3D;10等价</td>
</tr>
<tr>
<td align="left">noclobber</td>
<td align="left">不允许重定向覆盖已存在文件</td>
</tr>
<tr>
<td align="left">noglob</td>
<td align="left">不允许扩展文件名通配符</td>
</tr>
<tr>
<td align="left">nounset</td>
<td align="left">使用未定义的变量时给出错误</td>
</tr>
</tbody></table>
<ul>
<li>下面是一些只能由shopt命令设置的选项。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cdspell</td>
<td align="left">自动改正cd命令参数中的小错误</td>
</tr>
<tr>
<td align="left">hostcomplete</td>
<td align="left">以@开头时，按tab键可进行主机名的自动完成</td>
</tr>
<tr>
<td align="left">dotgblob</td>
<td align="left">以点开始的文件名被包含在路径名扩展中</td>
</tr>
<tr>
<td align="left">mailwarn</td>
<td align="left">显示邮件警告信息</td>
</tr>
</tbody></table>
<ul>
<li>shopt命令的选项如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-p</td>
<td align="left">显示可设置选项及当前取值</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">设置每一选项为on</td>
</tr>
<tr>
<td align="left">-u</td>
<td align="left">设置每一选项为off</td>
</tr>
<tr>
<td align="left">-q</td>
<td align="left">不输出信息</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>brew更换镜像源</title>
    <url>/2020/08/18/brew%E6%9B%B4%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h1><h2 id="替换brew-git"><a href="#替换brew-git" class="headerlink" title="替换brew.git"></a>替换brew.git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br></pre></td></tr></table></figure>



<h2 id="替换homebrew-core-git"><a href="#替换homebrew-core-git" class="headerlink" title="替换homebrew-core.git"></a>替换homebrew-core.git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>



<h2 id="刷新源"><a href="#刷新源" class="headerlink" title="刷新源"></a>刷新源</h2><p><code>brew update</code></p>
<p>#清华源</p>
<h2 id="替换brew-git-1"><a href="#替换brew-git-1" class="headerlink" title="替换brew.git"></a>替换brew.git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br></pre></td></tr></table></figure>



<h2 id="替换homebrew-core-git-1"><a href="#替换homebrew-core-git-1" class="headerlink" title="替换homebrew-core.git"></a>替换homebrew-core.git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>



<h2 id="刷新源-1"><a href="#刷新源-1" class="headerlink" title="刷新源"></a>刷新源</h2><p><code>brew update</code></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>egg.js 笔记</title>
    <url>/2019/03/13/egg-js%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="egg-js-笔记"><a href="#egg-js-笔记" class="headerlink" title="egg.js 笔记"></a>egg.js 笔记</h1><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>关于 app, ctx, helper, config, logger 的详细介绍:<br><a href="https://eggjs.org/zh-cn/basics/objects.html">官网链接</a></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h2 id="记一下经常容易弄错的-logger-对象"><a href="#记一下经常容易弄错的-logger-对象" class="headerlink" title="记一下经常容易弄错的 logger 对象"></a>记一下经常容易弄错的 logger 对象</h2><ul>
<li><p>App Logger<br>我们可以通过 app.logger 来获取到它，如果我们想做一些应用级别的日志记录，如记录启动阶段的一些数据信息，记录一些业务上与请求无关的信息，都可以通过 App Logger 来完成。</p>
</li>
<li><p>Context Logger<br>我们可以通过 ctx.logger 从 Context 实例上获取到它，从访问方式上我们可以看出来，Context Logger 一定是与请求相关的，它打印的日志都会在前面带上一些当前请求相关的信息（如 [$userId&#x2F;$ip&#x2F;$traceId&#x2F;${cost}ms $method $url]），通过这些信息，我们可以从日志快速定位请求，并串联一次请求中的所有的日志。</p>
</li>
<li><p>Controller Logger &amp; Service Logger<br>我们可以在 Controller 和 Service 实例上通过 this.logger 获取到它们，它们本质上就是一个 Context Logger，不过在打印日志的时候还会额外的加上文件路径，方便定位日志的打印位置。</p>
</li>
</ul>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200408181955.png"></p>
<blockquote>
<p>由此可见,如果想看到http请求的参数和路径,还有打印logger的文件就使用this.logger(ctx.logger多一个文件路径),如果只是打印和请求无关的日志,使用app.logger</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>在 controller和service 里比较推荐使用 ctx.logger,这样可以获取当前请求的相关信息,比较容易定位 bug.<br>在其他和业务无关的地方用 app.logger 就好了</p>
<span id="more"></span>

<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>application 是一个全局应用对象,而且在一个应用中只会被实例化一次.也就相当于是一个全局对象,如果把某对象挂在 app 下,可能会造成全局污染.</p>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="配置加载顺序"><a href="#配置加载顺序" class="headerlink" title="配置加载顺序"></a>配置加载顺序</h3><p>应用、插件、框架都可以定义这些配置，而且目录结构都是一致的，但存在优先级（应用 &gt; 框架 &gt; 插件），相对于此运行环境的优先级会更高。</p>
<p>比如在 prod 环境加载一个配置的加载顺序如下，后加载的会覆盖前面的同名配置。</p>
<blockquote>
<p>-&gt; 插件 config.default.js<br>-&gt; 框架 config.default.js<br>-&gt; 应用 config.default.js<br>-&gt; 插件 config.prod.js<br>-&gt; 框架 config.prod.js<br>-&gt; 应用 config.prod.js</p>
</blockquote>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式:"></a>获取方式:</h3><p>我们可以通过 app.config 从 Application 实例上获取到 config 对象，也可以在 Controller, Service, Helper 的实例上通过 this.config 获取到 config 对象。</p>
<h2 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h2><p>egg 还提供了订阅模式的基类,如果需要使用订阅模式,那调用这个类,然后继承并实现就好了</p>
<p>可以通过以下方式来引用 Subscription 基类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Subscription</span> = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).<span class="property">Subscription</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Schedule</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Subscription</span> &#123;</span><br><span class="line">  <span class="comment">// 需要实现此方法</span></span><br><span class="line">  <span class="comment">// subscribe 可以为 async function 或 generator function</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">subscribe</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Vue ElementUI el-backtop 控件</title>
    <url>/2020/01/15/el-backToTop/</url>
    <content><![CDATA[<p>一、前言<br>elementUI有说明文档，但我为什么还要重新写一下呢？因为文档也有坑，一开始使用时你复制进去，可能都没有效果。也不知道原因在哪，就如Backtop回到顶部的组件，不去看源码，真心不知道是怎么个所以然。一开始，我把这个组件放到我页面的底部，结果是无效果的，而且还会报css的这两个样式错误（.page-component__scroll .el-scrollbar__wrap），看完这个文档，也没找到这两个是什么东西，在哪设置。全文搜索，也没找到这两个css。最后逼我进去看Backtop组件源码，看懂后，删除了没必要的东西，放置的位置调整一下，完美解决。这也是本站使用的回到顶部的效果。以下我会贴出官方文档及源码，还有解决思路</p>
<p>二、官方文档 <a href="https://element.eleme.cn/#/zh-CN/component/backtop">https://element.eleme.cn/#/zh-CN/component/backtop</a></p>
<p>Backtop 回到顶部<br>返回页面顶部的操作按钮</p>
<p>基础用法<br>滑动页面即可看到右下方的按钮。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  Scroll down to see the bottom-right button.</span><br><span class="line">  <span class="tag">&lt;<span class="name">el-backtop</span> <span class="attr">target</span>=<span class="string">&quot;.page-component__scroll .el-scrollbar__wrap&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-backtop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">自定义显示内容</span><br><span class="line">显示区域被固定为 40px * 40px 的区域, 其中的内容可支持自定义。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  Scroll down to see the bottom-right button.</span><br><span class="line">  <span class="tag">&lt;<span class="name">el-backtop</span> <span class="attr">target</span>=<span class="string">&quot;.page-component__scroll .el-scrollbar__wrap&quot;</span> <span class="attr">:bottom</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">        height: 100%;</span></span></span><br><span class="line"><span class="string"><span class="tag">        width: 100%;</span></span></span><br><span class="line"><span class="string"><span class="tag">        background-color: #f2f5f6;</span></span></span><br><span class="line"><span class="string"><span class="tag">        box-shadow: 0 0 6px rgba(0,0,0, .12);</span></span></span><br><span class="line"><span class="string"><span class="tag">        text-align: center;</span></span></span><br><span class="line"><span class="string"><span class="tag">        line-height: 40px;</span></span></span><br><span class="line"><span class="string"><span class="tag">        color: #1989fa;</span></span></span><br><span class="line"><span class="string"><span class="tag">      &#125;&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      UP</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-backtop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没试过的可以先跟着官方的文档试下，看是否可行，若不可行，接着往下看</p>
<span id="more"></span>

<p>三、el-backtop组件源码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;el-fade-in&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">click.stop</span>=<span class="string">&quot;handleClick&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:style</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">        &#x27;right&#x27;: styleRight,</span></span></span><br><span class="line"><span class="string"><span class="tag">        &#x27;bottom&#x27;: styleBottom</span></span></span><br><span class="line"><span class="string"><span class="tag">      &#125;&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;el-backtop&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-icon</span> <span class="attr">name</span>=<span class="string">&quot;caret-top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> throttle <span class="keyword">from</span> <span class="string">&#x27;throttle-debounce/throttle&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;ElBacktop&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">visibilityHeight</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">default</span>: <span class="number">200</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">target</span>: [<span class="title class_">String</span>],</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">right</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">default</span>: <span class="number">40</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">bottom</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">default</span>: <span class="number">40</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">container</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">visible</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">styleBottom</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.bottom&#125;</span>px`</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">styleRight</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.right&#125;</span>px`</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">init</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">throttledScrollHandler</span> = <span class="title function_">throttle</span>(<span class="number">300</span>, <span class="variable language_">this</span>.<span class="property">onScroll</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="variable language_">this</span>.<span class="property">throttledScrollHandler</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">container</span> = <span class="variable language_">document</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">target</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="variable language_">this</span>.<span class="property">target</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">el</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`target is not existed: <span class="subst">$&#123;<span class="variable language_">this</span>.target&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">container</span> = <span class="variable language_">this</span>.<span class="property">el</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">onScroll</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> scrollTop = <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">scrollTop</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">visible</span> = scrollTop &gt;= <span class="variable language_">this</span>.<span class="property">visibilityHeight</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">scrollToTop</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;click&#x27;</span>, e);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">scrollToTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> el = <span class="variable language_">this</span>.<span class="property">el</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> step = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (el.<span class="property">scrollTop</span> &lt;= <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="built_in">clearInterval</span>(interval);</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        step += <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">scrollTop</span> -= step;</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">20</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="variable language_">this</span>.<span class="property">throttledScrollHandler</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组件的几个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visibility-height:滚动高度达到此参数值才出现，默认200，是number类型（使用如:visibility-height=&quot;100&quot;）</span><br><span class="line">target：触发滚动的对象，是String类型，你可以不传</span><br><span class="line">right：控制其显示位置, 距离页面右边距，默认40，是number类型，数值越大，离右边越远。</span><br><span class="line">bottom：控制其显示位置, 距离页面底部距离。默认40，是number类型，你可以调整他的值，越大离底部越远。</span><br></pre></td></tr></table></figure>

<p>三、思路</p>
<p>当你看完backtop的组件源码后，你是否会有所领悟呢？他的组件参数都有默认值，这意思就是，我们可以什么都不传，调用这个组件即可使用。</p>
<p><code>&lt;el-backtop&gt;&lt;/el-backtop&gt;</code></p>
<p>是的，你没看错，把上面那段代码Copy到你的代码中，即可使用。记得把代码放在最外层的div里的第一个，不要放在尾部。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;height: 100%;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-backtop</span> <span class="attr">:bottom</span>=<span class="string">&quot;60&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-backtop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>到此结束，这个组件，百度也得不到结果，能解决的只有你自己，要么放弃使用这个组件，要么就搞懂它，然后研究使用，当你知道它的原理，所有问题都不再是问题。这也是建议大家多看源码的理由之一。</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>firebase 消息推送</title>
    <url>/2019/05/31/firebase%20%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<h1 id="配置-firebase"><a href="#配置-firebase" class="headerlink" title="配置 firebase"></a>配置 firebase</h1><p>在创建了 firebase 项目以后,首先要将 Firebase Admin SDK 添加到服务器,然后生成配置 json 文件</p>
<blockquote>
<p><a href="https://firebase.google.com/docs/admin/setup?hl=zh-cn">firebase添加到服务器</a></p>
</blockquote>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190610114538.jpg"></p>
<p><strong>点击生成 JSON 文件以后,需备份保存,以免丢失</strong></p>
<h1 id="初始化-firebase-SDK"><a href="#初始化-firebase-SDK" class="headerlink" title="初始化 firebase SDK"></a>初始化 firebase SDK</h1><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * firebase</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Service</span> = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).<span class="property">Service</span>;</span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;firebase-admin&#x27;</span>);</span><br><span class="line"><span class="comment">// 一定要载入对应项目的 JSON 文件,如果错误会报`SenderId Mismatch`</span></span><br><span class="line"><span class="keyword">const</span> serviceAccount = <span class="built_in">require</span>(<span class="string">&#x27;../../config/firebase/wishes-firebase.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirebaseService</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Service</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(ctx);</span><br><span class="line">        admin.<span class="title function_">initializeApp</span>(&#123;</span><br><span class="line">            <span class="attr">credential</span>: admin.<span class="property">credential</span>.<span class="title function_">cert</span>(serviceAccount),</span><br><span class="line">            <span class="attr">databaseURL</span>: <span class="string">&#x27;https://api-123123.firebaseio.com&#x27;</span> <span class="comment">// databaseURL 字段也省略</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">admin</span> = admin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">FirebaseService</span>;</span><br></pre></td></tr></table></figure>

<h1 id="消息推送"><a href="#消息推送" class="headerlink" title="消息推送"></a>消息推送</h1><h2 id="推送又分为特定设备推送-多台设备推送-向主题推送"><a href="#推送又分为特定设备推送-多台设备推送-向主题推送" class="headerlink" title="推送又分为特定设备推送,多台设备推送,向主题推送"></a>推送又分为特定设备推送,多台设备推送,向主题推送</h2><blockquote>
<p><a href="https://firebase.google.com/docs/cloud-messaging/send-message">具体的方法和数据结构</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向特定设备推送</span></span><br><span class="line"><span class="comment">// controller 层</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">sendMsg</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx, service &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; title, body, userId &#125; = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">const</span> deviceToken = <span class="keyword">await</span> service.<span class="property">device</span>.<span class="title function_">getDeviceTokenByUserId</span>(userId);</span><br><span class="line">    <span class="keyword">const</span> message = &#123;</span><br><span class="line">        <span class="attr">notification</span>: &#123;</span><br><span class="line">            title,</span><br><span class="line">            body</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">token</span>: deviceToken</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">await</span> service.<span class="property">firebase</span>.<span class="title function_">sendMsgToDevice</span>(message).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">logger</span>.<span class="title function_">error</span>(<span class="string">`fcm send msg err =&gt; <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;firebase_error&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    ctx.<span class="title function_">success</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service 层</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">sendMsgToDevice</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">admin</span>.<span class="title function_">messaging</span>().<span class="title function_">send</span>(message)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Response is a message ID string.</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">logger</span>.<span class="title function_">debug</span>(<span class="string">`Successfully sent message: <span class="subst">$&#123;response&#125;</span>`</span>);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">logger</span>.<span class="title function_">error</span>(<span class="string">`Error sending message: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息推送类型"><a href="#消息推送类型" class="headerlink" title="消息推送类型"></a>消息推送类型</h2><p>使用 FCM，您可以向客户端发送两种类型的消息：</p>
<ol>
<li>通知消息，有时被视为“显示消息”。此类消息由 FCM SDK 自动处理。</li>
<li>数据消息，由客户端应用处理。</li>
</ol>
<p>message 的格式大概是这样</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span><span class="string">&quot;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;notification&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;Portugal vs. Denmark&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span><span class="string">&quot;great match!&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Nick&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Mario&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Room&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;PortugalVSDenmark&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages">更多的格式请点击</a></p>
<h1 id="使用-firebase-后台测试推送"><a href="#使用-firebase-后台测试推送" class="headerlink" title="使用 firebase 后台测试推送"></a>使用 firebase 后台测试推送</h1><blockquote>
<p><a href="https://console.firebase.google.com/project/instavideo/notification/compose">firebase 后台</a><br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190531172841.png"></p>
</blockquote>
<p>点击发送测试消息,输入设备的 deviceToken,就可以测试定向推送,测试通过了就可以拿该 deviceToken去调试代码了,优先确保 deviceToken 没有问题,手机应用能收到推送,再调试服务器代码.</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>git命令缩写</title>
    <url>/2019/03/14/git%20%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<h2 id="使用item2-oh-my-zsh就自动支持-git-的命令缩写"><a href="#使用item2-oh-my-zsh就自动支持-git-的命令缩写" class="headerlink" title="使用item2 + oh-my-zsh就自动支持 git 的命令缩写"></a>使用item2 + oh-my-zsh就自动支持 git 的命令缩写</h2><p>以下是一些常用的缩写:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alias ga=<span class="string">&#x27;git add&#x27;</span></span><br><span class="line">alias gb=<span class="string">&#x27;git branch&#x27;</span></span><br><span class="line">alias gba=<span class="string">&#x27;git branch -a&#x27;</span></span><br><span class="line">alias gbd=<span class="string">&#x27;git branch -d&#x27;</span></span><br><span class="line"><span class="comment">// commit</span></span><br><span class="line">alias gcam=<span class="string">&#x27;git commit -a -m&#x27;</span></span><br><span class="line">alias gcmsg=<span class="string">&#x27;git commit -m&#x27;</span></span><br><span class="line"></span><br><span class="line">alias gcb=<span class="string">&#x27;git checkout -b&#x27;</span></span><br><span class="line">alias gco=<span class="string">&#x27;git checkout&#x27;</span></span><br><span class="line">alias gcp=<span class="string">&#x27;git cherry-pick&#x27;</span></span><br><span class="line"></span><br><span class="line">alias gcl=<span class="string">&#x27;git clone&#x27;</span></span><br><span class="line">alias gd=<span class="string">&#x27;git diff&#x27;</span></span><br><span class="line">alias gfo=<span class="string">&#x27;git fetch origin&#x27;</span></span><br><span class="line">alias ggpush=<span class="string">&#x27;git push origin $(git_current_branch)&#x27;</span></span><br><span class="line">alias ggsup=<span class="string">&#x27;git branch --set-upstream-to=origin/$(git_current_branch)&#x27;</span></span><br><span class="line">alias glgp=<span class="string">&#x27;git log --stat -p&#x27;</span></span><br><span class="line"></span><br><span class="line">alias gm=<span class="string">&#x27;git merge&#x27;</span></span><br><span class="line">alias gp=<span class="string">&#x27;git push&#x27;</span></span><br><span class="line">alias gst=<span class="string">&#x27;git status&#x27;</span></span><br><span class="line"><span class="comment">// 暂存</span></span><br><span class="line">alias gstl=<span class="string">&#x27;git stash list&#x27;</span></span><br><span class="line">alias gsta=<span class="string">&#x27;git stash save&#x27;</span> <span class="comment">// 可加注释 &#x27;this is xxx&#x27; </span></span><br><span class="line">alias gstp=<span class="string">&#x27;git stash pop&#x27;</span> <span class="comment">// 恢复后删除暂存 后面加 stash@&#123;index&#125;指定某个暂存</span></span><br><span class="line">alias gstc=<span class="string">&#x27;git stash clear&#x27;</span> <span class="comment">// 删除全部暂存</span></span><br><span class="line">alias gstd=<span class="string">&#x27;git stash drop&#x27;</span> <span class="comment">// stash$&#123;index&#125; 指定删除某个暂存</span></span><br></pre></td></tr></table></figure>

<h2 id="用习惯以后-写-git-还是会快很多的"><a href="#用习惯以后-写-git-还是会快很多的" class="headerlink" title="用习惯以后,写 git 还是会快很多的"></a>用习惯以后,写 git 还是会快很多的</h2>]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2017/08/21/git/</url>
    <content><![CDATA[<p><img src="http://p04c6djlz.bkt.clouddn.com//17-11-29/44076899.jpg" alt="结构"></p>
<span id="more"></span>
<p>关于撤销：</p>
<ul>
<li>git reset ：reset HEAD是将刚刚add到缓存区的文件取消。</li>
<li>git checkout :checkout</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用域</th>
<th>常用情景</th>
</tr>
</thead>
<tbody><tr>
<td>git reset</td>
<td>提交层面</td>
<td>在私有分支上舍弃一些没有提交的更改</td>
</tr>
<tr>
<td>git reset</td>
<td>文件层面</td>
<td>将文件从缓存区中移除</td>
</tr>
<tr>
<td>git checkout</td>
<td>提交层面</td>
<td>切换分支或查看旧版本</td>
</tr>
<tr>
<td>git checkout</td>
<td>文件层面</td>
<td>舍弃工作目录中的更改</td>
</tr>
<tr>
<td>git revert</td>
<td>提交层面</td>
<td>在公共分支上回滚更改</td>
</tr>
<tr>
<td>git revert</td>
<td>文件层面</td>
<td>（然而并没有）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>Git2</title>
    <url>/2017/11/29/git2/</url>
    <content><![CDATA[<p>##git<br>最基本的操作就是<br><code>gst -&gt;git add . -&gt;git commit -m&quot;&quot; -&gt;git push -&gt;gst</code><br>但是往往事情没有那么顺利，比如git add以后我要撤销怎么办</p>
<span id="more"></span>
<h2 id="具体修改了什么代码"><a href="#具体修改了什么代码" class="headerlink" title="具体修改了什么代码"></a>具体修改了什么代码</h2><p>git diff —&gt;比较的是工作目录中当前文件和暂存区域快照之间的差异<br>git diff –staged —&gt;比较已经暂存起来的文件和上次提交时的快照之间的差异</p>
<p>git commit -a -m “”—&gt;其中-a是add .的作用</p>
<p>git log -p -2 —&gt;-p是展开每个版本的不同点，-2是最近2次</p>
<h2 id="git-checkout主要有三个作用："><a href="#git-checkout主要有三个作用：" class="headerlink" title="git checkout主要有三个作用："></a>git checkout主要有三个作用：</h2><ul>
<li>第一个就是切换分支。例如你从远程仓库clone下来所有的源代码，你git branch一下会看到你通常是在master，如果你想切换到某一个分支上呢？git checkout <branchname></li>
<li>第二个就是放弃对某个文件的修改。例如你想放弃对某个文件Hello.cpp的修改，git checkout – &lt;Hello.cpp&gt;&#x2F;&#x2F;回到上个版本</li>
<li>第三个就是新建一个分支，git checkout &lt;-b&gt; <branchname>，不加-b的话只新建不切换到新的分支上，加-b新建并切换到该分支上<h2 id="git-reset主要是取消上一次的操作，具体用法有很多"><a href="#git-reset主要是取消上一次的操作，具体用法有很多" class="headerlink" title="git reset主要是取消上一次的操作，具体用法有很多:"></a>git reset主要是取消上一次的操作，具体用法有很多:</h2></li>
<li>第一个取消merge，git reset –hard ORIG_HEAD，这样会退回到merge前的代码。</li>
<li>第二个是将文件从stage（缓存区）中移除，git reset HEAD <filename><br>忽略某些文件</li>
<li>第三个就是取消commit，git reset HEAD~<num> &lt;-soft&#x2F;-hard&gt;，取消上num次的commit .将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中<code>git reset --mixed HEAD</code>  如果你想完全舍弃你没有提交的改动，你可以使用 <code>git reset --hard HEAD</code><h2 id="git-revert-撤销一个提交的同时会创建一个新的提交"><a href="#git-revert-撤销一个提交的同时会创建一个新的提交" class="headerlink" title="git revert 撤销一个提交的同时会创建一个新的提交"></a>git revert 撤销一个提交的同时会创建一个新的提交</h2>你也可以把 git revert 当作撤销已经提交的更改，而 git reset HEAD 用来撤销没有提交的更改。<br>[image:72F89E7D-B0C1-47A0-B2CC-1762EB05968A-26007-00004B3EC747D25B&#x2F;BEAF033D-F9E6-4393-B4C6-0BF330F0AB4A.png]</li>
</ul>
<h2 id="远程仓库git-remote"><a href="#远程仓库git-remote" class="headerlink" title="远程仓库git remote"></a>远程仓库git remote</h2><ul>
<li>git fetch [remote-name]：此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。不像git pull 只是把当前分支的代码拉下来，而是拉整个仓库的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</li>
<li>实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</li>
<li>git push [origin master]：把本地缓存区的代码推送的远程仓库.</li>
<li>查看远程仓库信息git remote show [remote-name]:除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 master 分支，就可以用 git pull 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。<h2 id="打标签git-tag"><a href="#打标签git-tag" class="headerlink" title="打标签git tag"></a>打标签git tag</h2></li>
<li>不含标注用 -l 含标注用- a -m后面带注释.<h2 id="查看相应标签的版本信息git-show"><a href="#查看相应标签的版本信息git-show" class="headerlink" title="查看相应标签的版本信息git show"></a>查看相应标签的版本信息git show</h2><h2 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h2><blockquote>
<p>merge和 rebase 所做的事其实是一样的,都是把两个分支合并,不过rebase 是变基而 merge 是真正的合并,这对后期查看分支有一定的影响.</p>
</blockquote>
</li>
</ul>
<p>所以，在你运行 git rebase 之前，一定要问问你自己「有没有别人正在这个分支上工作？」。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如 git revert）来提交你的更改。不然的话，你可以随心所欲地重写历史。</p>
<p><strong>当你理解 rebase 是什么的时候，最重要的就是什么时候 不能 用 rebase。git rebase 的黄金法则便是，绝不要在公共的分支上使用它。</strong></p>
<h2 id="忽略一些文件"><a href="#忽略一些文件" class="headerlink" title="忽略一些文件"></a>忽略一些文件</h2><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子：</p>
<p>我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br><span class="line">\</span><br></pre></td></tr></table></figure>
<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 .gitignore 的格式规范如下：</p>
<blockquote>
<p>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。<br>可以使用标准的 glob 模式匹配。<br>匹配模式最后跟反斜杠（&#x2F;）说明要忽略的是目录。<br>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。<br>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>
</blockquote>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># ignore all .txt files in the doc/ directory</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>golang 学习笔记</title>
    <url>/2021/07/15/golang%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="golang-学习笔记"><a href="#golang-学习笔记" class="headerlink" title="golang 学习笔记"></a>golang 学习笔记</h1><h2 id="语法部分"><a href="#语法部分" class="headerlink" title="语法部分"></a>语法部分</h2><h2 id="数组-n-T"><a href="#数组-n-T" class="headerlink" title="数组 [n]T"></a>数组 [n]T</h2><p>语法： 变量名 :&#x3D; [数组长度]数据类型{数组内数据}<br>例如： country :&#x3D; [3]string{‘中国’,’日本’,’韩国’}<br>也可以只生命，不赋值，或者不填满数组<br>      var country [5]string<br>      需要注意的是这个时候不能使用 :&#x3D;<br>      语法允许 var country [5]string<br>      或者  country :&#x3D; [5]string{}<br>golang 的数组是固定长度的，如果想使用不固定长度的，可以使用切片（slice）</p>
<span id="more"></span>

<h2 id="切片-T"><a href="#切片-T" class="headerlink" title="切片 []T"></a>切片 []T</h2><p>相比数组，切片不需要声明长度，语法是通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：<br>slice[low : high] &#x2F;&#x2F; 默认 low 是 0，high是数组上界<br>声明切片的方式有 3 种:</p>
<ol>
<li><p>从数组上进行切片</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">slice := array[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 从数组 array 上切下角标为 1 到 4(不包括)的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从切片上进行切片</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">slice1 := array[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// [2,3,4]</span></span><br><span class="line">slice2 := slice[<span class="number">1</span>:<span class="number">2</span>] <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单独声明一个切片</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// [1,2,3] 可以理解为不设置长度的数组就是切片</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>要注意的是<strong>它是一个半开区间，包括第一个元素，但排除最后一个元素</strong><br>比如： a :&#x3D; [5]int{1,2,3,4,5}<br>      b :&#x3D; a[1:4] &#x2F;&#x2F; 2,3,4  从 1 下标(包含)开始到 4 下标(不包含)<br>      c :&#x3D; b[0:2] &#x2F;&#x2F; 2,3</p>
<p><strong>切片并不存储任何数据，它只是引用了底层数组中的一段</strong></p>
<h3 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h3><p>切片的长度就是它所包含的元素个数<br>切片的容量是从它的第一个元素开始数，到其<strong>底层数组</strong>元素末尾的个数<br>切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的 len 和 js 中的 array.length 一样</span></span><br><span class="line"><span class="comment">// cap 需要对比起底层数组来看</span></span><br><span class="line">   s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// len=6 cap=6 s=[2 3 5 7 11 13]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">	s = s[:<span class="number">0</span>] <span class="comment">// len=0 cap=6 s=[] 开始的元素和底层数组一致，所以 cap 是 6</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拓展其长度</span></span><br><span class="line">	s = s[:<span class="number">4</span>] <span class="comment">// len=4 cap=6 s=[2 3 5 7] 开始的元素是 2，所以 cap 还是 6</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 舍弃前两个值</span></span><br><span class="line">	s = s[<span class="number">2</span>:] <span class="comment">// len=2 cap=4 s=[5 7] 开始的元素是 5，所以 cap 是 4</span></span><br></pre></td></tr></table></figure>

<h3 id="make-函数"><a href="#make-函数" class="headerlink" title="make 函数"></a>make 函数</h3><p>make函数有三个参数，最后一个是可选参数<br><code>make([]type, len, cap)</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	printSlice(<span class="string">&quot;a&quot;</span>, a) <span class="comment">// a len=5 cap=5 [0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">	printSlice(<span class="string">&quot;b&quot;</span>, b) <span class="comment">// b len=0 cap=5 []</span></span><br><span class="line"></span><br><span class="line">	c := b[:<span class="number">2</span>]</span><br><span class="line">	printSlice(<span class="string">&quot;c&quot;</span>, c) <span class="comment">// c len=2 cap=5 [0 0]</span></span><br><span class="line"></span><br><span class="line">	d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">	printSlice(<span class="string">&quot;d&quot;</span>, d) <span class="comment">// d len=3 cap=3 [0 0 0]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="type">string</span>, x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s len=%d cap=%d %v\n&quot;</span>,</span><br><span class="line">		s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="append-函数"><a href="#append-函数" class="headerlink" title="append 函数"></a>append 函数</h3><p>append 函数是用户在切片尾部追加元素，功能上类似 push<br>语法是 append(s []T, …T)<br>append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾<br>需要注意的是 append 函数不会改变 s，只会返回追加之后的值，所以需要赋值给 s<br><code>s = append(s[]T, ...T)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := [3]int&#123;1,2,3&#125; // 123</span><br><span class="line">b := a[:]; // 123</span><br><span class="line">b = append(b, 4, 5) // 12345</span><br></pre></td></tr></table></figure>

<p>如果切片是从数组引用来的，那么 append 方法会另外分配一个数组来存储新追加到切片尾部的数据，并不会改变原底层数组</p>
<h2 id="range-语法"><a href="#range-语法" class="headerlink" title="range 语法"></a>range 语法</h2><p>for 循环的range 是用来遍历数组、切片(slice)或者映射(map)的<br>for (let item in array){} 等同于<br>for _,item :&#x3D; range array {}<br>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// i 是数组下标 v是值</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2的%d次方 = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">2</span>的<span class="number">0</span>次方 = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>的<span class="number">1</span>次方 = <span class="number">2</span></span><br><span class="line"><span class="number">2</span>的<span class="number">2</span>次方 = <span class="number">4</span></span><br><span class="line"><span class="number">2</span>的<span class="number">3</span>次方 = <span class="number">8</span></span><br><span class="line"><span class="number">2</span>的<span class="number">4</span>次方 = <span class="number">16</span></span><br><span class="line"><span class="number">2</span>的<span class="number">5</span>次方 = <span class="number">32</span></span><br><span class="line"><span class="number">2</span>的<span class="number">6</span>次方 = <span class="number">64</span></span><br><span class="line"><span class="number">2</span>的<span class="number">7</span>次方 = <span class="number">128</span></span><br></pre></td></tr></table></figure>
<p>但是我们在遍历切片时，经常是不需要用到 index 的，比如JS 中的 for in 遍历<br>这个时候我们可以用_来表示忽略该参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pow := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// [0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123; <span class="comment">// 只需要 index 时可以忽略第二个参数与逗号</span></span><br><span class="line">		pow[i] = <span class="number">1</span> &lt;&lt; <span class="type">uint</span>(i) <span class="comment">// == 2**i8</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123; <span class="comment">// 只需要 value 时 index 使用_,代替</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p>结构体有点类似 js 中的 class,里面放的都是 class 的成员,并不是 map 那样的键值对.<br>使用 type 和 struct 声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width <span class="type">int</span></span><br><span class="line">	height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> setWidth() &#123;</span><br><span class="line">	r.width = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> setHeight() &#123;</span><br><span class="line">	r.height = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rec := Rectangle&#123;width: <span class="number">1</span>, height: <span class="number">1</span>&#125;</span><br><span class="line">	rec.setWidth()</span><br><span class="line">	fmt.Println(rec.width) <span class="comment">// 仍然是1</span></span><br><span class="line"></span><br><span class="line">	rec.setHeight()</span><br><span class="line">	fmt.Println(rec.height)  <span class="comment">// 变为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是方法的一种使用场景,奇怪的是把Rectangle作为函数接受对象时,加了个*,也就是使用结构体的指针,为什么不使用指针的时候 rec 的成员没有被改变呢?</p>
<p>不带指针的情况下,方法会拷贝一份新的结构体,这个时候操作的是新结构体的数据,对原结构体没有影响<br>官方文档也提到:<br>1.如果你需要在方法&#x2F;函数内改变Rectangle的值，则必须声明一个指针方法。<br>2.如果你的Rectangle结构体数据较大，比如有100个字段，如果使用不带指针的方法，则每一次都需要对其进行拷贝，内存消耗较大，此时建议使用带指针的方法。<br>3.如果有部分方法是带指针的，则为了代码统一，建议其他方法也写成带指针的。</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>go标准输出流占位符</title>
    <url>/2021/09/02/go%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81%E5%8D%A0%E4%BD%8D%E7%AC%A6.go/</url>
    <content><![CDATA[<h2 id="普通占位符"><a href="#普通占位符" class="headerlink" title="普通占位符"></a>普通占位符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符     说明                           举例                   输出</span><br><span class="line">%v      相应值的默认格式。             Printf(&quot;%v&quot;, people)    &#123;zhangsan&#125;，</span><br><span class="line">%+v     打印结构体时，会添加字段名      Printf(&quot;%+v&quot;, people)  &#123;Name:zhangsan&#125;</span><br><span class="line">%#v     相应值的Go语法表示            Printf(&quot;#v&quot;, people)   main.Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br><span class="line">%T      相应值的类型的Go语法表示       Printf(&quot;%T&quot;, people)    main.Human</span><br><span class="line">%%      字面上的百分号，并非值的占位符   Printf(&quot;%%&quot;)            %</span><br></pre></td></tr></table></figure>

<h2 id="布尔占位符"><a href="#布尔占位符" class="headerlink" title="布尔占位符"></a>布尔占位符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符       说明                举例                     输出</span><br><span class="line">%t          true 或 false。     Printf(&quot;%t&quot;, true)       true</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="整数占位符"><a href="#整数占位符" class="headerlink" title="整数占位符"></a>整数占位符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符     说明                                  举例                       输出</span><br><span class="line">%b      二进制表示                             Printf(&quot;%b&quot;, 5)             101</span><br><span class="line">%c      相应Unicode码点所表示的字符              Printf(&quot;%c&quot;, 0x4E2D)        中</span><br><span class="line">%d      十进制表示                             Printf(&quot;%d&quot;, 0x12)          18</span><br><span class="line">%o      八进制表示                             Printf(&quot;%d&quot;, 10)            12</span><br><span class="line">%q      单引号围绕的字符字面值，由Go语法安全地转义  Printf(&quot;%q&quot;, 0x4E2D)        &#x27;中&#x27;</span><br><span class="line">%x      十六进制表示，字母形式为小写 a-f          Printf(&quot;%x&quot;, 13)             d</span><br><span class="line">%X      十六进制表示，字母形式为大写 A-F          Printf(&quot;%x&quot;, 13)             D</span><br><span class="line">%U      Unicode格式：U+1234，等同于 &quot;U+%04X&quot;    Printf(&quot;%U&quot;, 0x4E2D)         U+4E2D</span><br></pre></td></tr></table></figure>

<h2 id="浮点数和复数的组成部分（实部和虚部）"><a href="#浮点数和复数的组成部分（实部和虚部）" class="headerlink" title="浮点数和复数的组成部分（实部和虚部）"></a>浮点数和复数的组成部分（实部和虚部）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符     说明                              举例            输出</span><br><span class="line">%b      无小数部分的，指数为二的幂的科学计数法，</span><br><span class="line">        与 strconv.FormatFloat 的 &#x27;b&#x27; 转换格式一致。例如 -123456p-78</span><br><span class="line">%e      科学计数法，例如 -1234.456e+78        Printf(&quot;%e&quot;, 10.2)     1.020000e+01</span><br><span class="line">%E      科学计数法，例如 -1234.456E+78        Printf(&quot;%e&quot;, 10.2)     1.020000E+01</span><br><span class="line">%f      有小数点而无指数，例如 123.456        Printf(&quot;%f&quot;, 10.2)     10.200000</span><br><span class="line">%g      根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%g&quot;, 10.20)   10.2</span><br><span class="line">%G      根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%G&quot;, 10.20+2i) (10.2+2i)</span><br></pre></td></tr></table></figure>

<h2 id="字符串与字节切片"><a href="#字符串与字节切片" class="headerlink" title="字符串与字节切片"></a>字符串与字节切片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符     说明                              举例                           输出</span><br><span class="line">%s      输出字符串表示（string类型或[]byte)   Printf(&quot;%s&quot;, []byte(&quot;Go语言&quot;))  Go语言</span><br><span class="line">%q      双引号围绕的字符串，由Go语法安全地转义  Printf(&quot;%q&quot;, &quot;Go语言&quot;)         &quot;Go语言&quot;</span><br><span class="line">%x      十六进制，小写字母，每字节两个字符      Printf(&quot;%x&quot;, &quot;golang&quot;)         676f6c616e67</span><br><span class="line">%X      十六进制，大写字母，每字节两个字符      Printf(&quot;%X&quot;, &quot;golang&quot;)         676F6C616E67</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符         说明                      举例                             输出</span><br><span class="line">%p      十六进制表示，前缀 0x          Printf(&quot;%p&quot;, &amp;people)             0x4f57f0</span><br></pre></td></tr></table></figure>

<h2 id="其它标记"><a href="#其它标记" class="headerlink" title="其它标记"></a>其它标记</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符      说明                             举例          输出</span><br><span class="line">+      总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 </span><br><span class="line">                                           Printf(&quot;%+q&quot;, &quot;中文&quot;)  &quot;\u4e2d\u6587&quot;</span><br><span class="line">-      在右侧而非左侧填充空格（左对齐该区域）</span><br><span class="line">#      备用格式：为八进制添加前导 0（%#o）      Printf(&quot;%#U&quot;, &#x27;中&#x27;)      U+4E2D</span><br><span class="line">       为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；</span><br><span class="line">       如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串；</span><br><span class="line">       如果是可打印字符，%U（%#U）会写出该字符的</span><br><span class="line">       Unicode 编码形式（如字符 x 会被打印成 U+0078 &#x27;x&#x27;）。</span><br><span class="line">&#x27; &#x27;    (空格)为数值中省略的正负号留出空白（% d）；</span><br><span class="line">       以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</span><br><span class="line">0      填充前导的0而非空格；对于数字，这会将填充移到正负号之后</span><br></pre></td></tr></table></figure>

<h2 id="golang没有-‘-u’-点位符，若整数为无符号类型，默认就会被打印成无符号的。"><a href="#golang没有-‘-u’-点位符，若整数为无符号类型，默认就会被打印成无符号的。" class="headerlink" title="golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。"></a>golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。</h2><pre><code>
</code></pre>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>记一次奇怪的 bug</title>
    <url>/2021/11/03/http%20header%20%E8%BF%87%E5%A4%A7%E8%BF%94%E5%9B%9E400%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前端和测试反馈说登录功能出现 bug,通过 F12 定位到是 getUserInfo 接口返回 400<br>重点是这个接口的报错和登录的账号有关,有些账号报 400,有些账号报 403,还有些账号登录成功.</p>
<span id="more"></span>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20211103143835.png"><br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20211103143927.png"></p>
<p>但是我通过 postman 请求,不管什么账户都能成功.而使用前端页面请求的确和前端测试反馈的一致.这点就非常奇怪.</p>
<h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>首先我发现页面 403 的请求明显没有传authorization字段,所以返回 403 是正常的,但是没有思考具体为什么登录接口有返回 token,但是前端没有带上.</p>
<p>400 的问题比较奇怪,没有任何 response,只有一个 status code 是 400.<br>因为异常和请求的账号有关,所以考虑到会不会是 token 不一样,解析出token 内部的数据导致的 bug,但是使用 postman 请求缺没有问题.</p>
<p>postman 请求和浏览器请求的不同点就在于浏览器请求还带上了很多的 header 参数,postman 由于是我后端自己测试,所以只添加了基本的authorization和Content-Type</p>
<p>查询资料发现,Nginx 服务器默认的 header 长度上限是 4k,如果超过这个值,Nginx 就会直接返回 400.通过想修改默认的 header 上限值,可以通过以下2个参数来调整nginx的header上限</p>
<ul>
<li>client_header_buffer_size 16k</li>
<li>large_client_header_buffers 4 16k</li>
</ul>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>由于我在加密 token 的时候将太多数据添加到 payload 里了,导致 token 过长.<br>403 是由于 token 过长,超过了浏览器支持的最大上限,所以根本添加不上去.<br>400 也是因为 token 过长,只不过没有超过浏览器的上限,但是加上其他的 header 参数,总长度超过了 Nginx 服务的默认长度上限.</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>缩小 header,将多余的数据从 payload 中剔除,token 就会变短.</li>
<li>修改 Nginx header 的上限</li>
</ol>
<h2 id="修改-Nginx-header-的上限的参数"><a href="#修改-Nginx-header-的上限的参数" class="headerlink" title="修改 Nginx header 的上限的参数"></a>修改 Nginx header 的上限的参数</h2><h3 id="nginx处理header时的方法："><a href="#nginx处理header时的方法：" class="headerlink" title="nginx处理header时的方法："></a>nginx处理header时的方法：</h3><ol>
<li>先处理请求的request_line</li>
<li>之后才是request_header</li>
</ol>
<p>这两者的buffer分配策略相同。<br>先根据client_header_buffer_size配置的值分配一个buffer，如果分配的buffer无法容纳 request_line&#x2F;request_header，那么就会再次根据large_client_header_buffers配置的参数分配large_buffer，如果large_buffer还是无法容纳，那么就会返回414（处理request_line）&#x2F;400（处理request_header）错误。<br>如果你的请求中的header都很大，那么应该使用client_header_buffer_size，这样能减少一次内存分配。<br>如果你的请求中只有少量请求header很大，那么应该使用large_client_header_buffers，因为这样就仅需在处理大header时才会分配更多的空间，从而减少无谓的内存空间浪费。</p>
<h3 id="针对get请求，解决请求串过长的问题："><a href="#针对get请求，解决请求串过长的问题：" class="headerlink" title="针对get请求，解决请求串过长的问题："></a>针对get请求，解决请求串过长的问题：</h3><p>针对get请求，我们可以通过修改另外两个配置来解决请求串超长的问题：client_header_buffer_size语法：client_header_buffer_size size默认值：1k使用字段：http, server这个指令指定客户端请求的http头部缓冲区大小绝大多数情况下一个头部请求的大小不会大于1k不过如果有来自于wap客户端的较大的cookie它可能会大于1k，Nginx将分配给它一个更大的缓冲区，这个值可以在large_client_header_buffers里面设置。large_client_header_buffers语法：large_client_header_buffers number size默认值：large_client_header_buffers 4 4k&#x2F;8k使用字段：http, server指令指定客户端请求的一些比较大的头文件到缓冲区的最大值，如果一个请求的URI大小超过这个值，服务器将返回一个”Request URI too large” (414)，同样，如果一个请求的头部字段大于这个值，服务器将返回”Bad request” (400)。缓冲区根据需求的不同是分开的。默认一个缓冲区大小为操作系统中分页文件大小，通常是4k或8k，如果一个连接请求将状态转换为keep-alive，这个缓冲区将被释放。</p>
<p>那么有人就会觉得奇怪了，为什么修改http header的大小就能解决get请求串过长的问题呢，这就要从http协议的get请求说起了，其实GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中）。</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 设备号对照表</title>
    <url>/2019/12/24/iOS%20%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="iOS-设备号对照"><a href="#iOS-设备号对照" class="headerlink" title="iOS 设备号对照"></a>iOS 设备号对照</h1><span id="more"></span>

<table>
<thead>
<tr>
<th>设备型号</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone3,1</td>
<td>iPhone 4</td>
</tr>
<tr>
<td>iPhone3,2</td>
<td>iPhone 4</td>
</tr>
<tr>
<td>iPhone3,3</td>
<td>iPhone 4</td>
</tr>
<tr>
<td>iPhone4,1</td>
<td>iPhone 4S</td>
</tr>
<tr>
<td>iPhone5,1</td>
<td>iPhone 5</td>
</tr>
<tr>
<td>iPhone5,2</td>
<td>iPhone 5</td>
</tr>
<tr>
<td>iPhone5,3</td>
<td>iPhone 5c</td>
</tr>
<tr>
<td>iPhone5,4</td>
<td>iPhone 5c</td>
</tr>
<tr>
<td>iPhone6,1</td>
<td>iPhone 5s</td>
</tr>
<tr>
<td>iPhone6,2</td>
<td>iPhone 5s</td>
</tr>
<tr>
<td>iPhone7,1</td>
<td>iPhone 6 Plus</td>
</tr>
<tr>
<td>iPhone7,2</td>
<td>iPhone 6</td>
</tr>
<tr>
<td>iPhone8,1</td>
<td>iPhone 6s</td>
</tr>
<tr>
<td>iPhone8,2</td>
<td>iPhone 6s Plus</td>
</tr>
<tr>
<td>iPhone8,4</td>
<td>iPhone SE</td>
</tr>
<tr>
<td>iPhone9,1</td>
<td>iPhone 7</td>
</tr>
<tr>
<td>iPhone9,2</td>
<td>iPhone 7 Plus</td>
</tr>
<tr>
<td>iPhone9,3</td>
<td>iPhone 7</td>
</tr>
<tr>
<td>iPhone9,4</td>
<td>iPhone 7 Plus</td>
</tr>
<tr>
<td>iPhone10,1</td>
<td>iPhone 8</td>
</tr>
<tr>
<td>iPhone10,2</td>
<td>iPhone 8 Plus</td>
</tr>
<tr>
<td>iPhone10,4</td>
<td>iPhone 8</td>
</tr>
<tr>
<td>iPhone10,5</td>
<td>iPhone 8 Plus</td>
</tr>
<tr>
<td>iPhone10,3</td>
<td>iPhone X</td>
</tr>
<tr>
<td>iPhone10,6</td>
<td>iPhone X</td>
</tr>
<tr>
<td>iPhone11,2</td>
<td>iPhone XS</td>
</tr>
<tr>
<td>iPhone11,4</td>
<td>iPhone XS Max</td>
</tr>
<tr>
<td>iPhone11,6</td>
<td>iPhone XS Max</td>
</tr>
<tr>
<td>iPhone11,8</td>
<td>iPhone XR</td>
</tr>
<tr>
<td>iPhone12,1</td>
<td>iPhone 11</td>
</tr>
<tr>
<td>iPhone12,3</td>
<td>iPhone 11 Pro</td>
</tr>
<tr>
<td>iPhone12,5</td>
<td>iPhone 11 Pro Max</td>
</tr>
<tr>
<td>i386</td>
<td>Simulator</td>
</tr>
<tr>
<td>x86_64</td>
<td>Simulator</td>
</tr>
<tr>
<td>iPod1,1</td>
<td>iPod Touch 1G</td>
</tr>
<tr>
<td>iPod2,1</td>
<td>iPod Touch 2G</td>
</tr>
<tr>
<td>iPod3,1</td>
<td>iPod Touch 3G</td>
</tr>
<tr>
<td>iPod4,1</td>
<td>iPod Touch 4G</td>
</tr>
<tr>
<td>iPod5,1</td>
<td>iPod Touch 5G</td>
</tr>
<tr>
<td>iPad1,1</td>
<td>iPad</td>
</tr>
<tr>
<td>iPad1,2</td>
<td>iPad 3G</td>
</tr>
<tr>
<td>iPad2,1</td>
<td>iPad 2</td>
</tr>
<tr>
<td>iPad2,2</td>
<td>iPad 2</td>
</tr>
<tr>
<td>iPad2,3</td>
<td>iPad 2</td>
</tr>
<tr>
<td>iPad2,4</td>
<td>iPad 2</td>
</tr>
<tr>
<td>iPad2,5</td>
<td>iPad Mini</td>
</tr>
<tr>
<td>iPad2,6</td>
<td>iPad Mini</td>
</tr>
<tr>
<td>iPad2,7</td>
<td>iPad Mini</td>
</tr>
<tr>
<td>iPad3,1</td>
<td>iPad 3</td>
</tr>
<tr>
<td>iPad3,2</td>
<td>iPad 3</td>
</tr>
<tr>
<td>iPad3,3</td>
<td>iPad 3</td>
</tr>
<tr>
<td>iPad3,4</td>
<td>iPad 4</td>
</tr>
<tr>
<td>iPad3,5</td>
<td>iPad 4</td>
</tr>
<tr>
<td>iPad3,6</td>
<td>iPad 4</td>
</tr>
<tr>
<td>iPad4,1</td>
<td>iPad Air</td>
</tr>
<tr>
<td>iPad4,2</td>
<td>iPad Air</td>
</tr>
<tr>
<td>iPad4,4</td>
<td>iPad Mini 2</td>
</tr>
<tr>
<td>iPad4,5</td>
<td>iPad Mini 2</td>
</tr>
<tr>
<td>iPad4,6</td>
<td>iPad Mini 2</td>
</tr>
<tr>
<td>iPad4,7</td>
<td>iPad Mini 3</td>
</tr>
<tr>
<td>iPad4,8</td>
<td>iPad Mini 3</td>
</tr>
<tr>
<td>iPad4,9</td>
<td>iPad Mini 3</td>
</tr>
<tr>
<td>iPad5,1</td>
<td>iPad Mini 4</td>
</tr>
<tr>
<td>iPad5,2</td>
<td>iPad Mini 4</td>
</tr>
<tr>
<td>iPad5,3</td>
<td>iPad Air 2</td>
</tr>
<tr>
<td>iPad5,4</td>
<td>iPad Air 2</td>
</tr>
<tr>
<td>iPad6,3</td>
<td>iPad Pro 9.7</td>
</tr>
<tr>
<td>iPad6,4</td>
<td>iPad Pro 9.7</td>
</tr>
<tr>
<td>iPad6,7</td>
<td>iPad Pro 12.9</td>
</tr>
<tr>
<td>iPad6,8</td>
<td>iPad Pro 12.9</td>
</tr>
<tr>
<td>iPad6,11</td>
<td>iPad 5</td>
</tr>
<tr>
<td>iPad6,12</td>
<td>iPad 5</td>
</tr>
<tr>
<td>iPad7,1</td>
<td>iPad Pro 12.9 inch 2nd gen</td>
</tr>
<tr>
<td>iPad7,2</td>
<td>iPad Pro 12.9 inch 2nd gen</td>
</tr>
<tr>
<td>iPad7,3</td>
<td>iPad Pro 10.5 inch</td>
</tr>
<tr>
<td>iPad7,4</td>
<td>iPad Pro 10.5 inch</td>
</tr>
<tr>
<td>iPad8,1 ~ 8,4</td>
<td>iPad Pro 11-inch</td>
</tr>
<tr>
<td>iPad8,5 ~ 8,8</td>
<td>iPad Pro 12.9-inch</td>
</tr>
<tr>
<td>iPad11,1</td>
<td>iPad Mini 5</td>
</tr>
<tr>
<td>iPad11,2</td>
<td>iPad Mini 5</td>
</tr>
<tr>
<td>iPad11,3</td>
<td>iPad Air 3</td>
</tr>
<tr>
<td>iPad11,4</td>
<td>iPad Air 3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2017/11/29/js%20%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p><a href="https://hexianzhi.github.io/2017/04/27/JavaScript%E5%8E%9F%E5%9E%8B/">js 原型和原型链</a><br><a href="http://barryliu1995.studio/2017/08/04/%E8%B0%88%E8%B0%88JavaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/#more">js 原型和原型链 2</a></p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript 中的定时任务</title>
    <url>/2019/03/08/js%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="JavaScript-中的定时任务"><a href="#JavaScript-中的定时任务" class="headerlink" title="JavaScript 中的定时任务"></a>JavaScript 中的定时任务</h1><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>一般在 node 中,执行定时任务的方式有:</p>
<ol>
<li>setTimeout</li>
<li>schedule包</li>
<li>轮询 redis 或数据库</li>
<li>延时队列</li>
</ol>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>setTimeout是最简单的办法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="title function_">callback</span>(), time);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在 setTimeout 的第一个参数里传方法或者需要执行的语句, 第二个函数传毫秒数,当 setTimeout 被执行后,就开始到技术 time,时间到了以后就会执行第一个参数.</p>
<p>在这里要注意的是,如果传的不是方法而是语句则需要加上引号变成字符串参数.因为 setTimeout 方法是使用了eval函数,但是出于对 eval 函数的安全顾虑,以及 js 的性能考虑,还是尽量不要直接传 js 语句,而是使用匿名箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>这样就是执行方法,而且还避免了另一个 setTimeout 方法容易出错的地方</p>
<h4 id="setTimeout中的this关键字将指向全局环境"><a href="#setTimeout中的this关键字将指向全局环境" class="headerlink" title="setTimeout中的this关键字将指向全局环境"></a>setTimeout中的this关键字将指向全局环境</h4><p>如果setTimeout 第一个参数传入正常的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(o.<span class="property">y</span>,<span class="number">1000</span>);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>输出的是1而不是2,这是因为 setTimeout 是全局对象window 的一个方法,所以在 setTimeout中的 this 指向的是全局环境.所以应该尽量在 setTimeout 中传入箭头函数, 箭头函数会绑定当前 this.</p>
<h3 id="schedule-定时任务"><a href="#schedule-定时任务" class="headerlink" title="schedule 定时任务"></a>schedule 定时任务</h3><p>node-schedule 是一个定时任务包,设定好时间以后,传入的方法就会在预定的时间执行.并且是循环执行.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">&#x27;node-schedule&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleCronstyle</span>(<span class="params"></span>)&#123;</span><br><span class="line">    schedule.<span class="title function_">scheduleJob</span>(<span class="string">&#x27;30 * * * * *&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scheduleCronstyle:&#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">scheduleCronstyle</span>();</span><br></pre></td></tr></table></figure>
<p>以上代码就是在每分钟的30s 都执行 function(),这里的第一个参数是 cron 风格的时间设定</p>
<h4 id="corn风格定时器"><a href="#corn风格定时器" class="headerlink" title="corn风格定时器"></a>corn风格定时器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*  *  *  *  *  *  *</span><br><span class="line">┬  ┬  ┬  ┬  ┬  ┬  ┬</span><br><span class="line">│  │  │  │  │  |  └ year(1970-2099, OPTIONAL)</span><br><span class="line">│  │  │  │  │  └ day of week (0 - 7) (0 or 7 is Sun)</span><br><span class="line">│  │  │  │  └───── month (1 - 12)</span><br><span class="line">│  │  │  └────────── day of month (1 - 31)</span><br><span class="line">│  │  └─────────────── hour (0 - 23)</span><br><span class="line">│  └──────────────────── minute (0 - 59)</span><br><span class="line">└───────────────────────── second (0 - 59, OPTIONAL)</span><br></pre></td></tr></table></figure>
<p>corn 风格的时间设定是由7位数组成,每个位置的符号或者数字表示不同的意思,<br>*代表不指定,可任意时间都满足<br>比如<br><code>30 30 * * * ? </code>就代表的是每小时的30分30秒,<br><code>30 30 13 * * ? </code>代表每天的13点30分30秒,<br><code>30 30 13 1 * ? </code>代表每个月1号的13点30分30秒,<br><code>30 30 13 1 5 ? </code>代表每年的5月1号13点30分30秒,<br>最后的?指定星期几的,如果指定了具体几号,那么星期几就没有指定,两者很多时候是冲突的,所以就用?代表随意星期几都可以.而最后一位的年很少会用到,毕竟指定某一年的定时任务需求非常少.</p>
<p>参考: <a href="http://cron.qqe2.com/">corn 表达式生成网站</a></p>
<h3 id="轮询-redis-或数据库"><a href="#轮询-redis-或数据库" class="headerlink" title="轮询 redis 或数据库"></a>轮询 redis 或数据库</h3><p>众所周知的 redis 有设置过期时间的功能, 在 redis 中设置一个独特的 key-value,然后设置它的过期时间,然后在代码里设置轮询,当查不到这个 key 的时候就执行函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ok = <span class="keyword">await</span> redis.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">        <span class="keyword">function</span>(<span class="params"></span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">100</span>); <span class="comment">// 延迟100ms,即每0.1s 查询一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法虽然也能做到定时任务,并且非常简单,但是长时间的 io 操作,非常影响效率.所以不推荐使用</p>
<h3 id="mq-延时队列"><a href="#mq-延时队列" class="headerlink" title="mq 延时队列"></a>mq 延时队列</h3><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190308152127.png"></p>
<h4 id="rabbit-延时队列流程"><a href="#rabbit-延时队列流程" class="headerlink" title="rabbit 延时队列流程:"></a>rabbit 延时队列流程:</h4><p>创建普通交换器-&gt;创建正常队列-&gt;绑定普通交换器和死信交换器、死信路由-&gt;发送消息，设置过期时间-&gt;TTL 过期-&gt; 被发送到死信交换器-&gt;消费者创建死信交换器-&gt; 消费者创建死信队列-&gt; 绑定死信队列到死信交换器上-&gt;死信交换器把 msg 发到死信队列上-&gt;消费者拿到数据</p>
<h4 id="rabbit-npm-amqplib包的实现"><a href="#rabbit-npm-amqplib包的实现" class="headerlink" title="rabbit npm amqplib包的实现"></a>rabbit npm amqplib包的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">client.<span class="property">sendDelayedMessage</span> = <span class="keyword">async</span> (content, queueName, expires) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dle = <span class="string">&#x27;vs_dead_letter_exchange&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> dlrk = <span class="string">`<span class="subst">$&#123;queueName&#125;</span>_dlrk`</span>;</span><br><span class="line">        <span class="keyword">const</span> deadQueue = <span class="string">`<span class="subst">$&#123;queueName&#125;</span>_deadletter`</span>;</span><br><span class="line">        channelWrapper.<span class="title function_">addSetup</span>(<span class="keyword">async</span> (channel) =&gt; &#123;</span><br><span class="line">            <span class="keyword">await</span> channel.<span class="title function_">assertExchange</span>(dle, <span class="string">&#x27;direct&#x27;</span>);</span><br><span class="line">            <span class="keyword">const</span> ok = <span class="keyword">await</span> channel.<span class="title function_">assertQueue</span>(deadQueue, &#123;</span><br><span class="line">                <span class="attr">deadLetterExchange</span>: dle,</span><br><span class="line">                <span class="attr">deadLetterRoutingKey</span>: dlrk,</span><br><span class="line">            &#125;);</span><br><span class="line">            channel.<span class="title function_">sendToQueue</span>(ok.<span class="property">queue</span>, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(content)), &#123; <span class="attr">expiration</span>: <span class="title class_">String</span>(expires) &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`sendDelayedMessage err -&gt; <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client.<span class="property">consumeDelayed</span> = <span class="keyword">async</span> (queueName, cb, noAck = <span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dle = <span class="string">&#x27;vs_dead_letter_exchange&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> dlrk = <span class="string">`<span class="subst">$&#123;queueName&#125;</span>_dlrk`</span>;</span><br><span class="line">        channelWrapper.<span class="title function_">addSetup</span>(<span class="keyword">async</span> (channel) =&gt; &#123;</span><br><span class="line">            <span class="keyword">await</span> channel.<span class="title function_">assertExchange</span>(dle, <span class="string">&#x27;direct&#x27;</span>);</span><br><span class="line">            <span class="keyword">const</span> ok = <span class="keyword">await</span> channel.<span class="title function_">assertQueue</span>(queueName)</span><br><span class="line">            channel.<span class="title function_">bindQueue</span>(ok.<span class="property">queue</span>, dle, dlrk);</span><br><span class="line">            channel.<span class="title function_">consume</span>(ok.<span class="property">queue</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">cb</span>(msg);</span><br><span class="line">            &#125;, &#123; <span class="attr">noAck</span>: noAck&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`consumeDelayed err -&gt; <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>优点: 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。</p>
<p>缺点: 本身的易用度要依赖于rabbitMq的运维.因为要引用rabbitMq,所以复杂度和成本变高.</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>js 的 Event Loop</title>
    <url>/2018/05/28/js%20%E7%9A%84%20Even%20Loop/</url>
    <content><![CDATA[<h2 id="JavaScript-的运行机制"><a href="#JavaScript-的运行机制" class="headerlink" title="JavaScript 的运行机制:"></a>JavaScript 的运行机制:</h2><p><img src="http://p04c6djlz.bkt.clouddn.com//18-5-28/11519764.jpg"></p>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop:"></a>EventLoop:</h2><p><img src="http://p04c6djlz.bkt.clouddn.com//18-5-28/60180128.jpg"></p>
<span id="more"></span>

<h2 id="至于哪些是宏操作哪些是微操作"><a href="#至于哪些是宏操作哪些是微操作" class="headerlink" title="至于哪些是宏操作哪些是微操作:"></a>至于哪些是宏操作哪些是微操作:</h2><ul>
<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval, setImmediate(node环境下)。</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p>也就是说,从代码开始执行,就先创建一个宏操作,相当于是对代码的整体编译,然后每遇到一个宏操作或者微操作,都会将其放到对应的位置去,比如宏操作会放到主执行栈, 微操作会放到Event Queue 中.然后当代码”编译”执行完,也就是主执行栈执行完成,这个时候就会去执行 Event Queue, 也就是刚刚代码中的 Promise 或者 process.nextTick. 例如这段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout1&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout2&#x27;</span>), <span class="number">10</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果为script start, promise1, script end, then1, timeout1, timeout2</span></span><br></pre></td></tr></table></figure>

<p>如果一开始不熟练的话可以画出两个队列,分别把要执行的程序排进去</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 如何跳出 forEach 的循环</title>
    <url>/2018/07/26/js%20%E8%B7%B3%E5%87%BA%20forEach%20%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="js-跳出-forEach-循环"><a href="#js-跳出-forEach-循环" class="headerlink" title="js 跳出 forEach 循环"></a>js 跳出 forEach 循环</h1><p>其实就是在 forEach 中实现了 continue 的功能<br>现在有一个二重循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">routeMsg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">bigItem, index</span>) =&gt;</span> &#123;</span><br><span class="line">  route.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>  =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(bigItem.<span class="property">id</span>) ===  <span class="built_in">parseInt</span>(item.<span class="property">id</span>)) &#123;</span><br><span class="line">      status[index] =  <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      status[index] =  <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>需求要在外层的 item.id &#x3D;&#x3D;&#x3D; 内层的 item.id 时 status[index] &#x3D; 1<br>但是如果在 status[index] &#x3D; 1 时不跳出循环的话，在下一次内层循环时，会执行 status[index] &#x3D; 0，因为此时 index 是不会变的，所以就覆盖了上一次置 1 的数据.</p>
<p>JavaScript 中跳出 for 循环用的是 break， 但是 Array.forEach 却没有可以直接跳出循环的语句，需要在 forEach 外加上一层 try&#x2F;catch， 然后在需要跳出循环的地方写 <code>throw (new Error(&#39;continue&#39;))</code>，这样代码就会跳出内层循环，外层循环的 index 也就会+1</p>
<p>代码如下: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">routeMsg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">bigItem, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    route.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>  =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">parseInt</span>(bigItem.<span class="property">id</span>) ===  <span class="built_in">parseInt</span>(item.<span class="property">id</span>)) &#123;</span><br><span class="line">        status[index] =  <span class="number">1</span></span><br><span class="line">        <span class="keyword">throw</span> (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;continue&#x27;</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status[index] =  <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; <span class="keyword">catch</span> (err)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 的错误处理</title>
    <url>/2019/05/31/js%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在使用异步的终极解决方案-ES7的async&#x2F;await同时，如何优雅的处理错误提高代码的兼容性让作为码农的我很头疼。在项目实战中合理的使用try…catch…让代码的兼容和稳定性大大增强。</p>
<h1 id="本文将对-try…catch…-分成三个方面来叙述。"><a href="#本文将对-try…catch…-分成三个方面来叙述。" class="headerlink" title="本文将对 try…catch… 分成三个方面来叙述。"></a>本文将对 try…catch… 分成三个方面来叙述。</h1><ul>
<li>为什么要用</li>
<li>如何使用</li>
<li>实战</li>
</ul>
<h2 id="1、为什么要用-try…catch…"><a href="#1、为什么要用-try…catch…" class="headerlink" title="1、为什么要用 try…catch…"></a>1、为什么要用 try…catch…</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">funcAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n---begin---\n&#x27;</span>);</span><br><span class="line">   <span class="keyword">await</span> <span class="title function_">ih_func</span>();</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------end-----&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ih_func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//这里相当于throw一个异常了</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">funcAsync</span>();</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190531110432.png"></p>
<p>你一定会好奇为什么只打印了begin而没有打印end，这是因为reject(‘error’); 相当于throw一个异常了，所以程序就不会继续往下执行了，想要程序继续执行下去就需要处理throw出来的异常。</p>
<span id="more"></span>

<h2 id="2、如何使用-try…catch…-处理异常"><a href="#2、如何使用-try…catch…-处理异常" class="headerlink" title="2、如何使用 try…catch… 处理异常"></a>2、如何使用 try…catch… 处理异常</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">funcAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n---begin---\n&#x27;</span>);</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">ih_func</span>();</span><br><span class="line">   &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------end-----&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ih_func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//这里相当于throw一个异常了</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">funcAsync</span>();</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/media/15592719004630.jpg"></p>
<p>惊奇的发现通过 try…catch… 处理异常后的程序神奇的执行完成了。</p>
<p>在try{}中的代码 throw 出来的异常会被 catch 捕获到，程序认为你处理异常了，所以继续往下执行了</p>
<h2 id="3、-try…catch…-之实战"><a href="#3、-try…catch…-之实战" class="headerlink" title="3、 try…catch…  之实战"></a>3、 try…catch…  之实战</h2><p>程序如何处理异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">funcAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n---begin---\n&#x27;</span>);</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">ih_func</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------end-----&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----end2-----&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ih_func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//这里相当于throw一个异常了</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">funcAsync</span>();</span><br></pre></td></tr></table></figure>

<p>运行结果<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190531110024.png"></p>
<p>上面代码运行代码后发现，当 ih_func() throw出异常后，被外层的catch捕获并处理，而且直接跳出打印end2。并没有我们预期中，继续往下执行打印end。</p>
<p>多层try…catch… 如何处理异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">funcAsync_1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;  </span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">funcAsync_2</span>();</span><br><span class="line">   &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;funcAsync_1&#x27;</span>);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;funcAsync_1 ----  end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">funcAsync_2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n---begin&#x27;</span>+ i +<span class="string">&#x27;---\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">ih_func</span>(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------end&#x27;</span>+ i +<span class="string">&#x27;-----&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ih_func</span>(<span class="params">args</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//这里相当于throw一个异常了</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span> + args);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">funcAsync_1</span>();</span><br></pre></td></tr></table></figure>

<p>运行结果<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190531110111.png"></p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>一层 try…catch…的时候： 当程序 throw 出异常后，被外层的catch捕获并处理，程序在catch捕获处继续执行下去。</p>
<p>多层try…catch…的时候：当程序 throw 出异常后，会被离异常最近的catch捕获并处理，程序在catch捕获处继续执行下去。</p>
<p>当程序throw出一个异常后，会从里往外一直寻找处理异常的catch，当找到离异常最近的catch时，会被这个catch处理，并不会再往外传递异常，而且会在catch处理当前代码行继续往下执行。</p>
<p>如何提高程序的健壮性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">funcAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n---begin&#x27;</span>+ i +<span class="string">&#x27;---\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">ih_func</span>(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------end&#x27;</span>+ i +<span class="string">&#x27;-----&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ih_func</span>(<span class="params">args</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//这里相当于throw一个异常了</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span> + args);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">funcAsync</span>();</span><br></pre></td></tr></table></figure>

<p>运行结果<br><img src="/media/15592717098446.jpg"></p>
<p>对于多个await Promise返回值的时候，可以对具有Promise返回值为reject的异步操作时，使用 try…catch…不仅可以增强代码的健壮性，而且使代码在我们预期中执行下去。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 的错误捕获</title>
    <url>/2019/03/07/js%20%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<h1 id="JavaScript-的错误捕获"><a href="#JavaScript-的错误捕获" class="headerlink" title="JavaScript 的错误捕获"></a>JavaScript 的错误捕获</h1><h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><ol>
<li>EvalError，调用eval()时发生的异常，已被废弃只用于向后兼容而已</li>
<li>InternalError，JavaScript引擎内部异常，FireFox独门提供的！</li>
<li>RangeError，当函数实参越界时发生，如Array，Number.toExponential,Number.toFixed和Number.toPrecision时入参非法时。</li>
<li>ReferenceError，当引用未声明的变量时发生</li>
<li>SyntaxError，解析时发生语法错误</li>
<li>TypeError，当值不是所期待的类型时，null.f()也报这个错</li>
<li>URIError，当传递一个非法的URI给全局URI处理函数时发生，如decodeURIComponent(‘%’)，即decodeURIComponent，decodeURI,encodeURIComponent，encodeURI</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise1</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;resolve promise1&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">console</span>(<span class="number">2</span>); <span class="comment">// 这里是错误</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;resolve promise3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try - catch"></a>try - catch</h2><h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><p>在执行一系列的 Promise 时,如果是异步执行,(既不使用async await)则其他没有报错的 promise 会正常执行,而出错的 Promise 会在第一次执行的时候就被捕获<br>如果如下方法执行的话</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_">promise1</span>(i);</span><br><span class="line">            <span class="title function_">promise2</span>();</span><br><span class="line">            <span class="title function_">promise3</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`err =&gt;<span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="attr">node</span>:<span class="number">3226</span>) <span class="title class_">UnhandledPromiseRejectionWarning</span>: <span class="title class_">Unhandled</span> promise rejection (rejection <span class="attr">id</span>: <span class="number">1</span>): <span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<h3 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h3><p>如果使用了async await, main 函数变成这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">promise1</span>(i);</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">promise2</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">promise3</span>(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`err =&gt;<span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">err =&gt;<span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">err =&gt;<span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">err =&gt;<span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">err =&gt;<span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">err =&gt;<span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<p>那么代码在运行到 <code>promise2();</code>时就停下来,因为 promise3需要等待 promise2的结果,而 promise2又报错了,所以这个循环就会到此结束,promise3并不会执行.<br>如果想在同步执行,但是又不想因为promise2的错误影响promise3的执行,这个时候就需要在可能会出错的 promise 后使用.catch()</p>
<h2 id="promise-catch"><a href="#promise-catch" class="headerlink" title="promise.catch()"></a>promise.catch()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">promise1</span>(i);</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">promise2</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">promise3</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`err =&gt;<span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br><span class="line">    at <span class="title class_">Promise</span> (<span class="regexp">/Users/</span>bhb/code/testTryCatch.<span class="property">js</span>:<span class="number">10</span>:<span class="number">9</span>)</span><br><span class="line">    at <span class="keyword">new</span> <span class="title class_">Promise</span> (&lt;anonymous&gt;)</span><br><span class="line">    at promise2 (<span class="regexp">/Users/</span>bhb/code/testTryCatch.<span class="property">js</span>:<span class="number">9</span>:<span class="number">12</span>)</span><br><span class="line">    at main (<span class="regexp">/Users/</span>bhb/code/testTryCatch.<span class="property">js</span>:<span class="number">30</span>:<span class="number">19</span>)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process.<span class="property">_tickCallback</span> (internal/process/next_tick.<span class="property">js</span>:<span class="number">188</span>:<span class="number">7</span>)</span><br><span class="line">    at <span class="title class_">Function</span>.<span class="property">Module</span>.<span class="property">runMain</span> (<span class="variable language_">module</span>.<span class="property">js</span>:<span class="number">678</span>:<span class="number">11</span>)</span><br><span class="line">    at startup (bootstrap_node.<span class="property">js</span>:<span class="number">187</span>:<span class="number">16</span>)</span><br><span class="line">    at bootstrap_node.<span class="property">js</span>:<span class="number">608</span>:<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br><span class="line">    at <span class="title class_">Promise</span> (<span class="regexp">/Users/</span>bhb/code/testTryCatch.<span class="property">js</span>:<span class="number">10</span>:<span class="number">9</span>)</span><br><span class="line">    at <span class="keyword">new</span> <span class="title class_">Promise</span> (&lt;anonymous&gt;)</span><br><span class="line">    at promise2 (<span class="regexp">/Users/</span>bhb/code/testTryCatch.<span class="property">js</span>:<span class="number">9</span>:<span class="number">12</span>)</span><br><span class="line">    at main (<span class="regexp">/Users/</span>bhb/code/testTryCatch.<span class="property">js</span>:<span class="number">30</span>:<span class="number">19</span>)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process.<span class="property">_tickCallback</span> (internal/process/next_tick.<span class="property">js</span>:<span class="number">188</span>:<span class="number">7</span>)</span><br><span class="line">    at <span class="title class_">Function</span>.<span class="property">Module</span>.<span class="property">runMain</span> (<span class="variable language_">module</span>.<span class="property">js</span>:<span class="number">678</span>:<span class="number">11</span>)</span><br><span class="line">    at startup (bootstrap_node.<span class="property">js</span>:<span class="number">187</span>:<span class="number">16</span>)</span><br><span class="line">    at bootstrap_node.<span class="property">js</span>:<span class="number">608</span>:<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title class_">TypeError</span>: <span class="variable language_">console</span> is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<p>如果在一系列的同步执行 promise 中,报错的 promise 后.catch().做了错误捕获和处理,那么就不会影响后面的 promise 执行.</p>
<h2 id="promise-catch-throw-err"><a href="#promise-catch-throw-err" class="headerlink" title="promise.catch(throw err)"></a>promise.catch(throw err)</h2><p>如果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那么当前这个 promise 的错误就被会抛出,被当前的 try - catch 所捕获,同样的,当前这个循环就被会终止</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>当 promise 被同步执行的时候,如果遇到错误,并且没有被.catch后进行错误处理,那么当前的方法就会到此结束,后面的代码都不会被执行.</p>
</li>
<li><p>如果想一个 promise 的错误不影响整个方法的话,有2种方法:</p>
<ol>
<li>如果后面的代码不是需要前面的 promise 执行的结果的话,则不使用 async await,</li>
<li>如果需要同步执行,则对可预期的容易报错方法进行单独的.catch() 并在方法里进行错误处理.</li>
</ol>
</li>
<li><p>当然,如果要求一定需要执行错误 promise 后的代码,则不需要单独处理,只需要在整个方法里上加上 try - catch 进行错误捕获,然后 throw 错误或者直接处理错误(一般就是 logger.error()).</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 闭包学习</title>
    <url>/2017/11/29/js%20%E9%97%AD%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="闭包，简单来说就是可以读取其他函数内部变量的函数。只要满足这一点的函数，都可以叫闭包。"><a href="#闭包，简单来说就是可以读取其他函数内部变量的函数。只要满足这一点的函数，都可以叫闭包。" class="headerlink" title="闭包，简单来说就是可以读取其他函数内部变量的函数。只要满足这一点的函数，都可以叫闭包。"></a>闭包，简单来说就是可以读取其他函数内部变量的函数。只要满足这一点的函数，都可以叫闭包。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(n++) </span><br><span class="line">  &#125;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="title function_">example</span>();</span><br><span class="line"><span class="title function_">fun</span>();</span><br><span class="line"><span class="comment">// 1 执行完后 n++，变量n任然存在于内存中 fun();// 2 fun = null;// n被回收 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这里就是典型的从 function example 外部访问了内部的 变量 n. 这就是闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> n=<span class="number">1</span>; </span><br><span class="line">  <span class="title class_">Add</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    n+=<span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">example2</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="title function_">alert</span>(n); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> example2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=<span class="title function_">example1</span>(); </span><br><span class="line"><span class="title function_">result</span>(); </span><br><span class="line"><span class="comment">// 1 Add(); result(); // 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码中第一个” result(); “执行完以后，输出结果 “1”,第二的” result(); “执行完以后，输出结果 “2”，这就证明了，函数 example1 中的局部变量n一直保存在内存中，并没有在第一个” result(); “执行完以后被自动清除；才能在执行第二个”result(); “完以后，输出结果 “2”，如果这样就容易造成我们平时所说的全局空间污染。</p>
<p>还需要注意的是，上面的 <code>Add=function()&#123;n+=1&#125;</code> 这部分代码，一看这家伙居然没有名字（匿名函数），而且，变量还是没通过 var 去命名的，所以呢，就定义成了一个全局变量，所以外部函数当然可以对它”拳打脚踢”的操作咯；所以就有了<code>Add();</code> 执行以后，第二个 <code>result();</code>才能实现 n 的累加输出 “2”。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>array&#39;s func</title>
    <url>/2017/11/29/js_array_func/</url>
    <content><![CDATA[<p><img src="http://p04c6djlz.bkt.clouddn.com//17-11-29/53994765.jpg"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>scrollIntoView事件</title>
    <url>/2019/09/04/js%E9%A1%B5%E9%9D%A2%E5%86%85%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>经常在用的一个配置管理页面在产品迭代了几个版本以后发现配置页越来越长,但是又不想做成两列(觉得丑),所以就自己写了一个目录,点击以后页面会滑动到对应的配置项.<br>一开始是打算用 a 标签的 href 来做,但是发现这个方式点击以后会改变 URL,而且是直接跳到指定的标签,用户体验不是很好,就改用scrollIntoView</p>
<h1 id="scrollIntoView事件"><a href="#scrollIntoView事件" class="headerlink" title="scrollIntoView事件"></a>scrollIntoView事件</h1><p>Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内<br>只要用<code>document.getElementById()</code>方法找到要跳转的 element,然后就可以用scrollIntoView方法实现跳转,代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(target).<span class="title function_">scrollIntoView</span>(&#123;</span><br><span class="line">    <span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>,</span><br><span class="line">    <span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>scrollIntoView方法有 3 个多态,分别是不传参数,传 Boolean型的参数,传 Object 型的参数.</p>
<blockquote>
<p>element.scrollIntoView(); &#x2F;&#x2F; 等同于element.scrollIntoView(true)<br>element.scrollIntoView(alignToTop); &#x2F;&#x2F; Boolean型参数<br>element.scrollIntoView(scrollIntoViewOptions); &#x2F;&#x2F; Object型参数</p>
</blockquote>
<span id="more"></span>

<h3 id="alignToTop"><a href="#alignToTop" class="headerlink" title="alignToTop"></a>alignToTop</h3><p>一个Boolean值：<br>如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的 <code>scrollIntoViewOptions: &#123;block: &quot;start&quot;, inline: &quot;nearest&quot;&#125;</code>。这是这个参数的默认值。<br>如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的<code>scrollIntoViewOptions: &#123;block: &quot;end&quot;, inline: &quot;nearest&quot;&#125;</code>。</p>
<h3 id="scrollIntoViewOptions-可选"><a href="#scrollIntoViewOptions-可选" class="headerlink" title="scrollIntoViewOptions 可选"></a>scrollIntoViewOptions 可选</h3><p>一个带有选项的object：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    behavior<span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span>  | <span class="string">&quot;instant&quot;</span> | <span class="string">&quot;smooth&quot;</span><span class="punctuation">,</span> <span class="comment">//定义缓动动画 (可选)</span></span><br><span class="line">    block<span class="punctuation">:</span> <span class="string">&quot;start&quot;</span> | <span class="string">&quot;end&quot;</span><span class="punctuation">,</span> <span class="comment">// 跳转后标签位于屏幕的什么位置 (可选)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>实现非常简单,写一个固定在屏幕右上方的框框,带上一个阴影,其中最重要的是<code>z-index:10;</code>这一步,一定要把这个框框放到最上面的一层,保证不会被其他元素遮挡.然后加上一个:hover,使标题被选中时背景变色,鼠标变成手,然后用户更加清楚的知道自己选到了哪个标题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.catalog</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">170px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">10</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">6px</span> <span class="built_in">rgb</span>(<span class="number">89</span>, <span class="number">89</span>, <span class="number">89</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.roll</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">64</span>,<span class="number">158</span>,<span class="number">255</span>,.<span class="number">4</span>);</span><br><span class="line">    <span class="attribute">cursor</span>:pointer</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;roll&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;scrollTo(&#x27;pic&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">    图片配置</span></span><br><span class="line"><span class="tag">&lt;/<span class="attr">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终效果<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190904175437.png"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>初学 kafka</title>
    <url>/2018/08/13/kafka-node/</url>
    <content><![CDATA[<h1 id="kafka-node"><a href="#kafka-node" class="headerlink" title="kafka-node"></a>kafka-node</h1><blockquote>
<p>kafka 是一个高吞吐的分布式发布订阅消息系统<br>当瞬发数据量非常庞大的时候，就可以使用 kafka 做消息队列， 由生产者把数据放入 kafka 服务的消息队列中，由 kafka 来控制调度消费者来消费掉这些数据，这个过程如果由 API 服务器直接做的话，很可能会因为并发量过大导致操作速度慢，甚至于宕机.</p>
</blockquote>
<p>如果我们用 kafka 来控制这个过程，就会变的非常安全， kafka 的高吞吐量能够轻松容纳每秒数百万次的消息.</p>
<span id="more"></span>
<h2 id="首先，-kafka-是一项服务进程，所以我们要先安装到本地或者服务器上"><a href="#首先，-kafka-是一项服务进程，所以我们要先安装到本地或者服务器上" class="headerlink" title="首先， kafka 是一项服务进程，所以我们要先安装到本地或者服务器上"></a>首先， kafka 是一项服务进程，所以我们要先安装到本地或者服务器上</h2><ol>
<li>使用 homebrew 安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install kafka</span><br></pre></td></tr></table></figure>

<p>会自动安装依赖zookeeper</p>
<ol start="2">
<li>安装配置文件位置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/etc/kafka|zookeeper</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动 zookeeper</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/Cellar/kafka/0.10.0.1</span><br><span class="line">./bin/zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动 kafka 服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-server-start /usr/local/etc/kafka/server.properties &amp;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建 topic</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test1</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>查看创建的topic</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>生产数据</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-producer --broker-list localhost:9092 --topic test1</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>消费数据</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-consumer --zookeeper localhost:2181 --topic test1 --from-beginning</span><br></pre></td></tr></table></figure>


<p>到这里 kafka 的基本安装就完成了，接下来是编写生产和消费的代码， 环境使用的是 node.js，框架是 kafka-node.</p>
<h2 id="编写业务逻辑代码"><a href="#编写业务逻辑代码" class="headerlink" title="编写业务逻辑代码"></a>编写业务逻辑代码</h2><p>在生产中先创建一个连接 kafka 的对接对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> client  =  <span class="keyword">new</span> kafka.<span class="title class_">KafkaClient</span>(&#123;</span><br><span class="line">  <span class="attr">kafkaHost</span>: confKafka.<span class="property">connData</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里的 kafkaHost 是一个 URL 字符串.而且要求 kafka 版本要比较高才可以用这个对象.<br>然后写具体逻辑</p>
<h3 id="生产者："><a href="#生产者：" class="headerlink" title="生产者："></a>生产者：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">km</span>  =  <span class="keyword">new</span> kafka.<span class="title class_">KeyedMessage</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;message&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span>  payloads  = [&#123;</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;test1&#x27;</span>,</span><br><span class="line">  <span class="attr">messages</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params),</span><br><span class="line">  <span class="attr">partition</span>: <span class="number">0</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;test2&#x27;</span>,</span><br><span class="line">  <span class="attr">messages</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params),</span><br><span class="line">  <span class="attr">partition</span>: <span class="number">0</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;test3&#x27;</span>,</span><br><span class="line">  <span class="attr">messages</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params),</span><br><span class="line">  <span class="attr">partition</span>: <span class="number">0</span></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  producer  =  <span class="keyword">new</span> kafka.<span class="title class_">Producer</span>(<span class="variable language_">this</span>.<span class="property">client</span>)</span><br><span class="line">producer.<span class="title function_">on</span>(<span class="string">&#x27;ready&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="number">3</span></span><br><span class="line">  <span class="comment">// producer.createTopics(&#x27;test3&#x27;, false, function (err, data) &#123;</span></span><br><span class="line">  <span class="comment">// console.log(err, data)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  producer.<span class="title function_">send</span>(payloads, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>, err, data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">producer.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者:"></a>消费者:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">client</span>  =  <span class="keyword">new</span> kafka.<span class="title class_">KafkaClient</span>(&#123;</span><br><span class="line">  <span class="attr">kafkaHost</span>: config.<span class="property">connData</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> payloads  = [&#123;</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;test1&#x27;</span>,</span><br><span class="line">  <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">partition</span>: <span class="number">0</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">let</span>  options  = &#123;</span><br><span class="line">  <span class="attr">autoCommit</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  consumer  =  <span class="keyword">new</span> kafka.<span class="title class_">Consumer</span>(<span class="variable language_">this</span>.<span class="property">client</span>, payloads, options)</span><br><span class="line"><span class="comment">// 业务处理</span></span><br><span class="line">consumer.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">async</span> (message) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span>  params  =  <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">value</span>)</span><br><span class="line"><span class="comment">// 注册到TTN(业务逻辑)</span></span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">  <span class="keyword">await</span>  <span class="variable language_">this</span>.<span class="property">ttn</span>.<span class="title function_">registerDevice</span>(params.<span class="property">devID</span>, params.<span class="property">eui</span>)</span><br><span class="line"><span class="comment">// 保存到本地</span></span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line"><span class="comment">// 成功后提交offset</span></span><br><span class="line">  consumer.<span class="title function_">setOffset</span>(message.<span class="property">topic</span>, message.<span class="property">partition</span>, message.<span class="property">offset</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">&#125;)</span><br><span class="line">consumer.<span class="title function_">on</span>(<span class="string">&#x27;offsetOutOfRange&#x27;</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;offsetOutOfRange&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line">consumer.<span class="title function_">on</span>(<span class="string">&#x27;err&#x27;</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="这样就可以完成生产者生产资料，发送到-kafka，-然后-kafka-调用消费者，让消费者去消费这些资料"><a href="#这样就可以完成生产者生产资料，发送到-kafka，-然后-kafka-调用消费者，让消费者去消费这些资料" class="headerlink" title="这样就可以完成生产者生产资料，发送到 kafka， 然后 kafka 调用消费者，让消费者去消费这些资料"></a>这样就可以完成生产者生产资料，发送到 kafka， 然后 kafka 调用消费者，让消费者去消费这些资料</h3>]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>koa-log4</title>
    <url>/2017/11/27/koa-log4/</url>
    <content><![CDATA[<p>参考文章: <a href="https://zhuanlan.zhihu.com/p/22110802">知乎专栏</a></p>
<p>一、日志配置<br>1、 依赖选择： 根据koa wiki中的介绍，中间件 koa-log4 是 log4js-node koa版本， 且支持 koa2。 npm i –save koa-log4<br>2、 新建日志路径： .&#x2F;logs， 用于存放生成的日志文件<br>3、 新建日志配置文件： .&#x2F;log.js, 加入代码：</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">./log.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">&#x27;koa-log4&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logDir = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;logs&#x27;</span>)  <span class="comment">//配置目标路径 logs</span></span><br><span class="line"><span class="comment">/*生成logs目录*/</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">mkdirSync</span>(logDir)  <span class="comment">//新建目录， ./logs</span></span><br><span class="line"> &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">if</span>(err.<span class="property">code</span> !== <span class="string">&#x27;EEXIST&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Could not set up log directory, error was: &#x27;</span>, err)</span><br><span class="line">        process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//根据log 配置文件(log4js.json)配置日志文件</span></span><br><span class="line">log4js.<span class="title function_">configure</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;log4js.json&#x27;</span>), &#123; <span class="attr">cwd</span>: logDir &#125;)</span><br><span class="line"><span class="comment">//注册日志： 日志名（前缀）startup</span></span><br><span class="line"><span class="keyword">const</span> logger = log4js.<span class="title function_">getLogger</span>(<span class="string">&#x27;startup&#x27;</span>)</span><br><span class="line"><span class="comment">//输入日志</span></span><br><span class="line">logger.<span class="title function_">info</span>(<span class="string">&#x27;logs config finished!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>5、 日志配置文件 (log4js.json) 编写 实际使用中以下注释全部删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;appenders&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;console&quot;</span>  <span class="comment">//控制台输出日志</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;clustered&quot;</span>,  <span class="comment">//支持多 appender 时添加， </span></span><br><span class="line">      <span class="string">&quot;appenders&quot;</span>: [</span><br><span class="line">         &#123;  <span class="comment">//在./logs目录生成 http.log文件</span></span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;dateFile&quot;</span>, <span class="comment">//datefile表示是输出按时间分文件的日志</span></span><br><span class="line">          <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;http.log&quot;</span>,  <span class="comment">//文件件名</span></span><br><span class="line">          <span class="string">&quot;pattern&quot;</span>: <span class="string">&quot;-yyyy-MM-dd&quot;</span>,  <span class="comment">//非当天日志命名格式，例如：http.log-2016-08-02</span></span><br><span class="line">          <span class="string">&quot;category&quot;</span>: <span class="string">&quot;http&quot;</span>  <span class="comment">//过滤所有日志名为 http 的日志</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;  <span class="comment">//记录所有日志</span></span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;file&quot;</span>,  <span class="comment">//file表示日志输出为普通文件,在此种配置下,所有日志会输出到该日志文件</span></span><br><span class="line">          <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;app.log&quot;</span>, <span class="comment">//日志文件名</span></span><br><span class="line">          <span class="string">&quot;maxLogSize&quot;</span>: <span class="number">10485760</span>,  <span class="comment">//设置日志文件的最大大小，文件体积超过时，自动分文件</span></span><br><span class="line">          <span class="string">&quot;pattern&quot;</span>: <span class="string">&quot;-yyyy-MM-dd&quot;</span>, <span class="comment">//</span></span><br><span class="line">          <span class="string">&quot;numBackups&quot;</span>: <span class="number">5</span>  <span class="comment">//备份的文件数量,如果文件过多则会将最旧的删除</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;logLevelFilter&quot;</span>, <span class="comment">//日志级别过滤</span></span><br><span class="line">          <span class="string">&quot;level&quot;</span>: <span class="string">&quot;ERROR&quot;</span>,  <span class="comment">//该日志文件只记录级别在error及以上的日志</span></span><br><span class="line">          <span class="string">&quot;appender&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;file&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;errors.log&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、 在koa web工程中应如 log4</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> nunjucksViews = <span class="built_in">require</span>(<span class="string">&#x27;koa-nunjucks-promise&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> mount = <span class="built_in">require</span>(<span class="string">&#x27;koa-mount&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;koa-session2&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">&#x27;koa-log4&#x27;</span>)</span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./log&#x27;</span>)  <span class="comment">//引入（运行）日志配置文件， 生产日志目录及相应文件</span></span><br><span class="line"><span class="keyword">const</span> logger = log4js.<span class="title function_">getLogger</span>(<span class="string">&#x27;app&#x27;</span>) <span class="comment">//将当前文件日志命名为 app </span></span><br><span class="line">logger.<span class="title function_">info</span>(<span class="string">&#x27;--------step into koa-------------&#x27;</span>)</span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="built_in">require</span>(<span class="string">&#x27;./store&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>()</span><br><span class="line"><span class="keyword">const</span> route = <span class="keyword">new</span> <span class="title function_">router</span>()</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">nunjucksViews</span>(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/views`</span>, &#123;  <span class="comment">//配置模板文件路径，</span></span><br><span class="line">    <span class="attr">ext</span>: <span class="string">&#x27;html&#x27;</span>,   <span class="comment">//渲染文件后缀为 html</span></span><br><span class="line">    <span class="attr">noCache</span>: <span class="literal">true</span>,  <span class="comment">//开发环境下不设置缓存</span></span><br><span class="line">    <span class="attr">watch</span>: <span class="literal">true</span>,  <span class="comment">//开发环境下观察模板文件的变化并更新</span></span><br><span class="line">    <span class="attr">filters</span>: &#123;  <span class="comment">//过滤器  </span></span><br><span class="line">        <span class="attr">json</span>: <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(str, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">globals</span>: &#123;  <span class="comment">//设置对于nunjucks的全局变量</span></span><br><span class="line">        <span class="comment">// staticPath: &#x27;//static&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">server</span>(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/public`</span>)))  <span class="comment">//设置静态文件路径</span></span><br><span class="line"><span class="comment">//------------- 记录所有http请求---------------</span></span><br><span class="line">app.<span class="title function_">use</span>(log4js.<span class="title function_">koaLogger</span>(log4js.<span class="title function_">getLogger</span>(<span class="string">&#x27;http&#x27;</span>), &#123; <span class="attr">level</span>: <span class="string">&#x27;auto&#x27;</span> &#125;))</span><br><span class="line"><span class="comment">//-------------------------------------------</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;sessionId&quot;</span>,   <span class="comment">//default &quot;koa:sess&quot;,</span></span><br><span class="line">    <span class="attr">store</span>: <span class="keyword">new</span> <span class="title function_">store</span>(),</span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">5000</span>  <span class="comment">//设置session超时时间</span></span><br><span class="line">&#125;))</span><br><span class="line">route.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, co.<span class="title function_">wrap</span>(<span class="keyword">function</span>* (ctx) &#123;</span><br><span class="line"> <span class="comment">//-------------------------------------------</span></span><br><span class="line">    logger.<span class="title function_">debug</span>(<span class="string">&#x27; this is test log&#x27;</span>)  <span class="comment">//打印日志，日志级别 debug</span></span><br><span class="line"><span class="comment">//-------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.<span class="property">session</span>.<span class="property">view</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        ctx.<span class="property">session</span>.<span class="property">view</span> = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">session</span>.<span class="property">view</span> += <span class="number">1</span>   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;viewNum&#x27;</span>, ctx.<span class="property">session</span>.<span class="property">view</span>)</span><br><span class="line">    <span class="keyword">yield</span> ctx.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123;<span class="attr">title</span>: <span class="string">&#x27;Nunjucks&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;Feifeiyu yeah!&#x27;</span>&#125;)</span><br><span class="line">&#125;))</span><br><span class="line">route.<span class="title function_">get</span>(<span class="string">&#x27;/route/test&#x27;</span>, co.<span class="title function_">wrap</span>(<span class="keyword">function</span>* (ctx) &#123;</span><br><span class="line">    logger.<span class="title function_">info</span>(<span class="string">&#x27; this is test log2&#x27;</span>)  <span class="comment">//打印日志，日志级别 info</span></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;feifeiyu nuaa&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line">app.<span class="title function_">use</span>(route.<span class="title function_">routes</span>())</span><br><span class="line">    .<span class="title function_">use</span>(route.<span class="title function_">allowedMethods</span>())</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started， port 3000&#x27;</span>))</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app</span><br></pre></td></tr></table></figure>

<p><img src="http://p04c6djlz.bkt.clouddn.com//17-11-29/24815294.jpg" alt="IMAGE"></p>
]]></content>
  </entry>
  <entry>
    <title>koa-router 结构图</title>
    <url>/2017/11/29/koa-router/</url>
    <content><![CDATA[<p><img src="http://p04c6djlz.bkt.clouddn.com//17-11-29/1829965.jpg" alt="1"></p>
]]></content>
  </entry>
  <entry>
    <title>leanCloud pointer include find</title>
    <url>/2017/11/29/leanCloud%20pointer%20include%20find/</url>
    <content><![CDATA[<h2 id="在leanCloud表中的pointer数据是一个指向外键的指针，数值上等于userid之类的主键"><a href="#在leanCloud表中的pointer数据是一个指向外键的指针，数值上等于userid之类的主键" class="headerlink" title="在leanCloud表中的pointer数据是一个指向外键的指针，数值上等于userid之类的主键"></a>在leanCloud表中的pointer数据是一个指向外键的指针，数值上等于userid之类的主键</h2><p>但是如果在query中加入query.include(‘user’);那么在query.find()以后得到的数据里，leanCloud会自动帮你把外键对应的数据记录也带过来，就像表链接一样</p>
<h2 id="在插入-Pointer-数据时需要插入的是-object-对象而不是-String"><a href="#在插入-Pointer-数据时需要插入的是-object-对象而不是-String" class="headerlink" title="在插入 Pointer 数据时需要插入的是 object 对象而不是 String,"></a>在插入 Pointer 数据时需要插入的是 object 对象而不是 String,</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="variable constant_">AV</span>.<span class="title function_">createWithoutData</span>(<span class="string">&#x27;tableName&#x27;</span>, objectId);</span><br><span class="line">anotherObj.<span class="title function_">set</span>(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">anotherObj.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>libuv 学习笔记</title>
    <url>/2021/06/15/libuv%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="libuv-是什么"><a href="#libuv-是什么" class="headerlink" title="libuv 是什么"></a>libuv 是什么</h1><p>libuv是一个高性能的，事件驱动的I&#x2F;O库，并且提供了跨平台（如windows, linux）的API。对 node.js 来说 libuv 提供了 event-loop,以及基于 I&#x2F;O和其他时间通知的回调函数.简单的说 node.js 之所以是天生的异步,就是因为 node.js 使用了 libuv 实现. </p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>macOS Sierra 安装MongoDB</title>
    <url>/2016/12/13/macOS%20Sierra%20%E5%AE%89%E8%A3%85MongoDB/</url>
    <content><![CDATA[<h2 id="使用brew安装"><a href="#使用brew安装" class="headerlink" title="使用brew安装"></a>使用brew安装</h2><blockquote>
<p>brew install mongodb<br>这个时候终端就会开始下载和安装mongodb</p>
</blockquote>
<span id="more"></span>
<h3 id="下载完以后-需要创建一个目录-为mongo默认的数据写入目录"><a href="#下载完以后-需要创建一个目录-为mongo默认的数据写入目录" class="headerlink" title="下载完以后,需要创建一个目录,为mongo默认的数据写入目录"></a>下载完以后,需要创建一个目录,为mongo默认的数据写入目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudomkdir -p /data/db</span><br></pre></td></tr></table></figure>
<h3 id="然后给该目录可读可写的权限"><a href="#然后给该目录可读可写的权限" class="headerlink" title="然后给该目录可读可写的权限"></a>然后给该目录可读可写的权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown `id -u` /data/db</span><br></pre></td></tr></table></figure>
<h3 id="这个时候可以修改目录-也可以不修改-修改的话是这样"><a href="#这个时候可以修改目录-也可以不修改-修改的话是这样" class="headerlink" title="这个时候可以修改目录,也可以不修改,修改的话是这样"></a>这个时候可以修改目录,也可以不修改,修改的话是这样</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /data/db 目录是mongo的默认目录，如果你想使用其他目录，可以使 --dbpath 参数</span><br><span class="line">mongo --dbpath dir_name</span><br><span class="line">// dir_name 为你的目录名字</span><br></pre></td></tr></table></figure>
<h3 id="这时候就可以mongod启动mongodb了"><a href="#这时候就可以mongod启动mongodb了" class="headerlink" title="这时候就可以mongod启动mongodb了"></a>这时候就可以<code>mongod</code>启动mongodb了</h3><h2 id="如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod-lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉："><a href="#如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod-lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉：" class="headerlink" title="如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod.lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉："></a>如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod.lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aef | grep mongo</span><br></pre></td></tr></table></figure>

<p>然后根据进程ID杀掉进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kill 6955</span><br></pre></td></tr></table></figure>

<p>重新启动mongodb服务，即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongod</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>mocha test</title>
    <url>/2017/11/27/mocha%20test/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html">阮一峰博客</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">定义 test</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; createToken &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../lib/jwt&#x27;</span>) <span class="comment">//请求 token</span></span><br><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>)      </span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;../app&#x27;</span>)   <span class="comment">// 这里引用的是 app.listen() 输出的对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">AV</span> = <span class="built_in">require</span>(<span class="string">&#x27;leancloud-storage&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../lib/config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;test audioChannel&#x27;</span>, <span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> api;</span><br><span class="line">  <span class="keyword">let</span> token;</span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">    api = <span class="title function_">request</span>(server)</span><br><span class="line">    token = <span class="keyword">await</span> <span class="title function_">createToken</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>()</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">&#x27;koa-views&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">require</span>(<span class="string">&#x27;koa-json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> onerror = <span class="built_in">require</span>(<span class="string">&#x27;koa-onerror&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">&#x27;koa-log4&#x27;</span>)  <span class="comment">//koa 日志包</span></span><br><span class="line"><span class="keyword">const</span> logger = log4js.<span class="title function_">getLogger</span>(<span class="string">&#x27;app&#x27;</span>)  <span class="comment">//这里的 APP 是什么意思</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.<span class="title function_">listen</span>(<span class="number">9999</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[demo] request post is starting at port 9999&#x27;</span>)</span><br><span class="line">&#125;)        <span class="comment">//这里需要输出 app.listen() 的返回值</span></span><br><span class="line">          <span class="comment">//mocha 需要这引用这个</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = server</span><br></pre></td></tr></table></figure>

<p>输出测试结果到网页:<br>npm install –save-dev mochawesome<br>mocha testfile.js –reporter mochawesome</p>
<ul>
<li>–growl, -G<br>打开–growl参数，就会将测试结果在桌面显示。</li>
<li>–watch，-w</li>
</ul>
<p>–watch参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。</p>
<ul>
<li>–bail, -b</li>
</ul>
<p>–bail参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。</p>
<ul>
<li>–grep, -g</li>
</ul>
<p>–grep参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。</p>
<ul>
<li>–invert, -i</li>
</ul>
<p>–invert参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。</p>
]]></content>
      <categories>
        <category>unit test</category>
      </categories>
  </entry>
  <entry>
    <title>mongoDB 索引建立</title>
    <url>/2019/10/15/mongo%20%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>众所周知,数据库建立索引后速度会有极大的提升.但前提是正确的建立索引,否则数据库查询就不会走索引,而导致慢查询,不仅影响当前服务的性能,甚至可能影响其他使用同一数据库的服务的性能.</p>
<p>而索引分为独立索引和组合索引.</p>
<h1 id="独立索引-Single-field-index"><a href="#独立索引-Single-field-index" class="headerlink" title="独立索引(Single field index)"></a>独立索引(Single field index)</h1><p>对单独字段建立索引,例如:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>1 表示升序索引,-1 表示降序索引</p>
<p>查询条件为单一条件时有效,当查询条件为多个条件组合时,不会一一匹配独立索引</p>
<h2 id="独立索引的-sort-排序"><a href="#独立索引的-sort-排序" class="headerlink" title="独立索引的 sort 排序"></a>独立索引的 sort 排序</h2><p>对于独立索引来说，由于 MongoDB index 本身支持顺序查找，所以对于独立索引来说不管你是<code>&#123; sort: 1&#125; </code>还是<code>&#123; sort: -1 &#125;</code>都是一样的</p>
<h1 id="组合索引-Compound-index"><a href="#组合索引-Compound-index" class="headerlink" title="组合索引(Compound index)"></a>组合索引(Compound index)</h1><p>当查询条件为多个条件组合时,需要建立组合索引,例如:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;distributorNo&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payEnv&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;orderStatus&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createdAt&quot;</span><span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>组合索引中条件的顺序对索引的性能有至关重要的影响，比如索引 {userid:1, score:-1} 首先根据 userid 排序，然后再在每个 userid 中根据 score 排序。</p>
<h2 id="使用组合索引需要满足-prefix-原则"><a href="#使用组合索引需要满足-prefix-原则" class="headerlink" title="使用组合索引需要满足 prefix 原则"></a>使用组合索引需要满足 prefix 原则</h2><p>Index prefix 是指组合索引字段的左前缀子集，考虑以下索引：</p>
<span id="more"></span>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>复制代码这个索引包含以下 index prefix：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> item<span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> item<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> location<span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>复制代码所以只要语句满足 index prefix 原则都是可以支持使用组合索引的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.<span class="property">products</span>.<span class="title function_">find</span>( &#123; <span class="attr">item</span>: <span class="string">&quot;Banana&quot;</span> &#125; )</span><br><span class="line">db.<span class="property">products</span>.<span class="title function_">find</span>( &#123; <span class="attr">item</span>: <span class="string">&quot;Banana&quot;</span>,<span class="attr">location</span>:<span class="string">&quot;4th Street Store&quot;</span>&#125; )</span><br><span class="line">db.<span class="property">products</span>.<span class="title function_">find</span>( &#123; <span class="attr">item</span>: <span class="string">&quot;Banana&quot;</span>,<span class="attr">location</span>:<span class="string">&quot;4th Street Store&quot;</span>,<span class="attr">stock</span>:<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>复制代码相反如果不满足 index prefix 则无法使用索引，比如以下 field 的查询：</p>
<p><code>&#123; location: 1 &#125;</code><br><code>&#123; stock: 1 &#125;</code><br><code>&#123; location: 1, stock: 1 &#125;</code></p>
<p>由于 index prefix 的存在，如果一个 collection 既有 {a:1, b:1} 索引 ，也有 {a:1} 索引，如果二者没有稀疏或者唯一性的要求，独立索引是可以移除的。</p>
<blockquote>
<p>所以建立组合索引时需要把出现概率较高的条件放在前面,或者为一个查询建立多个组合索引.</p>
</blockquote>
<h2 id="组合索引的-sort-排序"><a href="#组合索引的-sort-排序" class="headerlink" title="组合索引的 sort 排序"></a>组合索引的 sort 排序</h2><p>前文说过独立索引的 sort 顺序无关紧要，但是组合索引则完全不同。<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20191016163906.png"></p>
<p>sort 条件必须要和索引完全相同或者完全相反才会走索引,否则不走索引.<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20191016164435.png"></p>
<h2 id="理解-field-顺序对索引的影响"><a href="#理解-field-顺序对索引的影响" class="headerlink" title="理解 field 顺序对索引的影响"></a>理解 field 顺序对索引的影响</h2><p>索引的真正作用是帮助我们限制数据的选择范围,field 数值不同的比较少的放在前面,能更好的缩小范围,比如渠道编号distributriNo,一共只有几十种不同的数值,放在最前面,一开始的时候就已经把范围缩小到这个渠道编号下的数据,然后再根据支付环境,支付类型,订单状态等条件,不断的缩小范围.<br>相反的,如果把 _id作为索引,那从一开始就要遍历整个表,对缩小搜索范围就没有什么帮助了.<br>所以,唯一索引要放在组合索引中最后的位置.</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20191016163342.png"></p>
<p>在以上的索引中,r1 就是把范围缩小到 origin后就去查询 id 了,相当于 12959 条<code>start_time:1, end_time:1</code>都符合条件的,但是 r2 就是把范围再缩小到<code>start_time:1, end_time: 1, origin: 1, orientation: 1</code>,剩下符合条件的数据就剩 2700 多条了,明显范围更小了</p>
<blockquote>
<p>刚刚说的建立组合索引需要把出现概率较高的条件放在前面,但是还要考虑这个条件在数据库中数值的种类有多少种,如果有很多种数值的话,就要另外考虑是不是要再单独建立索引</p>
</blockquote>
<h2 id="非-index-prefix-的排序"><a href="#非-index-prefix-的排序" class="headerlink" title="非 index prefix 的排序"></a>非 index prefix 的排序</h2><p>考虑索引 { a: 1, b: 1, c: 1, d: 1 }，即使排序的 field 不满足 index prefix 也是可以的，但前提条件是排序 field 之前的 index field 必须是等值条件，</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20191016165828.png"><br>上面表格 r1 的排序 field 是 b 和 c，a 是 index field 而且在 b 和 c 之前，可以使用索引；r3 的排序中 b 是范围查询，但是 b 之前的 a 用的也是等值条件，也就是只要排序 field 之前的 field 满足等值条件即可，其它的 field 可以任意条件。<br>也就是说如果<code>db.data.find( &#123; a: &#123; $lt: 3&#125; &#125; ).sort( &#123; b: 1 &#125; )</code>这个时候 b 前面的 a 不满足等值条件,就不会走索引了</p>
<h1 id="模糊匹配时如何走索引"><a href="#模糊匹配时如何走索引" class="headerlink" title="模糊匹配时如何走索引"></a>模糊匹配时如何走索引</h1><p>mongoDB 模糊查询关键字 <code>$regex</code> 如果不走索引对性能的影响非常大.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">where[key] = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;^&#x27;</span> + where.<span class="property">regex</span>[key]);</span><br></pre></td></tr></table></figure>
<p>在需要模糊匹配的字符串前面加上 ‘^’后这个模糊查询就可以走索引了,速度会快非常多.</p>
<p>参考资料: <a href="https://juejin.im/post/5ad1d2836fb9a028dd4eaae6#heading-7">掘金-wecatch</a></p>
<h1 id="TTL-索引"><a href="#TTL-索引" class="headerlink" title="TTL 索引"></a>TTL 索引</h1><blockquote>
<p>某些数据需要定期删除，或者说过期删除，在MongoDB就要用到TTL索引。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex(&#123;createdAt:1&#125;,&#123;expireAfterSeconds:60*60*24*30*3&#125;) // 90天后自动删除</span><br></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>MongoDB服务器每分钟检查一次TTL索引，有TTL索引的字段服务器会进行计算：当前服务器时间-字段时间&gt;&#x3D;expreAfterSeconds的秒数的时候，就会执行删除该数据。所以如果是对数据做过期删除操作,建议把索引建立在 createdAt 这样的字段上.</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>TTL索引一样可以提高查询速度。</li>
<li>TTL索引只能用于单字段，不能创建复合索引。</li>
</ul>
<h2 id="修改-TTL-过期时间"><a href="#修改-TTL-过期时间" class="headerlink" title="修改 TTL 过期时间"></a>修改 TTL 过期时间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.runCommand(&#123; </span><br><span class="line">    collMod: &quot;log_events&quot;,     ---集合名</span><br><span class="line">    index: &#123; </span><br><span class="line">        keyPattern: &#123; createdAt: 1 &#125;,     ---createdAt为具有TTL索引的字段名</span><br><span class="line">        expireAfterSeconds: 60*60*24*30 ---修改后的过期时间(秒)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB $or操作索引优化</title>
    <url>/2020/12/08/mongoDB%20$or%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现有索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; distributorNo: 1, username: 1 &#125;</span><br><span class="line">&#123; newAppleUserId: 1, distributorNo: 1 &#125;</span><br></pre></td></tr></table></figure>

<p>现在有个查询</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.<span class="property">user</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">    distributorNo, </span><br><span class="line">    <span class="attr">$or</span>: [&#123; </span><br><span class="line">        <span class="attr">username</span>: appleUserId</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">newAppleUserId</span>: appleUserId</span><br><span class="line">    &#125;] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>请问这个查询会走哪个索引?</p>
<span id="more"></span>

<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在网上查询资料后发现$or的查询需要每条查询语句都有索引,其实就是MongoDB把每条查询语句都执行了一遍,再将结果合并.</p>
<p>现在用户表有数据3000w+,发现这个查询每次都超时(设置了最长查询时间6秒),所以判断这条查询语句没有走索引,但是按原来的逻辑,<code>&#123; distributorNo: 1, username: 1 &#125;&#123; newAppleUserId: 1, distributorNo: 1 &#125;</code>的索引都有啊.</p>
<p>准备使用.explain(),查看这条查询语句到底是怎么执行的,但是正式数据库数量太多,执行也超时了,就改在本地测试,结果如下<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20201208164438.png"></p>
<p>原来MongoDB是先查询了distributorNo,后再进行{distributorNo,username}的查询,在第一步的时候就超时了,因为满足distributorNo条件的数据量占了绝大多数.</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>将查询语句改写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.<span class="property">user</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">    <span class="attr">$or</span>: [&#123;</span><br><span class="line">        distributorNo,</span><br><span class="line">        <span class="attr">username</span>: appleUserId</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        distributorNo,</span><br><span class="line">        <span class="attr">newAppleUserId</span>: appleUserId</span><br><span class="line">    &#125;] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也就是不管执行的查询语句是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.<span class="property">user</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        distributorNo,</span><br><span class="line">        <span class="attr">username</span>: appleUserId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>还是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.<span class="property">user</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        distributorNo,</span><br><span class="line">        <span class="attr">newAppleUserId</span>: appleUserId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>都有对应的索引.<br>部署以后观察,慢查询与超时都消失了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MongoDB 的<code>$or</code>查询其实就是将每种情况都执行了一次<br>如果<code>$or</code>条件之前还有其他条件,MongoDB会先用该条件查询,后再执行<code>$or</code>里的每一条查询<br>所以要么将前置条件合并到<code>$or</code>语句里,要么对前置条件单独建索引</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>mongoDB 查询操作符表</title>
    <url>/2019/12/27/mongoDB%20%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="mongoDB-find"><a href="#mongoDB-find" class="headerlink" title="mongoDB find"></a>mongoDB find</h1><h2 id="比较符"><a href="#比较符" class="headerlink" title="比较符"></a>比较符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>操作含义</th>
<th align="right">备注</th>
</tr>
</thead>
<tbody><tr>
<td>$lt</td>
<td>小于 &lt;</td>
<td align="right"></td>
</tr>
<tr>
<td>$lte</td>
<td>小于等于  &lt;&#x3D;</td>
<td align="right"></td>
</tr>
<tr>
<td>$gt</td>
<td>大于 &gt;</td>
<td align="right"></td>
</tr>
<tr>
<td>$gte</td>
<td>大于等于 &gt;&#x3D;</td>
<td align="right"></td>
</tr>
<tr>
<td>$ne</td>
<td>不等于 !&#x3D;</td>
<td align="right"></td>
</tr>
<tr>
<td>$in</td>
<td>在范围内 include</td>
<td align="right">{age: {$in: [18,20]}} 注意是数组</td>
</tr>
<tr>
<td>$nin</td>
<td>不在范围内 !include</td>
<td align="right">参考$in</td>
</tr>
<tr>
<td>$all</td>
<td>完全匹配</td>
<td align="right">{ tags: { $all: [tagId] } } 后面接数组</td>
</tr>
<tr>
<td>$regex</td>
<td>正则匹配</td>
<td align="right">find({‘name’: {$regex: ‘^M.*}) 以 M 开头的名字</td>
</tr>
<tr>
<td>$exists</td>
<td>是否存在</td>
<td align="right">{name:{$exists:true}} 查找 name 存在的 doc</td>
</tr>
<tr>
<td>$type</td>
<td>类型判断</td>
<td align="right">{age: {$type: Number}}</td>
</tr>
<tr>
<td>$text</td>
<td>文本查询</td>
<td align="right">{<code>$text</code>: {‘$search’: ‘Mike’}}     text类型的属性中包含Mike字符串</td>
</tr>
<tr>
<td>$or</td>
<td>或操作</td>
<td align="right">{$or:[{‘name’:’chen’},{‘name’:’wang’}]} or 后面接数组</td>
</tr>
<tr>
<td>$and</td>
<td>与操作</td>
<td align="right">{$and:[{‘name’:’chen’},{‘name’:’wang’}]} and 后面接数组</td>
</tr>
</tbody></table>
<h2 id="in-和-all-的区别"><a href="#in-和-all-的区别" class="headerlink" title="$in 和 $all 的区别:"></a><code>$in</code> 和 <code>$all</code> 的区别:</h2><p><code>$in</code>和<code>$all</code>后面都是接数组,但是指向的范围不同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询topic.tags.includes(copyTagId)的模板,$all 是完全匹配</span></span><br><span class="line"><span class="comment">// 也就是说 topic.tags&gt;= $all 后面的数组</span></span><br><span class="line"><span class="keyword">const</span>  topicList  =  <span class="keyword">await</span> ctx.<span class="property">model</span>.<span class="property">Topic</span>.<span class="title function_">find</span>(&#123; <span class="attr">tags</span>: &#123; <span class="attr">$all</span>: [copyTagId] &#125; &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;].includes(topic.name)的模板</span></span><br><span class="line"><span class="comment">// 也就是数据库中的数据等`$in` 后面数组中任何之一都可以,有点像$or</span></span><br><span class="line"><span class="keyword">const</span>  topicList  =  <span class="keyword">await</span> ctx.<span class="property">model</span>.<span class="property">Topic</span>.<span class="title function_">find</span>(&#123; <span class="attr">name</span>: &#123; <span class="attr">$in</span>: [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>] &#125; &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>mongoose 笔记</title>
    <url>/2021/11/24/mongoose/</url>
    <content><![CDATA[<h1 id="mongoose-exec-方法"><a href="#mongoose-exec-方法" class="headerlink" title="mongoose exec 方法"></a>mongoose exec 方法</h1><p>因为我使用 mongoose 的 Query 方法一直都没有加 exec() 方法,但是使用 nestjs 生成的 service 文件里的查询方法,尾巴会带上一个 exec()方法,所以我查了一下文档,了解这个 exec()方法加与不加有什么区别.</p>
<h2 id="正常的-Query-方法"><a href="#正常的-Query-方法" class="headerlink" title="正常的 Query 方法"></a>正常的 Query 方法</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20211124144714.png"></p>
<span id="more"></span>

<p>返回的是一个 <Query> 对象,是一个带查询接口的,mongoose 封装过的对象.</p>
<p>这个<Query> 对象肯定也带有 exec()方法.</p>
<h2 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec() 方法"></a>exec() 方法</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20211124144925.png"></p>
<p>exec 方法返回的是一个 Promise 对象,所以在 await 后面,js 会自动拿到 Promise 的 resolve 结果.</p>
<h2 id="但是为什么我之前不加exec-最后都能拿到查询数值呢"><a href="#但是为什么我之前不加exec-最后都能拿到查询数值呢" class="headerlink" title="但是为什么我之前不加exec(),最后都能拿到查询数值呢?"></a>但是为什么我之前不加exec(),最后都能拿到查询数值呢?</h2><p>await 会将后面接的 Promise 或者 thenable 对象取.then().resolve()的结果.<br>而这个 Query 对象就是一个 thenable 对象.<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20211124145242.png"></p>
<p>如果开发者没有对对象进行下一步操作,await 会去执行.then 方法,再拿到最后的 resolve 数值.</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>.exec()方法有点像是申明这条查询语句到此结束,开始执行了.<br>而没有加的情况,最后也会执行.then 方法,本质上没有太大的区别,从代码可读性和严谨性方面,加上 exec() 会更好一些</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx使用</title>
    <url>/2017/11/29/nginx/</url>
    <content><![CDATA[<h3 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h3><p><code>cd /usr/local/nginx/sbin</code></p>
<p><code>./nginx</code></p>
<h3 id="二、重启"><a href="#二、重启" class="headerlink" title="二、重启"></a>二、重启</h3><span id="more"></span>
<p>更改配置重启nginx</p>
<p>kill -HUP 主进程号或进程号文件路径<br>或者<br><code>cd /usr/local/nginx/sbin</code></p>
<p><code>./nginx -s reload</code></p>
<p>判断配置文件是否正确</p>
<p><code>./nginx -t -c /usr/local/nginx/conf/nginx.conf</code><br>或者</p>
<p><code>cd  /usr/local/nginx/sbin</code><br><code>./nginx -t</code></p>
<h3 id="三、关闭"><a href="#三、关闭" class="headerlink" title="三、关闭"></a>三、关闭</h3><p>查询nginx主进程号</p>
<p><code>ps -ef | grep nginx</code></p>
<p>从容停止   kill -QUIT 主进程号</p>
<p>快速停止   kill -TERM 主进程号</p>
<p>强制停止   kill -9 nginx</p>
<p>若nginx.conf配置了pid文件路径，如果没有，则在logs目录下</p>
<p>kill -信号类型 ‘&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid’</p>
<h3 id="四、升级"><a href="#四、升级" class="headerlink" title="四、升级"></a>四、升级</h3><p>1、先用新程序替换旧程序文件</p>
<p>2、kill -USR2 旧版程序的主进程号或者进程文件名</p>
<p>此时旧的nginx主进程会把自己的进程文件改名为.oldbin，然后执行新版nginx，此时新旧版本同时运行</p>
<p>3、kill -WINCH 旧版本主进程号</p>
<p>4、不重载配置启动新&#x2F;旧工作进程</p>
<p>kill -HUP 旧&#x2F;新版本主进程号</p>
<p>从容关闭旧&#x2F;新进程</p>
<p>kill -QUIT 旧&#x2F;新进程号</p>
<p>快速关闭旧&#x2F;新进程</p>
<p>kill -TERM 旧&#x2F;新进程号</p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>node.js 流API</title>
    <url>/2020/02/27/node.js%20%E6%B5%81/</url>
    <content><![CDATA[<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="流的基本类型"><a href="#流的基本类型" class="headerlink" title="流的基本类型"></a>流的基本类型</h2><p>Node.js，Stream 有四种流类型：</p>
<ul>
<li><p>Readable - 可读操作。</p>
</li>
<li><p>Writable - 可写操作。</p>
</li>
<li><p>Duplex - 可读可写操作.</p>
</li>
<li><p>Transform - 操作被写入数据，然后读出结果。</p>
</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。</p>
<h2 id="常用的事件有："><a href="#常用的事件有：" class="headerlink" title="常用的事件有："></a>常用的事件有：</h2><ul>
<li><p>data - 当有数据可读时触发。</p>
</li>
<li><p>end - 没有更多的数据可读时触发。</p>
</li>
<li><p>error - 在接收和写入过程中发生错误时触发。</p>
</li>
<li><p>finish - 所有数据已被写入到底层系统时触发。</p>
</li>
</ul>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> readerStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;input.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置编码为 utf8。</span></span><br><span class="line">readerStream.<span class="title function_">setEncoding</span>(<span class="string">&#x27;UTF8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></span><br><span class="line">readerStream.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span></span><br><span class="line"><span class="keyword">const</span> writerStream = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 utf8 编码写入数据</span></span><br><span class="line">writerStream.<span class="title function_">write</span>(data,<span class="string">&#x27;UTF8&#x27;</span>);</span><br><span class="line"><span class="comment">// 标记文件末尾</span></span><br><span class="line">writerStream.<span class="title function_">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></span><br><span class="line">writerStream.<span class="title function_">on</span>(<span class="string">&#x27;finish&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入完成。&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">writerStream.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">stack</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">stack</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;程序执行完毕&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上程序还有一种更加简便的写法:</p>
<h2 id="使用管道流"><a href="#使用管道流" class="headerlink" title="使用管道流"></a>使用管道流</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">const</span> readerStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;input.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">const</span> writerStream = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道读写操作</span></span><br><span class="line"><span class="comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span></span><br><span class="line">readerStream.<span class="title function_">pipe</span>(writerStream);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;程序执行完毕&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要同时将流要输出到多个地方,可以使用</p>
<h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先将 input.txt 的数据流进行zlib.createGzip()操作再到fs.createWriteStream()创建文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 input.txt 文件为 input.txt.gz</span></span><br><span class="line">fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;input.txt&#x27;</span>)</span><br><span class="line">  .<span class="title function_">pipe</span>(zlib.<span class="title function_">createGzip</span>())</span><br><span class="line">  .<span class="title function_">pipe</span>(fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;input.txt.gz&#x27;</span>));</span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件压缩完成。&quot;</span>);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs 网络错误信息</title>
    <url>/2019/07/26/node.js%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>Node.js 底层使用的是 glibc 库，这些错误信息都是 glibc 库在 socket 连接时使用的 connect 函数中定义的错误类型，当然，v8在使用glibc库时也会加入一些自定义的错误类型，但许多错误情况还是和glibc中的定义一致的。</p>
<p>connect 函数的定义为：int connect (int socket, struct sockaddr addr, socklen_t length)</p>
<p>connect 函数会使用文件描述符（file descriptor）socket表示的 socket 发起连接，socket 地址通过 addr 和 length 这两个参数来指定。（这个 socket 一般是其他机器的 socket，而且必须已经配置成了服务器）。</p>
<p>一般情况下，connect 函数会等待服务器响应请求才返回。当然也可以将 socket 设置为非阻塞模式来不等待响应就快速返回（可以参考下 nginx 是怎么使用 socket 的）。</p>
<h1 id="2-错误类型"><a href="#2-错误类型" class="headerlink" title="2.错误类型"></a>2.错误类型</h1><blockquote>
<p>connect 函数正常的返回值为 0，在有错误时会返回 -1。函数中定义了如下错误条件：</p>
</blockquote>
<ul>
<li>EBADF：socket 不是有效的文件描述符（file descriptor）。</li>
</ul>
<span id="more"></span>

<ul>
<li><p>ENOTSOCK：文件描述符 socket 不是 socket 。</p>
</li>
<li><p>EADDRNOTAVAIL：指定的地址在远程机器上不可用。</p>
</li>
<li><p>EAFNOSUPPORT：socket 不支持 addr 的命名空间。</p>
</li>
<li><p>EISCONN：socket 已经连接。</p>
</li>
<li><p>ETIMEDOUT：连接尝试超时。</p>
</li>
<li><p>ECONNREFUSED：服务器主动拒绝建立连接。</p>
</li>
<li><p>ENETUNREACH：从本机到给定 addr 的网络不通。</p>
</li>
<li><p>EADDRINUSE：给定 addr 的 socket 地址已经在使用。（这种错误最常见，我们有时候本地已经启动了一个 Node.js 程序，再次启动会看到这个错误，也就是端口号已经被占用了）</p>
</li>
<li><p>EINPROGRESS：socket 是非阻塞的，连接不能立即建立。可以使用 select 来确定连接完全建立的时间。参考等待I&#x2F;O。在连接完全建立前如果在相同的 socket 上调用 connect，会以 EALREADY 失败。</p>
</li>
<li><p>EALREADY：socket 是非阻塞的而且有一个挂起的连接（参考上面的 EINPROGRESS）。</p>
</li>
</ul>
<h1 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h1><p>connect 是作为多线程程序的取消点定义的，开发者需要确保线程取消后释放了占用的资源（例如内存、文件描述符、semaphore)等）。</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>node.js路径</title>
    <url>/2017/11/29/node.js%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<ul>
<li>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</li>
<li>__filename: 总是返回被执行的 js 的绝对路径</li>
<li>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</li>
<li>.&#x2F;: 在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。</li>
</ul>
<blockquote>
<p>PORT&#x3D;4000 node index.js  –设置环境</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>获取客户端 IP地址</title>
    <url>/2018/06/21/node%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%20IP%20%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="获取客户端-IP地址"><a href="#获取客户端-IP地址" class="headerlink" title="获取客户端 IP地址"></a>获取客户端 IP地址</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getClientIp</span>(<span class="params">req</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="property">headers</span>[<span class="string">&#x27;x-forwarded-for&#x27;</span>] ||</span><br><span class="line">        req.<span class="property">connection</span>.<span class="property">remoteAddress</span> ||</span><br><span class="line">        req.<span class="property">socket</span>.<span class="property">remoteAddress</span> ||</span><br><span class="line">        req.<span class="property">connection</span>.<span class="property">socket</span>.<span class="property">remoteAddress</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>代码第一段判断是否有反向代理IP(头信息：x-forwarded-for)，在判断connection的远程IP，以及后端的socket的IP。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>PM2学习-2018-06-01</title>
    <url>/2018/06/01/pm2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="pm2学习笔记"><a href="#pm2学习笔记" class="headerlink" title="pm2学习笔记"></a>pm2学习笔记</h1><h2 id="pm2-有一个很好看的-web-管理应用"><a href="#pm2-有一个很好看的-web-管理应用" class="headerlink" title="pm2 有一个很好看的 web 管理应用"></a>pm2 有一个很好看的 web 管理应用</h2><p><a href="https://app.keymetrics.io/">keymetrics</a><br>安装了 pm2以后，到这个网站上注册账号，并用他给的 <code>pm2 link xxx xxxx</code>就把当前电脑的pm2管理的进程情况输出到这个网站上了<br><img src="http://p04c6djlz.bkt.clouddn.com//1527824401376.jpg"></p>
<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><p><code>npm install pm2 -g</code> ： 全局安装。 <code>--watch 是监控项目的所有文件,一旦有改变就重启服务器,像nodemon 一样</code></p>
<span id="more"></span>
<p><code>pm2 start app.js</code> ： 启动服务，入口文件是app.js。<br><code>pm2 start app.js -i [n] --name [name]</code> ： 启动n个进程，名字命名为name。<br><code>pm2 start app.js -i max</code> 使用负载均衡的模式启动程序, <strong>cluster mode 模式,max 是指服务器有多少个 CPU 就启动多少个应用实例,进行负载均衡,尽最大程度使用 CPU</strong><br><code>pm2 serve path port</code>  运行一个静态文件目录,<strong>路径应该是一个文件夹,而不是文件,然后在 <code>localhost:port/文件</code>访问</strong><br><code>npm restart [name or id]</code> ： 重启服务。<br><code>npm reload [name or id]</code> ： 和rastart功能相同，但是可以实现0s的无缝衔接；如果有nginx的使用经验，可以对比nginx reload指令。<br><code>pm2 start app.js --max_memory_restart 1024M</code> ： 当内存超过1024M时自动重启。 如果工程中有比较棘手的内存泄露问题，这个算是一个折中方案。<br><code>pm2 monit</code> ： 对服务进行监控。</p>
<p>更多的指令可以参考 <a href="https://www.douban.com/note/314200231/">PM2 介绍</a></p>
<h2 id="高级用法-ecosystem"><a href="#高级用法-ecosystem" class="headerlink" title="高级用法 ecosystem"></a>高级用法 ecosystem</h2><p>pm2支持配置文件启动：<br><code>pm2 ecosystem</code>： 生成配置文件<code>ecosystem.json</code><br><code>pm2 startOrRestart /file/path/ecosystem.json</code> : 通过配置文件启动服务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Application configuration section</span></span><br><span class="line"><span class="comment">   * http://pm2.keymetrics.io/docs/usage/application-declaration/</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  apps : [</span><br><span class="line">    <span class="comment">// First application</span></span><br><span class="line">    &#123;</span><br><span class="line">      name      : <span class="string">&#x27;mongoDB&#x27;</span>,</span><br><span class="line">      script    : <span class="string">&#x27;mongod&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Second application</span></span><br><span class="line">    &#123;</span><br><span class="line">      name      : <span class="string">&#x27;iot_api&#x27;</span>,</span><br><span class="line">      script    : <span class="string">&#x27;./seeed_IOT/seeed_iot_api/bin/www&#x27;</span>,</span><br><span class="line">      <span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="attr">NODE_ENV</span>: <span class="string">&#x27;release&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      env_production : &#123;</span><br><span class="line">        <span class="attr">NODE_ENV</span>: <span class="string">&#x27;release&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="attr">name</span>: <span class="string">&#x27;message server&#x27;</span>,</span><br><span class="line">    	<span class="attr">script</span>: <span class="string">&#x27;./seeed_IOT/seeed_message_server/bin/www&#x27;</span>,</span><br><span class="line">    	<span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;NODE_ENV&#x27;</span>: <span class="string">&#x27;release&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      env_production : &#123;</span><br><span class="line">        <span class="attr">NODE_ENV</span>: <span class="string">&#x27;release&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Deployment section</span></span><br><span class="line"><span class="comment">   * http://pm2.keymetrics.io/docs/usage/deployment/</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  deploy : &#123;</span><br><span class="line">    <span class="comment">// production : &#123;</span></span><br><span class="line">    <span class="comment">//   user : &#x27;node&#x27;,  // 登录远程服务器的用户名，此处填写我们创建的hwl</span></span><br><span class="line">    <span class="comment">//   host : &#x27;212.83.163.1&#x27;, // 服务器 IP</span></span><br><span class="line">    <span class="comment">//   ref  : &#x27;origin/master&#x27;, // git 地址及分支</span></span><br><span class="line">    <span class="comment">//   repo : &#x27;git@github.com:repo.git&#x27;, // git 仓库地址</span></span><br><span class="line">    <span class="comment">//   path : &#x27;/var/www/production&#x27;, // 服务器路径</span></span><br><span class="line">    <span class="comment">//   &#x27;post-deploy&#x27; : &#x27;npm install &amp;&amp; pm2 reload ecosystem.config.js --env production&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// dev : &#123;</span></span><br><span class="line">    <span class="comment">//   user : &#x27;node&#x27;,</span></span><br><span class="line">    <span class="comment">//   host : &#x27;212.83.163.1&#x27;,</span></span><br><span class="line">    <span class="comment">//   ref  : &#x27;origin/master&#x27;,</span></span><br><span class="line">    <span class="comment">//   repo : &#x27;git@github.com:repo.git&#x27;,</span></span><br><span class="line">    <span class="comment">//   path : &#x27;/var/www/development&#x27;,</span></span><br><span class="line">    <span class="comment">//   &#x27;post-deploy&#x27; : &#x27;npm install &amp;&amp; pm2 reload ecosystem.config.js --env dev&#x27;,</span></span><br><span class="line">    <span class="comment">//   env  : &#123;</span></span><br><span class="line">    <span class="comment">//     NODE_ENV: &#x27;dev&#x27;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置项:</p>
<ol>
<li>name  应用进程名称；</li>
<li>script  启动脚本路径；</li>
<li>cwd  应用启动的路径，关于script与cwd的区别举例说明：在&#x2F;home&#x2F;polo&#x2F;目录下运行&#x2F;data&#x2F;release&#x2F;node&#x2F;index.js，此处script为&#x2F;data&#x2F;release&#x2F;node&#x2F;index.js，cwd为&#x2F;home&#x2F;polo&#x2F;；</li>
<li>args  传递给脚本的参数；</li>
<li>interpreter  指定的脚本解释器；</li>
<li>interpreter_args  传递给解释器的参数；</li>
<li>instances  应用启动实例个数，仅在cluster模式有效，默认为fork；</li>
<li>exec_mode  应用启动模式，支持fork和cluster模式；</li>
<li>watch  监听重启，启用情况下，文件夹或子文件夹下变化应用自动重启；</li>
<li>ignore_watch  忽略监听的文件夹，支持正则表达式；</li>
<li>max_memory_restart  最大内存限制数，超出自动重启；</li>
<li>env  环境变量，object类型，如{“NODE_ENV”:”production”, “ID”: “42”}；</li>
<li>log_date_format  指定日志日期格式，如YYYY-MM-DD HH:mm:ss；</li>
<li>error_file  记录标准错误流，$HOME&#x2F;.pm2&#x2F;logs&#x2F;XXXerr.log)，代码错误可在此文件查找；</li>
<li>out_file  记录标准输出流，$HOME&#x2F;.pm2&#x2F;logs&#x2F;XXXout.log)，如应用打印大量的标准输出，会导致pm2日志过大；</li>
<li>min_uptime  应用运行少于时间被认为是异常启动；</li>
<li>max_restarts  最大异常重启次数，即小于min_uptime运行时间重启次数；</li>
<li>autorestart  默认为true, 发生异常的情况下自动重启；</li>
<li>cron_restart  crontab时间格式重启应用，目前只支持cluster模式；</li>
<li>force  默认false，如果true，可以重复启动一个脚本。pm2不建议这么做；</li>
<li>restart_delay  异常重启情况下，延时重启时间；</li>
</ol>
<h2 id="本地pm2的ecosystem配置"><a href="#本地pm2的ecosystem配置" class="headerlink" title="本地pm2的ecosystem配置"></a>本地pm2的ecosystem配置</h2><p>在本地的目标应用下，输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 ecosystem</span><br></pre></td></tr></table></figure>

<p>生成pm2的部署配置模板文件如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  /**</span><br><span class="line">   * Application configuration section</span><br><span class="line">   * PM2 - Application Declaration</span><br><span class="line">   */</span><br><span class="line">  apps : [</span><br><span class="line">    // First application</span><br><span class="line">    &#123;</span><br><span class="line">      name      : &quot;API&quot;,</span><br><span class="line">      script    : &quot;app.js&quot;,</span><br><span class="line">      env: &#123;</span><br><span class="line">        COMMON_VARIABLE: &quot;true&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      env_production : &#123;</span><br><span class="line">        NODE_ENV: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // Second application</span><br><span class="line">    &#123;</span><br><span class="line">      name      : &quot;WEB&quot;,</span><br><span class="line">      script    : &quot;web.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  /**</span><br><span class="line">   * Deployment section</span><br><span class="line">   * PM2 - Deployment</span><br><span class="line">   */</span><br><span class="line">  deploy : &#123;</span><br><span class="line">    production : &#123;</span><br><span class="line">### ### ##       user : &quot;node&quot;,</span><br><span class="line">      host : &quot;212.83.163.1&quot;,</span><br><span class="line">      ref  : &quot;origin/master&quot;,</span><br><span class="line">      repo : &quot;git@github.com:repo.git&quot;,</span><br><span class="line">      path : &quot;/var/www/production&quot;,</span><br><span class="line">      &quot;post-deploy&quot; : &quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    dev : &#123;</span><br><span class="line">      user : &quot;node&quot;,</span><br><span class="line">      host : &quot;212.83.163.1&quot;,</span><br><span class="line">      ref  : &quot;origin/master&quot;,</span><br><span class="line">      repo : &quot;git@github.com:repo.git&quot;,</span><br><span class="line">      path : &quot;/var/www/development&quot;,</span><br><span class="line">      &quot;post-deploy&quot; : &quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env dev&quot;,</span><br><span class="line">      env  : &#123;</span><br><span class="line">        NODE_ENV: &quot;dev&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应为目前我们仅部署一个应用，因此，先把不必要的信息删除，即删除apps部分的第二项。同时把我们的目标文件改为你应用的入口文件，此处修改为Express.js的默认设置，即：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">script    <span class="punctuation">:</span> <span class="string">&quot;./bin/www&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>apps部分就设置完毕了，然后再设置deploy部分。其中production用于生产环境，dev用于开发环境，为了演示，我们只设置production部分。</p>
<p>下面依次介绍各个设置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">production : &#123;</span><br><span class="line">  user : &quot;登录远程服务器的用户名，此处填写我们创建的yishi&quot;,</span><br><span class="line">  host : &quot;远程服务器的IP或hostname，此处可以是数组同步部署多个服务器，不过鉴于我们只有一个服务器，因此我们填写123.57.205.23&quot;,</span><br><span class="line">  ref  : &quot;远端名称及分支名，此处填写origin/master&quot;,</span><br><span class="line">  repo : &quot;git仓库地址，此处填写git@github.com:e10101/pm2app.git&quot;,</span><br><span class="line">  path : &quot;远程服务器部署目录，需要填写user具备写入权限的目录，此处填写/home/yishi/www/production&quot;,</span><br><span class="line">  &quot;post-deploy&quot; : &quot;部署后需要执行的命令，此处填写npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整理后，按照我们的设置，应为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">production: &#123;</span><br><span class="line">  user: &quot;yishi&quot;,</span><br><span class="line">  host: &quot;123.57.205.23&quot;,</span><br><span class="line">  ref: &quot;origin/master&quot;,</span><br><span class="line">  repo: &quot;git@github.com:e10101/pm2app.git&quot;,</span><br><span class="line">  path: &quot;/home/yishi/www/production&quot;,</span><br><span class="line">  &quot;post-deploy&quot;: &quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub yishi@123.57.205.23:/home/yishi/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>上述命令中的yishi为用户名，执行时需要替换为你设置的用户名。</p>
<p>设置ssh完毕后，再看看整理完毕的ecosystem配置文件，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  /**</span><br><span class="line">   * Application configuration section</span><br><span class="line">   * PM2 - Application Declaration</span><br><span class="line">   */</span><br><span class="line">  apps : [</span><br><span class="line">    // First application</span><br><span class="line">    &#123;</span><br><span class="line">      name      : &quot;pm2app&quot;,</span><br><span class="line">      script    : &quot;./bin/www&quot;,</span><br><span class="line">      env: &#123;</span><br><span class="line">        COMMON_VARIABLE: &quot;true&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      env_production : &#123;</span><br><span class="line">        NODE_ENV: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  /**</span><br><span class="line">   * Deployment section</span><br><span class="line">   * PM2 - Deployment</span><br><span class="line">   */</span><br><span class="line">  deploy : &#123;</span><br><span class="line">    production : &#123;</span><br><span class="line">      user: &quot;yishi&quot;,</span><br><span class="line">      host: &quot;123.57.205.23&quot;,</span><br><span class="line">      ref: &quot;origin/master&quot;,</span><br><span class="line">      repo: &quot;git@github.com:e10101/pm2app.git&quot;,</span><br><span class="line">      path: &quot;/home/yishi/www/production&quot;,</span><br><span class="line">      &quot;post-deploy&quot;: &quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本地应用目录下，执行pm2 deploy命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 deploy ecosystem.json production setup</span><br></pre></td></tr></table></figure>

<p>提示错误：</p>
<blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br><span class="line">  failed to clone</span><br><span class="line">Deploy failed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>此时主要是在远程服务器中，并未将<a href="https://link.zhihu.com/?target=http://github.com">http://github.com</a>加入known_hosts，在服务器端通过如下命令设置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure>

<p>在本地继续执行部署命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 deploy ecosystem.json production setup</span><br></pre></td></tr></table></figure>

<p>此时，如无其他问题，输出应提示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  ○ setup complete</span><br><span class="line">--&gt; Success</span><br></pre></td></tr></table></figure>

<p>至此，pm2的部署设置完毕。</p>
<h2 id="pm2部署"><a href="#pm2部署" class="headerlink" title="pm2部署"></a>pm2部署</h2><p>pm2的部署设置完毕后，接下来就是实际部署了。</p>
<p>在部署前，现将本地代码修改并进行git提交：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;update ecosystem&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>提交后，在本地应用目录，输入如下命令进行生产环境的部署：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 deploy ecosystem.json production</span><br></pre></td></tr></table></figure>

<p>可以看到如下输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[PM2][WARN] Applications pm2app not running, starting...</span><br><span class="line">[PM2] App [pm2app] launched (1 instances)</span><br><span class="line">┌──────────┬────┬──────┬──────┬────────┬─────────┬────────┬─────────────┬──────────┐</span><br><span class="line">│ App name │ id │ mode │ pid  │ status │ restart │ uptime │ memory      │ watching │</span><br><span class="line">├──────────┼────┼──────┼──────┼────────┼─────────┼────────┼─────────────┼──────────┤</span><br><span class="line">│ pm2app   │ 0  │ fork │ 1028 │ online │ 0       │ 0s     │ 11.246 MB   │ disabled │</span><br><span class="line">└──────────┴────┴──────┴──────┴────────┴─────────┴────────┴─────────────┴──────────┘</span><br><span class="line"> Use `pm2 show &lt;id|name&gt;` to get more details about an app</span><br><span class="line">  ○ hook test</span><br><span class="line">  ○ successfully deployed origin/master</span><br><span class="line">--&gt; Success</span><br></pre></td></tr></table></figure>

<p>部署成功，在远程服务器查看端口情况：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">netstat -antp</span><br></pre></td></tr></table></figure>

<p>可以看到应用默认部署的3000端口已经开放了。通过浏览器打开：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://123.57.205.23:3000/</span><br></pre></td></tr></table></figure>

<p>可以看到部署的Web应用可以访问了。（如果netstat -antp中可见3000端口可访问，可以检查下ECS的防火墙设置，确保3000端口对外开放）</p>
<h2 id="pm2其他命令"><a href="#pm2其他命令" class="headerlink" title="pm2其他命令"></a>pm2其他命令</h2><p>应用列表：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure>

<p>应用信息（查看应用编号为0的信息）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 show 0 </span><br></pre></td></tr></table></figure>

<h2 id="（重要）服务器端设置pm2开机自动启动"><a href="#（重要）服务器端设置pm2开机自动启动" class="headerlink" title="（重要）服务器端设置pm2开机自动启动"></a>（重要）服务器端设置pm2开机自动启动</h2><p>开启启动设置，此处是CentOS系统，其他系统替换最后一个选项（可选项：ubuntu, centos, redhat, gentoo, systemd, darwin, amazon）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 startup centos</span><br></pre></td></tr></table></figure>

<p>然后按照提示需要输入的命令进行输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo su -c &quot;env PATH=$PATH:/usr/bin pm2 startup centos -u yishi --hp /home/yishi&quot;</span><br></pre></td></tr></table></figure>

<p>保存pm2设置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm2 save</span><br></pre></td></tr></table></figure>

<p>现在重新启动系统，测试是否可以开机启动：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>等系统重启后，通过浏览器检查系统是否自动启动：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://123.57.205.23:3000/</span><br></pre></td></tr></table></figure>

<p>如果启动正常，说明设置成功！</p>
<p><strong>以上就是如何通过pm2部署Node应用到服务器生成环境的总结。</strong></p>
]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
  </entry>
  <entry>
    <title>Python 学习笔记</title>
    <url>/2020/01/27/python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><span id="more"></span>

<h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><p>当方法体还没有定义好,但是想先调试代码时可以先用<code>pass</code><br>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>此时 nop 函数也可以被调用,只是什么都不会做</p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><blockquote>
<p>定义默认参数要牢记一点：默认参数必须指向不变对象！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=[]</span>):</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>

<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<h2 id="切片-slice-0-1-2"><a href="#切片-slice-0-1-2" class="headerlink" title="切片(slice[0:1:2])"></a>切片(slice[0:1:2])</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>] <span class="comment"># 从下角标 0 开启,到下角标为 4 的(不包括 4),每隔 2 个取一个</span></span><br><span class="line"><span class="built_in">str</span>[-<span class="number">5</span>] <span class="comment"># 从倒数第五个开始,往后的全部</span></span><br><span class="line"><span class="built_in">str</span>[:-<span class="number">1</span>] <span class="comment"># 从头开始一直取到下角标为-1 的(不包括)</span></span><br></pre></td></tr></table></figure>

<p>切片的顺序的不会变的,都是从前往后,能改变的只是起止的位置范围,每隔几个取一次</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d <span class="comment"># 遍历 key</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values() <span class="comment"># 遍历对象的值</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items() <span class="comment"># 遍历对象的每个键值对</span></span><br></pre></td></tr></table></figure>

<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="literal">None</span>]</span><br><span class="line">L2 = [s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L1 <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, <span class="built_in">str</span>)]</span><br><span class="line"><span class="built_in">print</span>(L2) <span class="comment"># [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;apple&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>总结:<br>[数值输出时还可以做处理  forInList  条件]<br>条件里要加 <code>if</code>, 虽然不加也是返回布尔值,但还是要加<code>if</code></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p>
<ul>
<li>一类是集合数据类型，如list、tuple、dict、set、str等；</li>
<li>一类是generator，包括生成器和带yield的generator function。</li>
</ul>
<p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator</p>
<p>迭代器都是可迭代对象,但是可迭代对象不一定都是迭代器:</p>
<p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。<br>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p>
<blockquote>
<p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。list、dict、str一开始时就能知道他们的长度,所以他们不是迭代器.</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2017/11/29/redis/</url>
    <content><![CDATA[<p>redis 启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./src/redis-server ./redis.conf</span><br><span class="line">./src/redis-cli</span><br><span class="line">auth heyzWebRedis2016</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><img src="http://p04c6djlz.bkt.clouddn.com//17-11-29/87023246.jpg"></p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>redis的multi和pipeline的介绍与区别</title>
    <url>/2020/07/06/redis%E7%9A%84multi%E5%92%8Cpipeline%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="multi是标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由-EXEC-命令原子性-atomic-地执行。"><a href="#multi是标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由-EXEC-命令原子性-atomic-地执行。" class="headerlink" title="multi是标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。"></a>multi是标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multi = <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">redis</span>.<span class="title function_">multi</span>();</span><br><span class="line">multi.<span class="title function_">zadd</span>(onlineUserListKey, <span class="number">0</span>, userId);</span><br><span class="line">multi.<span class="title function_">expire</span>(onlineUserListKey, <span class="variable language_">this</span>.<span class="property">defaultExpire</span>);</span><br><span class="line"><span class="keyword">await</span> multi.<span class="title function_">exec</span>();</span><br></pre></td></tr></table></figure>

<p>把多个redis操作放到一个队列里,multi是在服务端缓冲,全部请求到redis以后,等待exec()命令,再一起执行,具有原子性.</p>
<h2 id="pipeline是客户端将执行的命令写入到缓冲中，最后由exec命令一次性发送给redis执行返回"><a href="#pipeline是客户端将执行的命令写入到缓冲中，最后由exec命令一次性发送给redis执行返回" class="headerlink" title="pipeline是客户端将执行的命令写入到缓冲中，最后由exec命令一次性发送给redis执行返回"></a>pipeline是客户端将执行的命令写入到缓冲中，最后由exec命令一次性发送给redis执行返回</h2><p>pipeline是通过管道一个个的去执行命令,在redis的客户端做缓冲,减少了redis的连接与请求量,减轻了redis的压力,但是结果依然是按顺序一个个执行,并不具有原子性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline = <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">redis</span>.<span class="title function_">pipeline</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">of</span> ids) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = redisKeys.<span class="property">string</span>.<span class="title function_">ad</span>(id);</span><br><span class="line">    pipeline.<span class="title function_">get</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">await</span> pipeline.<span class="title function_">exec</span>();</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>multi和pipeline都是将redis命令缓冲,再统一执行,但是则重点不同</p>
<ul>
<li>multi是为了多个操作的原子性,pipeline是为了减少redis的连接和请求压力.</li>
<li>multi是服务端缓冲,pipeline是客户端缓冲</li>
<li>请求次数的不一致，multi需要每个命令都发送一次给服务端，pipeline最后一次性发送给服务端，请求次数相对于multi减少</li>
<li>multi&#x2F;exec可以保证原子性，而pipeline不保证原子性</li>
</ul>
<p><strong>所以当redis操作要求保证原子性时,使用multi&#x2F;exec,其他时候应该使用pipeline去减轻redis的压力</strong></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>redis 基本操作与五大数据类型</title>
    <url>/2019/04/03/reids%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单的讲,redis 是一个非常高效的简单数据库,这个数据库只有5种数据结构.<br>因为 redis 具有速度快,可以设置过期时间的特性,常被用来做缓存.</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol>
<li>string 字符串</li>
<li>hash 多个键值对的集合</li>
<li>set 集合</li>
<li>sorted set 有序集合</li>
<li>list 列表</li>
</ol>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>redis 的五种数据结构其实也都是键值对,区别在于键值对的值不一样,不一样的数据结构的值可能又是另一个键值对,或者是一系列的键值对.<br>但是就像 JavaScript 中所有的数据结构都是从 Object 类型继承来的一样,redis 也可以类比成这样.五种数据结构都继承于键值对,所以也会有一些通用的方法.</p>
<h3 id="redis基本命令"><a href="#redis基本命令" class="headerlink" title="redis基本命令"></a><a href="http://www.runoob.com/redis/redis-keys.html">redis基本命令</a></h3><span id="more"></span>

<p>其中比较常用的有:</p>
<ul>
<li>del key - 删除 key</li>
<li>exists key - 判断可以是否存在,存在返回1,不存在返回0</li>
<li>expire key - 给 key 设置过期时间,单位为秒</li>
<li>pexprie key - 给 key 设置过期时间,单位是毫秒</li>
<li>expireat key - 给key 设置过期时间,区别在于这里的参数是 Unix 时间戳</li>
<li>rename key newKey - 重命名 key, 这个操作如果key 不存在会报错,所以使用前需要先用 exists key 判断一下,并且如果 newKey 已经存在的话会覆盖,所以最好也判断一下 exists newKey</li>
<li>renamenx key newKey - 重命名key, 仅当 newKey 不存在时成功,就可以少判断一次 exists newKey 了</li>
</ul>
<h2 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190403171809.jpg"></p>
<p>string 类型非常简单,就是最简单的键值对,key 是一个 string, value 也是一个 string.<br>最常用的命令也就是 get,set,可以说是其他类型的一个基类了.</p>
<h3 id="string-基本命令"><a href="#string-基本命令" class="headerlink" title="string 基本命令"></a><a href="http://www.runoob.com/redis/redis-strings.html">string 基本命令</a></h3><h3 id="set方法可直接设置过期时间-需要几个可选参数"><a href="#set方法可直接设置过期时间-需要几个可选参数" class="headerlink" title="set方法可直接设置过期时间,需要几个可选参数"></a>set方法可直接设置过期时间,需要几个可选参数</h3><p>redis.set(key, value, timeType[opt], time[opt], NX|XX[opt])<br>其中 timeType:</p>
<ul>
<li>‘EX’ 指的是 time 的单位是秒</li>
<li>‘PX’ 指的是 time 的单位是毫秒</li>
</ul>
<p>这 NX|XX 意思是: </p>
<ul>
<li>‘NX’ 只有当 key 不存在时才设置过期时间</li>
<li>‘XX’ 只有当 key 存在时才设置过期时间</li>
</ul>
<h2 id="hash-类型"><a href="#hash-类型" class="headerlink" title="hash 类型"></a>hash 类型</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190403171846.jpg"></p>
<blockquote>
<p>hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
</blockquote>
<p>这里引入了一个 field的概念,其实 hash 就是一个 value 是多个 string 类型键值对集合的键值对,这里的 field 就是 一个二级 key.<br>不过不能无限分级下去,这个 field 对应的 value 就一定是一个 string 字符串<br>hash 的命令主要是在 string 的基础上最前面加个h,类似的: </p>
<ul>
<li>hdel key field1 field2 … - 删除 field</li>
<li>hexists key field - 判断存在与否</li>
<li>hset key field value - 写入 field 的值</li>
<li>hget key field - 获取key 下某 field 的值</li>
<li>hlen key - 获取 field 的数量</li>
<li>hkeys key - 获取所有 field 的name</li>
</ul>
<p>因为一个 key下可以有几乎无数个 field,所以就会有批量操作: </p>
<ul>
<li>hmset key field1 value1 field2 value2.. - js 中把 field 和 value 按顺序的放入数组中,就可以批量写入例如 <code>redis.hset(key, [field1, value1, field2, value2...])</code></li>
<li>hmget key filed1 field2 field3.. - 同理,会按field 的顺序返回value 数组</li>
<li>hgetall key - 获取 key 下的所有 field,但如果 field 数量过多,可能会导致 redis 堵塞,所以在不确定一个 hash key 下有多少 field 的情况,不推荐使用.</li>
<li>hscan key cursor [MATCH pattern] [COUNT count] - 扫描器,可以做类似分页查询的操作,还可以做模糊查询 cursor 就是游标起点,count 就是 pagesize. 模糊查询就是 match 后面加正则匹配查询但是用hscan 做分页查询是不能排序,只能按原 key 的 field 排序获取, 返回[field, value]</li>
</ul>
<h3 id="hash-基本命令"><a href="#hash-基本命令" class="headerlink" title="hash 基本命令"></a><a href="http://www.runoob.com/redis/redis-sets.html">hash 基本命令</a></h3><h2 id="set-类型"><a href="#set-类型" class="headerlink" title="set 类型"></a>set 类型</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190403174748.jpg"></p>
<blockquote>
<p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。<br>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
</blockquote>
<h3 id="简单的说-set-就是一个-field-不可重复-且-value-x3D-field-的-hash"><a href="#简单的说-set-就是一个-field-不可重复-且-value-x3D-field-的-hash" class="headerlink" title="简单的说,set 就是一个 field 不可重复,且 value&#x3D;field 的 hash"></a>简单的说,set 就是一个 field 不可重复,且 value&#x3D;field 的 hash</h3><p>set 类型大多用在统计人数等不可重复的情况下.<br>常用的命令有:</p>
<ul>
<li>sadd key member1 member2 - 给集合添加成员,这里又引入了 member 的概念,应该是为了区分 field</li>
<li>sismember key member - 判断 member 是否是 key 的成员</li>
<li>scard key - 获取 key 的总 member 数</li>
<li>srem key member1 member2 - 移除 key 中的一个或多个成员</li>
<li>smembers key - 返回集合中的所有成员,同样的可能会出现堵塞,所以也有扫描器</li>
<li>sscan key cursor [match pattern] [count count] - 扫描器,返回 member</li>
</ul>
<p>set 还有一些差集,交集的离散数学操作.</p>
<h3 id="set-基本命令"><a href="#set-基本命令" class="headerlink" title="set 基本命令"></a><a href="http://www.runoob.com/redis/redis-sets.html">set 基本命令</a></h3><h2 id="sorted-set-类型"><a href="#sorted-set-类型" class="headerlink" title="sorted set 类型"></a>sorted set 类型</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190403180034.jpg"></p>
<p>有序集合就是在集合 set 的基础上,给每个 member 再附上一个double 类型的分数score.member 虽然要是唯一的,但是 score 是可以重复的.我们可以用这个 score 来实现排序.</p>
<p>常用的命令有: </p>
<ul>
<li>zadd key [score1,member1,score2,member2…] - 给key 添加带 score 的成员,sore 是必选参数.</li>
<li>zcard key - 获取集合成员数</li>
<li>zrem key [member1,member2..] - 移除一个或多个成员</li>
<li>zscore key member - 获取成员的分数值</li>
</ul>
<p>除了常规是增加删除外还有关于 score 的操作:</p>
<ul>
<li>zcount key min max - 计算 score 在这个区间内的 member 有多少</li>
<li>zrangebyscore key min max [withscore] [limit offset count] - 返回分数在这个区间的成员,其中,无穷小,无穷大用-inf,+inf 表示. 如果withscore 的话就会返回 [member,score]这样的结构,还可以指定 limit, offset, count来做分页查询.js 中一般是<code>redis.zrangebyscore([key, &#39;-inf&#39;, &#39;+inf&#39;, &#39;limit&#39;, offset, pagesize])</code> 返回值是从小到大排序</li>
<li>zrevrangebyscore key max min [withsocre] [limit offset count] - 同上,不过是最大最小反过来</li>
<li>zremrangebyrank key min max - 删除 score 从min 到 max 之间的 member</li>
<li>zremrangebylex key start stop - 删除在 start成员到 stop 成员之间的所有成员(包括边界),lex指的是在有序 set 中的某一成员</li>
<li>zrange key start stop [withscore] - 返回下角标在 start 到 stop 之间(包括边界)的所有成员,这里是 start 和 stop 就是成员在 sorted set 中的排序,从0开始. 如果是<code>redis.zrange(key, 0, -1)</code>就是 返回所有成员, 想知道成员的下角标可以用 zrank</li>
<li>zrank key member - 返回成员的索引指,即下角标</li>
<li>zscan key cursor [match pattern] [count count] - 有序集合同样也有扫描器</li>
</ul>
<h3 id="sorted-set-基本命令"><a href="#sorted-set-基本命令" class="headerlink" title="sorted set 基本命令"></a><a href="http://www.runoob.com/redis/redis-sorted-sets.html">sorted set 基本命令</a></h3><h2 id="list-类型"><a href="#list-类型" class="headerlink" title="list 类型"></a>list 类型</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190403183230.jpg"></p>
<p>list 类型就是数据结构中的队列加栈,因为 list 类型既可以从头部(左边)添加元素,也可以从尾部(右边)添加元素,删除元素也是一样,但必须是按序的,不能添加或者删除中间的元素.</p>
<p>常用的命令有: </p>
<ul>
<li>lpush key [value1, value2..] - 添加一个或多个元素到队首</li>
<li>lpop key - 移出队首的第一个元素</li>
<li>rpush key [value1, value2..] - 添加一个或多个元素到队尾</li>
<li>rpop key - 移出队尾的第一个元素</li>
<li>llen key - 获取队列长度</li>
</ul>
<p>用以上的几个命令就可以组成队列操作和栈操作<br> lpush + lpop 或者 rpush + rpop就是栈操作<br> lpush + rpop 就是队首在右边的队列操作<br> rpush + lpop 就是队首在左边的队列操作</p>
<p><a href="http://www.runoob.com/redis/redis-lists.html">list 基本命令</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>sign with Apple开发总结</title>
    <url>/2020/03/19/sign%20with%20appleId%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>要在App Store 新上架的App要在4月份前适配iOS 13,其中App如果使用了第三方登录的,就要同时支持AppleId 登录,也是一种第三方登录.</p>
<p>先放一个时序图:<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200319153719.png"></p>
<h2 id="第一步-客户端和AppleServer交互后请求后端"><a href="#第一步-客户端和AppleServer交互后请求后端" class="headerlink" title="第一步,客户端和AppleServer交互后请求后端"></a>第一步,客户端和AppleServer交互后请求后端</h2><p>客户端向苹果服务器请求,拿到用户的信息和identityToken.主要返回数据如下:</p>
<ul>
<li>user: 用户唯一ID，在一个开发者账号下的APP获取到的是一样的，类似微信开发API中的openid；</li>
<li>identityToken: 「JWT」格式的token，用于验证信息合法性。</li>
<li>email: 用户邮箱(可能为空)</li>
<li>fullName: 昵称等信息</li>
<li>realUserStatus: 是否是“真实用户”，可用于反作弊，对抗黑灰产. (0为黑户,1为不确定,2为正常用户)</li>
</ul>
<p>拿到信息后调用接口,把信息传给后端,但这样有个重要的问题就是不能保证安全性，无法判断请求是否是伪造的。这个时候就要使用identityToken了。</p>
<h3 id="注意：当第一次认证成功之后，将不会再返回email，fullName等信息，可以在设置-gt-Apple-ID-gt-密码与安全性-gt-使用您AppleID的App-中删除对应的APP。"><a href="#注意：当第一次认证成功之后，将不会再返回email，fullName等信息，可以在设置-gt-Apple-ID-gt-密码与安全性-gt-使用您AppleID的App-中删除对应的APP。" class="headerlink" title="注意：当第一次认证成功之后，将不会再返回email，fullName等信息，可以在设置-&gt;Apple ID-&gt;密码与安全性-&gt;使用您AppleID的App 中删除对应的APP。"></a>注意：当第一次认证成功之后，将不会再返回email，fullName等信息，可以在设置-&gt;Apple ID-&gt;密码与安全性-&gt;使用您AppleID的App 中删除对应的APP。</h3><h2 id="第二步-后端校验identityToken合法性"><a href="#第二步-后端校验identityToken合法性" class="headerlink" title="第二步,后端校验identityToken合法性"></a>第二步,后端校验identityToken合法性</h2><p>identityTokenString实际上是JWT（JSON Web Token）格式的文件，JWT文件由三部分组成：</p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<span id="more"></span>

<p>这三部分由”.”分割，其中Header和Payload是经过base64编码的。<br>Header base64解码之后示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span><span class="string">&quot;eXaunmL&quot;</span><span class="punctuation">,</span> <span class="comment">// 用来确定publicKey,后面说</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;RS256&quot;</span> <span class="comment">// 加密算法</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Payload base64解码之后示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://appleid.apple.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.easeapi.www&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span><span class="number">1584588402</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span><span class="number">1584587802</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span><span class="string">&quot;022409.17avbbaf112941e5a722788e7f3880f4.4565&quot;</span><span class="punctuation">,</span> <span class="comment">// 用户唯一ID</span></span><br><span class="line">    <span class="attr">&quot;c_hash&quot;</span><span class="punctuation">:</span><span class="string">&quot;DmuPZ_bX1Tr6AGFW3rDYbQ&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;auth_time&quot;</span><span class="punctuation">:</span><span class="number">1584587802</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nonce_supported&quot;</span><span class="punctuation">:</span><span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而Signature部分就是对Header及Payload两部分内容按指定算法进行签名，大致逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Signature = signature(base64UrlEncode(Header) + &quot;.&quot; + base64UrlEncode(Payload), secretKey)</span><br><span class="line">#signature代表具体的加密算法；</span><br><span class="line">#secretKey为密钥；</span><br></pre></td></tr></table></figure>

<p>具体到identityToken，Apple目前采用的是RS256的非对称加密算法：</p>
<p>Apple会使用私钥（也即为上面的secretKey）对Header及Payload加密，获取Signature；<br>将Header，Payload及Signature信息包装为JWT格式文件，即是identityToken；<br>那么，我们如何才能验证拿到的identityToken是否合法呢，这就要用到Apple提供的公钥了。公钥获取地址：<a href="https://appleid.apple.com/auth/keys">https://appleid.apple.com/auth/keys</a><br>直接用GET请求就会得等一个数组Keys,也就是 JWK 列表。这也就意味着客户端向服务器提交的 identityToken 可能是用 keys 里面的特定某个 JWK 来进行加密的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;kty&quot;</span><span class="punctuation">:</span><span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span><span class="string">&quot;86D88Kf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;use&quot;</span><span class="punctuation">:</span><span class="string">&quot;sig&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;n&quot;</span><span class="punctuation">:</span><span class="string">&quot;iGaLqP6y-SJCCBq5Hv6pGDbG_SQ11MNjH7rWHcCFYz4hGwHC4lcSurTlV8u3avoVNM8jXevG1Iu1SY11qInqUvjJur--hghr1b56OPJu6H1iKulSxGjEIyDP6c5BdE1uwprYyr4IO9th8fOwCPygjLFrh44XEGbDIFeImwvBAGOhmMB2AD1n1KviyNsH0bEB7phQtiLk-ILjv1bORSRl8AK677-1T8isGfHKXGZ_ZGtStDe7Lu0Ihp8zoUt59kx2o9uWpROkzF56ypresiIl4WprClRCjz8x6cPZXU2qNWhu71TQvUFwvIvbkE1oYaJMb0jcOTmBRZA2QuYw-zHLwQ&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;e&quot;</span><span class="punctuation">:</span><span class="string">&quot;AQAB&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;kty&quot;</span><span class="punctuation">:</span><span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span><span class="string">&quot;eXaunmL&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;use&quot;</span><span class="punctuation">:</span><span class="string">&quot;sig&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;n&quot;</span><span class="punctuation">:</span><span class="string">&quot;4dGQ7bQK8LgILOdLsYzfZjkEAoQeVC_aqyc8GC6RX7dq_KvRAQAWPvkam8VQv4GK5T4ogklEKEvj5ISBamdDNq1n52TpxQwI2EqxSk7I9fKPKhRt4F8-2yETlYvye-2s6NeWJim0KBtOVrk0gWvEDgd6WOqJl_yt5WBISvILNyVg1qAAM8JeX6dRPosahRVDjA52G2X-Tip84wqwyRpUlq2ybzcLh3zyhCitBOebiRWDQfG26EH9lTlJhll-p_Dg8vAXxJLIJ4SNLcqgFeZe4OfHLgdzMvxXZJnPp_VgmkcpUdRotazKZumj6dBPcXI_XID4Z4Z3OM1KrZPJNdUhxw&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;e&quot;</span><span class="punctuation">:</span><span class="string">&quot;AQAB&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>接下来就需要我们确定当前的 identityToken 到底是使用哪个 JWK 来加密的，这样做可以避免批量生成证书，提升性能。找到keys数组中的kid和我们刚刚从Header中解析出来的kid相同的那个对象.那个就我们要用的publicKey.但是现在的publicKey格式不是我们要的PEM文件格式.所以要把数据再转一下格式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// pem公钥</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8kGa1pSjbSYZVebtTRBLxBz5H</span><br><span class="line">4i2p/llLCrEeQhta5kaQu/RnvuER4W8oDH3+3iuIYW4VQAzyqFpwuzjkDI+17t5t</span><br><span class="line">0tyazyZ8JXw+KgXTxldMPEL95+qVhgXvwtihXC1c5oGbRlEDvDF6Sa53rcFVsYJ4</span><br><span class="line">ehde/zUxo6UvS7UrBQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<p>我这里用的是<code>jwk-to-pem</code>包做的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jwkToPem = <span class="built_in">require</span>(<span class="string">&#x27;jwk-to-pem&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getPublicKey</span>(<span class="params">kid</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> publicKey;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="title function_">curl</span>(<span class="string">&#x27;https://appleid.apple.com/auth/keys&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">dataAsQueryString</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> result.<span class="property">data</span>.<span class="property">keys</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.<span class="property">kid</span> === kid) &#123;</span><br><span class="line">            publicKey = key;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> pem = <span class="title function_">jwkToPem</span>(publicKey);</span><br><span class="line">    <span class="keyword">return</span> pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取PEM后再用JWT校验identityToken就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> header = identityToken.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">header = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">Base64</span>.<span class="title function_">decode</span>(header));</span><br><span class="line"><span class="keyword">const</span> publicKey = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getPublicKey</span>(header.<span class="property">kid</span>);</span><br><span class="line"><span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">app</span>.<span class="property">jwt</span>.<span class="title function_">verify</span>(identityToken, publicKey);</span><br></pre></td></tr></table></figure>

<h2 id="第三步-业务逻辑处理"><a href="#第三步-业务逻辑处理" class="headerlink" title="第三步,业务逻辑处理"></a>第三步,业务逻辑处理</h2><p>使用user或者校验identityToken得到的sub作为唯一标识注册用户,这里最好还要缓存一下email，fullName字段,以免因为网络等原因在校验成功后没有注册用户,导致丢失数据.</p>
<p>参考文档:<br><a href="https://easeapi.com/blog/blog/88-sign-with-apple.html">大伟不是戴维 blog</a><br><a href="https://segmentfault.com/a/1190000020840290">segmentfault</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>socket.io 事件</title>
    <url>/2017/11/27/socket%20%C2%A0%E5%90%84%E7%A7%8D%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>Object.keys(socket.server.sockets.sockets)是当前连接上 socket 的所有客户端的socket.Id<br>Object.keys(socket.server.sockets.connected)也是<br>Object.keys(socket.server.eio.clients)</p>
<p>socket.on(‘login’, (socket) &#x3D;&gt; {<br>  socketId &#x3D; socket.id&#x2F;&#x2F;当前连接的 socketId<br>})</p>
<p>socket.id 就是当前客户端的 socketId</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送给当前请求的客户端</span></span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&quot;this is a test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给除了当前请求的所有的客户端</span></span><br><span class="line">socket.<span class="property">broadcast</span>.<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&quot;this is a test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给所有的客户端包括请求的客户端</span></span><br><span class="line">io.<span class="property">sockets</span>.<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&quot;this is a test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给在game房间(Room)的除啦当前请求的所有客户端</span></span><br><span class="line">socket.<span class="property">broadcast</span>.<span class="title function_">to</span>(<span class="string">&#x27;game&#x27;</span>).<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;nice game&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送给在game房间(Room)的包括请求客户端的所有的客户端</span></span><br><span class="line">io.<span class="property">sockets</span>.<span class="title function_">in</span>(<span class="string">&#x27;game&#x27;</span>).<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;cool game&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="x2F-x2F-发送给socketid-客户端标识-指定客户端"><a href="#x2F-x2F-发送给socketid-客户端标识-指定客户端" class="headerlink" title="&#x2F;&#x2F;发送给socketid(客户端标识)指定客户端"></a>&#x2F;&#x2F;<strong>发送给socketid(客户端标识)指定客户端</strong></h2><ul>
<li><p>1.0版本前使用下面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">io.<span class="property">sockets</span>.<span class="title function_">socket</span>(socketid).<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;for your eyes only&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>1.0版本后使用下面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">io.<span class="property">sockets</span>.<span class="property">connected</span>[socket.<span class="property">id</span>].<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>,<span class="string">&#x27;for your eyes only&#x27;</span> );</span><br></pre></td></tr></table></figure>
</li>
<li><h1 id="加入房间"><a href="#加入房间" class="headerlink" title="加入房间"></a>加入房间</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;joinRoom&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`joinRoom success`</span>)</span><br><span class="line">    socket.<span class="title function_">join</span>(<span class="string">`room<span class="subst">$&#123;data.roomId&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// socket.in(`room$&#123;data.roomId&#125;`).emit(&#x27;userJoinRoom&#x27;, `$&#123;data.userId&#125; join in the Room$&#123;data.roomId&#125;`);//发送给房内(包括自己)一个事件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li><h1 id="离开房间"><a href="#离开房间" class="headerlink" title="离开房间"></a>离开房间</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;leaveRoom&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`leaveRoom success`</span>)</span><br><span class="line">    socket.<span class="title function_">leave</span>(<span class="string">`room<span class="subst">$&#123;data.roomId&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// socket.to(`room$&#123;data.roomId&#125;`).emit(&#x27;userLeaveRoom&#x27;, `$&#123;data.userId&#125; leave in the Room$&#123;data.roomId&#125;`)//发送给房内(不包括自己)一个事件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>socket</category>
      </categories>
  </entry>
  <entry>
    <title>socket.io</title>
    <url>/2017/09/16/socket.io/</url>
    <content><![CDATA[<p><strong>SERVER (APP.JS)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)()</span><br><span class="line">  , server = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).<span class="title function_">createServer</span>(app)</span><br><span class="line">  , io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>).<span class="title function_">listen</span>(server);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">sendfile</span>(__dirname + <span class="string">&#x27;/index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.<span class="property">sockets</span>.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> (<span class="params">socket</span>) &#123;</span><br><span class="line">  socket.<span class="title function_">emit</span>(<span class="string">&#x27;news&#x27;</span>, &#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;);</span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;my other event&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<blockquote>
<p>其中 <code>io = require(&#39;socket.io&#39;).listen(server);</code> 将 socket.io 绑定到服务器上，于是任何连接到该服务器的客户端都具备了实时通信功能。 </p>
<p><code>io.sockets.on(&#39;connection&#39;, function (socket) &#123; ... &#125;)</code> 的作用是服务器监听所有客户端，并返回该新连接对象，接下来我们就可以通过该连接对象（socket）与客户端进行通信了。你可以看到不管是服务器还是客户端都有 emit 和 on 这两个函数，可以说 socket.io 的核心就是这两个函数了，通过 emit 和 on 可以轻松地实现服务器与客户端之间的双向通信。</p>
</blockquote>
<ul>
<li><code>emit</code> ：用来发射一个事件或者说触发一个事件，第一个参数为事件名，第二个参数为要发送的数据，第三个参数为回调函数（一般省略，如需对方接受到信息后立即得到确认时，则需要用到回调函数）。</li>
<li><code>on</code> ：用来监听一个 emit 发射的事件，第一个参数为要监听的事件名，第二个参数为一个匿名函数用来接收对方发来的数据，该匿名函数的第一个参数为接收的数据，若有第二个参数，则为要返回的函数。</li>
</ul>
<p>socket.io 提供了三种默认的事件（客户端和服务器都有）：connect 、message 、disconnect 。当与对方建立连接后自动触发 connect 事件，当收到对方发来的数据后触发 message 事件（通常为 socket.send() 触发），当对方关闭连接后触发 disconnect 事件。</p>
<p>此外，socket.io 还支持自定义事件，毕竟以上三种事件应用范围有限，正是通过这些自定义的事件才实现了丰富多彩的通信。</p>
<p>最后，需要注意的是，在服务器端区分以下三种情况：</p>
<ul>
<li>socket.emit() ：向建立该连接的客户端广播</li>
<li>socket.broadcast.emit() ：向除去建立该连接的客户端的所有客户端广播</li>
<li>io.sockets.emit() ：向所有客户端广播，等同于上面两个的和</li>
</ul>
<p>加入房间用 socket.join(‘room 10002’, () &#x3D;&gt; {})</p>
]]></content>
      <categories>
        <category>socket</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript this 的指向</title>
    <url>/2017/11/29/this%20%E7%9A%84%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>一共有4中情况:</p>
<ul>
<li>1.纯粹的函数调用<br>属于全局性调用，因此this就代表全局对象Global。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="title function_">alert</span>(x); <span class="comment">//0这里是调用了 test(),把 this.x 从1改成了0,所以这个时候的 this 指向的是全局变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.作为对象方法的调用<br>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　　　<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">　　o.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">　　o.<span class="property">m</span> = test;</span><br><span class="line">　　o.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3.作为构造函数调用<br>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">　　<span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　　　<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line">　　<span class="title function_">alert</span>(x); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4.apply调用<br>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line">o.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">o.<span class="property">m</span> = test;</span><br><span class="line">o.<span class="property">m</span>.<span class="title function_">apply</span>(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p><strong>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。<br>如果把最后一行代码修改为</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">　o.<span class="property">m</span>.<span class="title function_">apply</span>(o); <span class="comment">//1</span></span><br><span class="line">　运行结果就变成了<span class="number">1</span>，证明了这时<span class="variable language_">this</span>代表的是对象o。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>在 Ubuntu 上安装 ss</title>
    <url>/2019/03/18/ubuntu%20%E5%AE%89%E8%A3%85%20ss/</url>
    <content><![CDATA[<h1 id="在-Ubuntu-上安装-ss"><a href="#在-Ubuntu-上安装-ss" class="headerlink" title="在 Ubuntu 上安装 ss"></a>在 Ubuntu 上安装 ss</h1><h2 id="0-购买或者薅羊毛-vps"><a href="#0-购买或者薅羊毛-vps" class="headerlink" title="0. 购买或者薅羊毛 vps"></a>0. 购买或者薅羊毛 vps</h2><h2 id="1-ssh-登录"><a href="#1-ssh-登录" class="headerlink" title="1. ssh 登录"></a>1. ssh 登录</h2><h2 id="2-获取root权限"><a href="#2-获取root权限" class="headerlink" title="2. 获取root权限"></a>2. 获取root权限</h2><p><code>sudo -s</code></p>
<h2 id="3-更新apt-get"><a href="#3-更新apt-get" class="headerlink" title="3. 更新apt-get"></a>3. 更新apt-get</h2><p><code>apt-get update</code></p>
<h2 id="4-安装python包管理工具"><a href="#4-安装python包管理工具" class="headerlink" title="4. 安装python包管理工具"></a>4. 安装python包管理工具</h2><p><code>apt-get install python-setuptools</code><br><code>apt-get install python-pip</code></p>
<h2 id="5-安装ss"><a href="#5-安装ss" class="headerlink" title="5. 安装ss"></a>5. 安装ss</h2><p><code>pip install shadowsocks</code></p>
<span id="more"></span>

<h2 id="6-编写配置文件"><a href="#6-编写配置文件" class="headerlink" title="6. 编写配置文件"></a>6. 编写配置文件</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 填0.0.0.0 比填 ip 地址容易成功</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span><span class="number">8388</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span><span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;password&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span><span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workers&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-后台启动服务"><a href="#7-后台启动服务" class="headerlink" title="7. 后台启动服务"></a>7. 后台启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">启动：ssserver -c ss.json -d start </span><br><span class="line">停止：ssserver -c ss.json -d stop </span><br><span class="line">重启：ssserver -c ss.json -d restart</span><br></pre></td></tr></table></figure>
<h2 id="8-安装-BBR-加速"><a href="#8-安装-BBR-加速" class="headerlink" title="8. 安装 BBR 加速"></a>8. 安装 BBR 加速</h2><p><code>wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</code></p>
<h3 id="获取读写权限"><a href="#获取读写权限" class="headerlink" title="获取读写权限"></a>获取读写权限</h3><p><code>chmod +x bbr.sh</code></p>
<h3 id="启动-BBR"><a href="#启动-BBR" class="headerlink" title="启动 BBR"></a>启动 BBR</h3><p><code>./bbr.sh</code></p>
<blockquote>
<p>接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。<br>重新启动之后，输入 lsmod | grep bbr 如果看到 tcp_bbr 就说明 BBR 已经启动了。</p>
</blockquote>
<h2 id="9-设置-SS-为开机启动项"><a href="#9-设置-SS-为开机启动项" class="headerlink" title="9. 设置 SS 为开机启动项"></a>9. 设置 SS 为开机启动项</h2><p><code>vi /etc/rc.local</code><br>写入 <code>sudo ssserver -c /etc/shadowsocks/ss.json -d start</code><br>    <code>./bbr.sh</code></p>
<h2 id="10-如果遇到EVP-CIPHER-CTX-cleanup错误"><a href="#10-如果遇到EVP-CIPHER-CTX-cleanup错误" class="headerlink" title="10. 如果遇到EVP_CIPHER_CTX_cleanup错误"></a>10. 如果遇到EVP_CIPHER_CTX_cleanup错误</h2><blockquote>
<p>解决openssl升级到1.1.0以上版本，导致shadowsocks2.8.2启动报undefined symbol: EVP_CIPHER_CTX_cleanup错误。</p>
</blockquote>
<ol>
<li>用vim打开文件：vim &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;crypto&#x2F;openssl.py (该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)</li>
<li>跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup）</li>
<li>进入编辑模式,将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes &#x3D; (c_void_p,) 改为libcrypto.EVP_CIPHER_CTX_reset.argtypes &#x3D; (c_void_p,)</li>
<li>再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx) 改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx), 保存并退出</li>
<li>启动ss服务：service shadowsocks start 或 sslocal -c ss配置文件目录<br>问题解决</li>
</ol>
<h2 id="aws-安装-ss"><a href="#aws-安装-ss" class="headerlink" title="aws 安装 ss"></a>aws 安装 ss</h2><p><a href="http://cqwdc.com/post/7ebafa90.html">参考博客</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>Web 中间件</title>
    <url>/2017/11/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>简单说，中间件(middleware)就是处理HTTP请求的函数。</strong> 它最大的特点就是，一个中间件处理完，再传递给 下一个中间件。App实例在运行过程中，会调用一系列的中间件。<br>每个中间件可以从App实例，接收三个参数，依次为request对象(代表HTTP请求)、response对象(代表 HTTP回应)，next回调函数(代表下一个中间件)。每个中间件都可以对HTTP请求(request对象)进行加工， 并且决定是否调用next方法，将request对象再传给下一个中间件。<br>一个不进行任何操作、只传递request对象的中间件，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uselessMiddleware</span>(<span class="params">req, res, next</span>) &#123;   <span class="title function_">next</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uselessMiddleware</span>(<span class="params">req, res, next</span>) &#123;   <span class="title function_">next</span>(<span class="string">&#x27;出错了!&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。</p>
<span id="more"></span>
<h2 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h2><p>use是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);<span class="keyword">var</span> app = <span class="title function_">express</span>();app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">request, response, next</span>) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;In comes a &quot;</span> + request.<span class="property">method</span> + <span class="string">&quot; to &quot;</span> + request.<span class="property">url</span>);   <span class="title function_">next</span>();&#125;);app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">request, response</span>) &#123;  response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);   response.<span class="title function_">end</span>(<span class="string">&quot;Hello world!\n&quot;</span>);&#125;); http.<span class="title function_">createServer</span>(app).<span class="title function_">listen</span>(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码使用app.use方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行 信息，然后通过next方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方 法，所以request对象就不再向后传递了。</li>
<li>use方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内 容。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);<span class="keyword">var</span> app = <span class="title function_">express</span>();app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">request, response, next</span>) &#123;   <span class="keyword">if</span> (request.<span class="property">url</span> == <span class="string">&quot;/&quot;</span>) &#123;response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);response.<span class="title function_">end</span>(<span class="string">&quot;Welcome to the homepage!\n&quot;</span>); &#125; <span class="keyword">else</span> &#123;<span class="title function_">next</span>();   &#125;&#125;);app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">request, response, next</span>) &#123;   <span class="keyword">if</span> (request.<span class="property">url</span> == <span class="string">&quot;/about&quot;</span>) &#123;    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);   &#125; <span class="keyword">else</span> &#123;    <span class="title function_">next</span>();    &#125;  &#125;);app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">request, response</span>) &#123;   response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);  response.<span class="title function_">end</span>(<span class="string">&quot;404 error!\n&quot;</span>);&#125;);http.<span class="title function_">createServer</span>(app).<span class="title function_">listen</span>(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。注意，app.use方法一共登记了 三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回404错误， 即前面的中间件都没匹配请求路径，找不到所要请求的资源。<br>除了在回调函数内部判断请求的网址，use方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配 这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/path&#x27;</span>, someMiddleware);</span><br></pre></td></tr></table></figure>

<p>上面代码表示，只对根目录的请求，调用某个中间件。<br>因此，上面的代码可以写成下面的样子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>); <span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);<span class="keyword">var</span> app = <span class="title function_">express</span>();app.<span class="title function_">use</span>(<span class="string">&quot;/home&quot;</span>, <span class="keyword">function</span>(<span class="params">request, response, next</span>) &#123;   response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);   response.<span class="title function_">end</span>(<span class="string">&quot;Welcome to the homepage!\n&quot;</span>);&#125;);app.<span class="title function_">use</span>(<span class="string">&quot;/about&quot;</span>, <span class="keyword">function</span>(<span class="params">request, response, next</span>) &#123;   response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);   response.<span class="title function_">end</span>(<span class="string">&quot;Welcome to the about page!\n&quot;</span>);&#125;);app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">request, response</span>) &#123;   response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);   response.<span class="title function_">end</span>(<span class="string">&quot;404 error!\n&quot;</span>);&#125;); http.<span class="title function_">createServer</span>(app).<span class="title function_">listen</span>(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>为什么 JS 是单线程</title>
    <url>/2017/11/29/%E4%B8%BA%E4%BB%80%E4%B9%88JavaScript%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">阮一峰博客链接</a></p>
<h2 id="一、为什么JavaScript是单线程？"><a href="#一、为什么JavaScript是单线程？" class="headerlink" title="一、为什么JavaScript是单线程？"></a>一、为什么JavaScript是单线程？</h2><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<h2 id="二、见博客"><a href="#二、见博客" class="headerlink" title="二、见博客"></a>二、见博客</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>二叉查找树、平衡二叉树、红黑树对比</title>
    <url>/2020/04/26/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<blockquote>
<p>前言：BST、AVL、RBT、B-tree都是动态结构，查找时间基本都在O(longN)数量级上,BST最差的情况会到O(N)。下面做出详细对比。</p>
</blockquote>
<h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 (Binary Search Tree)"></a>二叉查找树 (Binary Search Tree)</h2><p>二叉查找树又称二叉搜索树，二叉排序树，特点如下:</p>
<ol>
<li>左子树上所有结点值均小于根结点</li>
<li>右子树上所有结点值均大于根结点</li>
<li>结点的左右子树本身又是一颗二叉查找树</li>
<li>二叉查找树中序遍历得到结果是递增排序的结点序列。</li>
</ol>
<h3 id="BST-的操作代价分析："><a href="#BST-的操作代价分析：" class="headerlink" title="BST 的操作代价分析："></a>BST 的操作代价分析：</h3><h4 id="1-查找代价："><a href="#1-查找代价：" class="headerlink" title="(1) 查找代价："></a>(1) 查找代价：</h4><p>任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。<br>当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。<br>当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)&#x2F;2，查找的平均时间复杂度在O(N)数量级上。</p>
<h4 id="2-插入代价："><a href="#2-插入代价：" class="headerlink" title="(2) 插入代价："></a>(2) 插入代价：</h4><p>新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。</p>
<span id="more"></span>

<h4 id="3-删除代价："><a href="#3-删除代价：" class="headerlink" title="(3) 删除代价："></a>(3) 删除代价：</h4><p>当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的…的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。</p>
<h3 id="BST效率总结"><a href="#BST效率总结" class="headerlink" title="BST效率总结 :"></a>BST效率总结 :</h3><p>查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。<br>插入删除操作算法简单，时间复杂度与查找差不多。</p>
<h2 id="平衡二叉查找树-Balanced-Binary-Search-Tree"><a href="#平衡二叉查找树-Balanced-Binary-Search-Tree" class="headerlink" title="平衡二叉查找树 ( Balanced Binary Search Tree )"></a>平衡二叉查找树 ( Balanced Binary Search Tree )</h2><p>二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。</p>
<h3 id="AVL-的操作代价分析："><a href="#AVL-的操作代价分析：" class="headerlink" title="AVL 的操作代价分析："></a>AVL 的操作代价分析：</h3><h4 id="1-查找代价：-1"><a href="#1-查找代价：-1" class="headerlink" title="(1) 查找代价："></a>(1) 查找代价：</h4><p>AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。</p>
<h4 id="2-插入代价：-1"><a href="#2-插入代价：-1" class="headerlink" title="(2) 插入代价："></a>(2) 插入代价：</h4><p>AVL必须要保证严格平衡(|bf|&lt;&#x3D;1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。</p>
<h4 id="3-删除代价：-1"><a href="#3-删除代价：-1" class="headerlink" title="(3) 删除代价："></a>(3) 删除代价：</h4><p>AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)&#x3D;O(2logN)</p>
<h3 id="AVL-效率总结"><a href="#AVL-效率总结" class="headerlink" title="AVL 效率总结 :"></a>AVL 效率总结 :</h3><p>查找的时间复杂度维持在O(logN)，不会出现最差情况<br>AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。<br>AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。</p>
<h2 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树 (Red-Black Tree )"></a>红黑树 (Red-Black Tree )</h2><p>二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。但是这样做是否值得呢？<br>能不能找一种折中策略，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率呢？ 答案就是：红黑树。</p>
<h3 id="RBT-的操作代价分析："><a href="#RBT-的操作代价分析：" class="headerlink" title="RBT 的操作代价分析："></a>RBT 的操作代价分析：</h3><h4 id="1-查找代价：-2"><a href="#1-查找代价：-2" class="headerlink" title="(1) 查找代价："></a>(1) 查找代价：</h4><p>由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。</p>
<h4 id="2-插入代价：-2"><a href="#2-插入代价：-2" class="headerlink" title="(2) 插入代价："></a>(2) 插入代价：</h4><p>RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。</p>
<h4 id="3-删除代价：-2"><a href="#3-删除代价：-2" class="headerlink" title="(3) 删除代价："></a>(3) 删除代价：</h4><p>RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</p>
<h3 id="RBT-效率总结"><a href="#RBT-效率总结" class="headerlink" title="RBT 效率总结 :"></a>RBT 效率总结 :</h3><p>查找 效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST。<br>插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>复习二叉树的遍历</title>
    <url>/2020/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="遍历的种类"><a href="#遍历的种类" class="headerlink" title="遍历的种类"></a>遍历的种类</h2><p>二叉树遍历主要分为:</p>
<ul>
<li>深度优先遍历: 先访问子节点，再访问父节点，最后是第二个子节点</li>
<li>广度优先遍历: 先访问第一个子节点，再访问第二个子节点，最后访问父节点</li>
</ul>
<p>其中深度优先遍历又可以根据遍历的顺序分为:</p>
<ul>
<li>前序遍历(Pre-Order Traversal)</li>
<li>中序遍历(In-Order Traversal)</li>
<li>后序遍历(Post-Order Traversal)</li>
</ul>
<span id="more"></span>

<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历:"></a>前序遍历:</h3><p>指先访问根，然后访问子树的遍历方式</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200422151640.png"></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历:"></a>中序遍历:</h3><p>指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200422151730.png"></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历:"></a>后序遍历:</h3><p>指先访问子树，然后访问根的遍历方式</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200422151804.png"></p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历:"></a>广度优先遍历:</h3><p>和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200422152348.png"></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>3DES 加密和 RSA 签名的 JS 实现</title>
    <url>/2017/11/29/%E5%85%B3%E4%BA%8E3DES%E5%8A%A0%E5%AF%86%E5%92%8CRSA%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<h2 id="3DES加密-需要3个显式参数-–只要参数全部相同-3DES加密结果也是相同"><a href="#3DES加密-需要3个显式参数-–只要参数全部相同-3DES加密结果也是相同" class="headerlink" title="3DES加密,需要3个显式参数 –只要参数全部相同,3DES加密结果也是相同"></a>3DES加密,需要3个显式参数 –只要参数全部相同,3DES加密结果也是相同</h2><ul>
<li>待加密数据 data</li>
<li>加密密码 key</li>
<li>偏移量 iv</li>
</ul>
<h3 id="看起来十分简单-但是3DES加密有其他很多种隐式参数"><a href="#看起来十分简单-但是3DES加密有其他很多种隐式参数" class="headerlink" title="看起来十分简单,但是3DES加密有其他很多种隐式参数:"></a>看起来十分简单,但是3DES加密有其他很多种隐式参数:</h3><ul>
<li>mode: CryptoJS.mode.CBC</li>
<li>padding: CryptoJS.pad.Pkcs7</li>
</ul>
<p>mode还有其他的类型,padding也是</p>
<span id="more"></span>

<h2 id="RSA签名-–每次签出来的电子签名都是不一样的"><a href="#RSA签名-–每次签出来的电子签名都是不一样的" class="headerlink" title="RSA签名  –每次签出来的电子签名都是不一样的"></a>RSA签名  –每次签出来的电子签名都是不一样的</h2><p>显式参数有:</p>
<ul>
<li>要发送的数据 data</li>
<li>本地私钥  private_key</li>
</ul>
<p>隐式参数有:</p>
<ul>
<li>签名格式: RSA-MD5、RSA-SHA256</li>
<li>最后要转成什么格式: base64、utf8</li>
</ul>
<h3 id="PHP中使用的OpenSSL-sign使用的私钥是RSA原生的，而Java使用的是PKCS8格式的，这两种格式需要使用OpenSSL客户端转一下，node-js使用的和PHP一样"><a href="#PHP中使用的OpenSSL-sign使用的私钥是RSA原生的，而Java使用的是PKCS8格式的，这两种格式需要使用OpenSSL客户端转一下，node-js使用的和PHP一样" class="headerlink" title="PHP中使用的OpenSSL.sign使用的私钥是RSA原生的，而Java使用的是PKCS8格式的，这两种格式需要使用OpenSSL客户端转一下，node.js使用的和PHP一样"></a>PHP中使用的OpenSSL.sign使用的私钥是RSA原生的，而Java使用的是PKCS8格式的，这两种格式需要使用OpenSSL客户端转一下，node.js使用的和PHP一样</h3><p>这个项目非常小,写下来一个脚本不到100行,却写了我非常的久,原因我分析了一下:</p>
<ol>
<li>放假回来,水平的确下降了非常多,很多都忘了</li>
<li>前期appKey出了点错误,让整个项目停滞了很多天</li>
<li>运维那边太忙,没有时间来帮我配置测试环境,无故浪费很多时间</li>
<li>和第三方交流有代沟,没有能及时的发现问题的真正所在,一直没有发现是RSA私钥的格式问题</li>
<li>自己的集中度不够,经常写一会儿写不出来就去划水</li>
<li>3DES加密和RSA签名之前没有接触过,甚至连签名是干嘛的都不知道,自然会出现一些现在看来很傻的行为</li>
<li>js对这两个算法的支持不是非常友好,尤其是这两个算有很多的变形,例如3DES有很多中mode,padding,RSA需要使用buffer和base64</li>
<li>没有非常认真的去分析问题(如果早一点配好RSA的PHP测试环境,知道自己的RSA签名代码没有问题,就可以模块化,一步步拆分出来,定位bug) –PHP产生的3DES加密后的密文拿来在node环境中跑没有出现问题,可以得出node RSA加密部分代码没有问题,但是换了数据就报55,代表可能是3DES加密有问题,或者3DES加密后的编码格式有问题,分开一步步去测试</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>反向代理与正向代理</title>
    <url>/2019/03/08/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="反向代理与正向代理"><a href="#反向代理与正向代理" class="headerlink" title="反向代理与正向代理"></a>反向代理与正向代理</h1><p>面试中经常会问到 Nginx 的反向代理是什么意思,理解这个问题首先要知道什么是正向代理,反向代理就是正向代理的反方向.</p>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>客户端不直接访问服务器,而是访问代理服务器,代理服务器再去访问服务器,并把结果返回给客户端,这就是正向代理,**发起者也就是需要代理服务的客户端.**比如我们手机或者电脑需要访问外网,这个时候就需要一个能访问外网的代理服务器,也就是 SS 服务器,这个时候SS 对我们来说就是一个正向代理服务,我们访问 SS 服务器,它帮我们去访问外网,再把我们要的资料返回给我们.</p>
<span id="more"></span>

<h3 id="正向代理的用途"><a href="#正向代理的用途" class="headerlink" title="正向代理的用途"></a>正向代理的用途</h3><ol>
<li>访问原来无法访问的资源，如google,公司对外开放的 VPN 服务器</li>
<li>可以做缓存，加速访问资源</li>
<li>对客户端访问授权，上网进行认证(例如网吧,学校)</li>
<li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>
</ol>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>刚好和正向代理相反是就是反向代理,我们搭建反向代理服务器不是为了访问其他服务器,而是为了让其他客户端更好的访问我们自己的服务器.例如负载均衡服务,对外设置一个方向代理服务器,外网客户端访问我们的资源时,方向代理服务器就可以动态的选择客户端访问的内网资源.<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190308162345.png"></p>
<h3 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a>反向代理的用途</h3><ol>
<li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li>
<li>负载均衡，通过反向代理服务器来优化网站的负载</li>
</ol>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>这里用2张图来表达一下<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190308162408.png"></p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/img/20190308162429.jpg"></p>
<h3 id="总结-正向代理代理的对象是客户端，反向代理代理的对象是服务端"><a href="#总结-正向代理代理的对象是客户端，反向代理代理的对象是服务端" class="headerlink" title="总结: 正向代理代理的对象是客户端，反向代理代理的对象是服务端"></a>总结: <strong>正向代理</strong>代理的对象是客户端，<strong>反向代理</strong>代理的对象是服务端</h3>]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 变量驼峰命名转下划线命名</title>
    <url>/2018/05/31/%E5%8F%98%E9%87%8F%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%BD%AC%E4%B8%8B%E5%88%92%E7%BA%BF%E5%91%BD%E5%90%8D%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="JavaScript-变量驼峰命名转下划线命名的一个方法"><a href="#JavaScript-变量驼峰命名转下划线命名的一个方法" class="headerlink" title="JavaScript 变量驼峰命名转下划线命名的一个方法"></a>JavaScript 变量驼峰命名转下划线命名的一个方法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@function</span>  驼峰命名转下划线</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  arg 变量名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">camelToSnake</span> = (<span class="params">arg</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> arg.<span class="title function_">replace</span>(<span class="regexp">/([A-Z])/g</span>, <span class="string">&#x27;_$1&#x27;</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">objCamelToSnake</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span>  newObj  = &#123;&#125;</span><br><span class="line">	<span class="keyword">let</span>  keys  =  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">	keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">keyItem</span>  =&gt;</span> &#123;</span><br><span class="line">		newObj[<span class="variable language_">this</span>.<span class="title function_">camelToSnake</span>(keyItem)] = obj[keyItem]</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span>  newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>对 JS 异步非阻塞的理解</title>
    <url>/2017/11/29/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%20%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<h2 id="同步异步关心的是消息通信机制"><a href="#同步异步关心的是消息通信机制" class="headerlink" title="同步异步关心的是消息通信机制"></a>同步异步关心的是消息通信机制</h2><p>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。<br>而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。<br>例如：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<h3 id="同步异步关心的是结果的返回方式"><a href="#同步异步关心的是结果的返回方式" class="headerlink" title="同步异步关心的是结果的返回方式"></a>同步异步关心的是结果的返回方式</h3><span id="more"></span>
<h2 id="阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态"><a href="#阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态" class="headerlink" title="阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态."></a>阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</h2><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p>
<h3 id="也就是说阻塞与非阻塞关心的是线程发出调用后的状态。挂起还是非挂起。"><a href="#也就是说阻塞与非阻塞关心的是线程发出调用后的状态。挂起还是非挂起。" class="headerlink" title="也就是说阻塞与非阻塞关心的是线程发出调用后的状态。挂起还是非挂起。"></a>也就是说阻塞与非阻塞关心的是线程发出调用后的状态。挂起还是非挂起。</h3><h2 id="在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。"><a href="#在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。" class="headerlink" title="在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。"></a>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</h2><h2 id="总结：同异步是强调你找他还是他完成后来告诉你，阻非阻塞强调是否挂起（你在等待的时候是否可以做其他事）"><a href="#总结：同异步是强调你找他还是他完成后来告诉你，阻非阻塞强调是否挂起（你在等待的时候是否可以做其他事）" class="headerlink" title="总结：同异步是强调你找他还是他完成后来告诉你，阻非阻塞强调是否挂起（你在等待的时候是否可以做其他事）"></a>总结：同异步是强调你找他还是他完成后来告诉你，阻非阻塞强调是否挂起（你在等待的时候是否可以做其他事）</h2><h3 id="阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式"><a href="#阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式" class="headerlink" title="阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式"></a>阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式</h3><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>同步阻塞：你打电话问老板有没有某书，老板去查，在老板给你结果之前，你一直拿着电话等待老板给你结果，你此时什么也干不了。<br>同步非阻塞：你打电话过去后，在老板给你结果之前，你拿着电话等待老板给你结果，但是你拿着电话等的时候可以干一些其他事，比如嗑瓜子。<br>异步阻塞：你打电话过去后，老板去查，你挂掉电话，等待老板给你打电话通知你，这是异步，你挂了电话后还是啥也干不了，只能一直等着老板给你打电话告诉你结果，这是阻塞。<br>异步非阻塞：你打电话过去后，你就挂了电话，然后你就想干嘛干嘛去。只用时不时去看看老板给你打电话没。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>时间格式转化</title>
    <url>/2017/11/27/%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E6%88%90%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="使用-moment-包-官网地址链接"><a href="#使用-moment-包-官网地址链接" class="headerlink" title="使用 moment 包,官网地址链接"></a>使用 moment 包,官网地址<a href="http://momentjs.cn/">链接</a></h1><h2 id="将时间戳转换成日期格式："><a href="#将时间戳转换成日期格式：" class="headerlink" title="将时间戳转换成日期格式："></a>将时间戳转换成日期格式：</h2><blockquote>
<p>简单的一句代码<br><code>var date = new Date(时间戳); //获取一个时间对象 </code></p>
</blockquote>
<span id="more"></span>
<p>注意：如果是uinx时间戳记得乘于1000。比如php函数time()获得的时间戳就要乘于1000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*----------下面是获取时间日期的方法，需要什么样的格式自己拼接起来就好了----------*/</span><br><span class="line">date.getFullYear();//获取完整的年份(4位,1970)</span><br><span class="line">date.getMonth();//获取月份(0-11,0代表1月,用的时候记得加上1)</span><br><span class="line">date.getDate();//获取日(1-31)</span><br><span class="line">date.getTime();//获取时间(从1970.1.1开始的毫秒数)</span><br><span class="line">date.getHours();//获取小时数(0-23)</span><br><span class="line">date.getMinutes();//获取分钟数(0-59)</span><br><span class="line">date.getSeconds();//获取秒数(0-59)</span><br><span class="line">//更多好用的方法可以到这查找 -&gt; http://www.w3school.com.cn/jsref/jsref_obj_date.asp</span><br><span class="line">// 例子，比如需要这样的格式：yyyy-MM-dd hh:mm:ss</span><br><span class="line">var date = new Date(1398250549490);</span><br><span class="line">Y = date.getFullYear() + &#x27;-&#x27;;</span><br><span class="line">M = (date.getMonth()+1 &lt; 10 ? &#x27;0&#x27;+(date.getMonth()+1) : date.getMonth()+1) + &#x27;-&#x27;;</span><br><span class="line">D = date.getDate() + &#x27; &#x27;;</span><br><span class="line">h = date.getHours() + &#x27;:&#x27;;</span><br><span class="line">m = date.getMinutes() + &#x27;:&#x27;;</span><br><span class="line">s = date.getSeconds(); </span><br><span class="line">console.log(Y+M+D+h+m+s); //呀麻碟</span><br><span class="line">//输出结果：2014-04-23 18:55:49</span><br></pre></td></tr></table></figure>

<h2 id="将日期格式转换成时间戳："><a href="#将日期格式转换成时间戳：" class="headerlink" title="将日期格式转换成时间戳："></a>将日期格式转换成时间戳：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 也很简单</span><br><span class="line">date = new Date(&#x27;2014-04-23 18:55:49:123&#x27;);</span><br><span class="line">//传入一个时间格式，如果不传入就是获取现在的时间了，就这么简单。</span><br><span class="line">// 有三种方式获取</span><br><span class="line">time1 = date.getTime()</span><br><span class="line">time2 = date.valueOf()</span><br><span class="line">time3 = Date.parse(date)</span><br><span class="line">// 三种获取的区别</span><br><span class="line">第一、第二种：会精确到毫秒</span><br><span class="line">第三种：只能精确到秒，毫秒将用0来代替</span><br><span class="line">// 比如上面代码输出的结果(一眼就能看出区别)：</span><br><span class="line">//    1398250549123</span><br><span class="line">//    1398250549123</span><br><span class="line">//    1398250549000</span><br></pre></td></tr></table></figure>
<p>注意：获取到的时间戳除于1000就可以获得unix的时间戳了，在传值给PHP时用得到。</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>JS 异步编程解决方案</title>
    <url>/2017/11/29/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="首先是使用Promise。Promise是为了能更好的管理回调函数。"><a href="#首先是使用Promise。Promise是为了能更好的管理回调函数。" class="headerlink" title="首先是使用Promise。Promise是为了能更好的管理回调函数。"></a>首先是使用Promise。Promise是为了能更好的管理回调函数。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>()</span><br><span class="line">    <span class="title function_">resolve</span>(data)<span class="comment">//成功</span></span><br><span class="line">    <span class="title function_">reject</span>(data)<span class="comment">//失败</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这里的resolve和reject的data是返回给.then(data)中的data，意思就和return数据给下一个函数作为参数一样。完成链式调用。比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">func</span>(val).<span class="title function_">then</span>(<span class="function"><span class="params">dat</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//这里的dat就是resolve来的data</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//而reject的错误一般是用.catch()捕获然后再处理，也可以在catch里继续reject(err)给后面.catch(err)来处理。</span></span><br></pre></td></tr></table></figure>

<p><strong>不要在循环内部直接做异步操作，否则根本拿不到数据，循环就结束了</strong><br>如果一定要做循环可以使用async.each或者使用Promise.all()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">each</span>(record, <span class="function">(<span class="params">item, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">  result.<span class="property">title</span> = item.<span class="title function_">get</span>(<span class="string">&#x27;auction&#x27;</span>).<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>);</span><br><span class="line">  result.<span class="property">imgUrls</span> = item.<span class="title function_">get</span>(<span class="string">&#x27;auction&#x27;</span>).<span class="title function_">get</span>(<span class="string">&#x27;imgUrls&#x27;</span>);</span><br><span class="line">  <span class="title function_">find</span>(item.<span class="title function_">get</span>(<span class="string">&#x27;auction&#x27;</span>).<span class="title function_">get</span>(<span class="string">&#x27;objectId&#x27;</span>))<span class="comment">//把异步操作封装成一个Promise的方法对象</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">userId</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (userId === item.<span class="title function_">get</span>(<span class="string">&#x27;userId&#x27;</span>)) &#123;</span><br><span class="line">        result.<span class="property">status</span> = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.<span class="property">status</span> = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="property">heyzNum</span> = item.<span class="title function_">get</span>(<span class="string">&#x27;heyzNum&#x27;</span>);</span><br><span class="line">      result.<span class="property">time</span> = <span class="title function_">formatTime</span>(item.<span class="title function_">get</span>(<span class="string">&#x27;createdAt&#x27;</span>));</span><br><span class="line">      data.<span class="title function_">push</span>(result);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用Promise.all<br>但是如果这个promise队列里出现了reject，那么Promise.all()返回的结果会被一个reject而报销（其他正常返回也没用了）<br>Promise.all会把参数数组里的每个Promise的resolve都返回给下来then(results &#x3D;&gt; {})中的results，会按顺序输出，以最后一个Promise完成为标志，进入then()<br><strong>如果放在 Promise.all(promiseArr)中的 Promise 没有resolve, 那么 Promise.all 也无法运行</strong><br><a href="http://www.cnblogs.com/lvdabao/p/es6-promise-1.html">Promise例子</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getActivitiesByCouponsAndModel</span> = (<span class="params">activityModel</span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, activityModel);</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; activityModel.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(<span class="title function_">mixCouponInfoById</span>(activityModel[i].<span class="property">couponLists</span>, newObj[i]));<span class="comment">//mixCouponInfoById也是个返回Promise对象的方法，然后把Promise对象全部push到数组里。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(result)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="title function_">resolve</span>(&#123;</span><br><span class="line">      <span class="attr">success</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">data</span>: r</span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">reject</span>(&#123;</span><br><span class="line">      <span class="attr">error</span>: <span class="number">500</span>,</span><br><span class="line">      <span class="attr">message</span>: e</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="总的来说，async-each的逻辑更符合同步编程的逻辑，promise-all呢返回的是之前promises数组分别执行完的结果的数组，在后续的数据处理上可能比较麻烦"><a href="#总的来说，async-each的逻辑更符合同步编程的逻辑，promise-all呢返回的是之前promises数组分别执行完的结果的数组，在后续的数据处理上可能比较麻烦" class="headerlink" title="总的来说，async.each的逻辑更符合同步编程的逻辑，promise.all呢返回的是之前promises数组分别执行完的结果的数组，在后续的数据处理上可能比较麻烦"></a>总的来说，async.each的逻辑更符合同步编程的逻辑，promise.all呢返回的是之前promises数组分别执行完的结果的数组，在后续的数据处理上可能比较麻烦</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>微服务架构</title>
    <url>/2021/06/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h1><p>微服务没有一个明确的定义,只能通过和传统的服务对比,才比较好理解什么是微服务.<br>传统服务是将绝大多数的业务 api 都集成在一个工程里.</p>
<h2 id="优点是"><a href="#优点是" class="headerlink" title="优点是:"></a>优点是:</h2><ol>
<li>开发简单直接，集中式管理</li>
<li>基本不会重复开发</li>
<li>功能都在本地，没有分布式的管理开销和调用开销</li>
</ol>
<h2 id="但是同样的-缺点也很多"><a href="#但是同样的-缺点也很多" class="headerlink" title="但是同样的,缺点也很多:"></a>但是同样的,缺点也很多:</h2><ol>
<li>开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断</li>
<li>代码维护难：代码功能耦合在一起，新人不知道何从下手</li>
<li>部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</li>
<li>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉</li>
<li>扩展性不够：无法满足高并发情况下的业务需求</li>
</ol>
<p>所以对比之下就有了微服务架构.其思路大致上来说,就是将原来庞大的工程拆分成n 个小的,互相连接的工程.<br>比如原来是整个电商系统的后端服务,现在拆分成:</p>
<ul>
<li>用户服务</li>
<li>商品服务</li>
<li>订单服务</li>
<li>物流服务</li>
<li>等等…</li>
</ul>
<span id="more"></span>

<p>不同的业务访问不同的服务,听起来似乎对前端很不友好,不同的业务我需要请求不同的服务器,其实不是的,在这些微服务之前,还有一个 api-gateway 来负责服务路由、负载均衡、缓存、访问控制和鉴权等任务,对前端来说整个架构就是透明的.</p>
<h2 id="整体架构图大致上是这样"><a href="#整体架构图大致上是这样" class="headerlink" title="整体架构图大致上是这样"></a>整体架构图大致上是这样</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210608145148.png"></p>
<h1 id="微服务有什么优点"><a href="#微服务有什么优点" class="headerlink" title="微服务有什么优点"></a>微服务有什么优点</h1><p>微服务架构有很多重要的优点。</p>
<ol>
<li><p>它解决了复杂性问题。它将单体应用分解为一组服务。虽然功能总量不变，但应用程序已被分解为可管理的模块或服务。这些服务定义了明确的RPC或消息驱动的API边界。微服务架构强化了应用模块化的水平，而这通过单体代码库很难实现。因此，微服务开发的速度要快很多，更容易理解和维护。</p>
</li>
<li><p>这种体系结构使得每个服务都可以由专注于此服务的团队独立开发。只要符合服务API契约，开发人员可以自由选择开发技术。这就意味着开发人员可以采用新技术编写或重构服务，由于服务相对较小，所以这并不会对整体应用造成太大影响。</p>
</li>
<li><p>微服务架构可以使每个微服务独立部署。开发人员无需协调对服务升级或更改的部署。这些更改可以在测试通过后立即部署。所以微服务架构也使得CI／CD成为可能。</p>
</li>
<li><p>微服务架构使得每个服务都可独立扩展。我们只需定义满足服务部署要求的配置、容量、实例数量等约束条件即可。比如我们可以在EC2计算优化实例上部署CPU密集型服务，在EC2内存优化实例上部署内存数据库服务。</p>
</li>
</ol>
<h1 id="微服务有什么缺点"><a href="#微服务有什么缺点" class="headerlink" title="微服务有什么缺点"></a>微服务有什么缺点</h1><p>微服务的缺点主要是系统整体比较复杂,服务之间需要互相调用或者通信,并且对这些服务进行监控与管理.</p>
<ol>
<li>API Gateway</li>
<li>服务间调用</li>
<li>服务发现</li>
<li>服务容错</li>
<li>服务部署</li>
<li>数据调用</li>
</ol>
<h1 id="所以我们需要一个工具来做弥补缺点"><a href="#所以我们需要一个工具来做弥补缺点" class="headerlink" title="所以我们需要一个工具来做弥补缺点"></a>所以我们需要一个工具来做弥补缺点</h1><p>微服务的缺点并不是无法解决的,我们可以使用一套工具或者框架来去管理我们的微服务.<br>比如使用:Service Mesh<br>现在 docker 的使用变得越来越成熟,而容器非常的切合微服务的理念.加上使用 K8S 做容器的管理,再使用其他工具做 Service Mesh. 整个系统都会变得有序且可控.</p>
<p>系统结构<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210608160141.png"></p>
<h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h1><p>Istio是一个用来连接、管理和保护微服务的开放平台。Istio提供一种简单的方式来建立已部署服务网络，具备负载均衡、服务间认证、监控等功能，而不需要改动任何服务代码。想要为服务增加对Istio的支持，您只需要在环境中部署一个特殊的边车（sidecar），使用Istio控制面板功能配置和管理代理，拦截微服务之间的所有网络通信。</p>
<p>Istio提供了一个完整的解决方案，通过为整个服务网格提供行为洞察和操作控制来满足微服务应用程序的多样化需求。它在服务网络中统一提供了许多关键功能：</p>
<ul>
<li>流量管理：控制服务之间的流量和API调用的流向，使得调用更可靠，并使网络在恶劣情况下更加健壮。</li>
<li>可观察性：了解服务之间的依赖关系，以及它们之间流量的本质和流向，从而提供快速识别问题的能力。</li>
<li>策略执行：将组织策略应用于服务之间的互动，确保访问策略得以执行，资源在消费者之间良好分配。策略的更改是通过配置网格而不是修改应用程序代码。</li>
<li>服务身份和安全：为网格中的服务提供可验证身份，并提供保护服务流量的能力，使其可以在不同可信度的网络上流转。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://dockone.io/article/3687">一篇文章快速理解微服务架构</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>环境配置</title>
    <url>/2017/11/29/%E6%96%B0%E4%BA%BA%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="编程环境"><a href="#编程环境" class="headerlink" title="编程环境"></a>编程环境</h2><ul>
<li>brew</li>
<li>nvm</li>
<li>node</li>
<li>npm</li>
</ul>
<ol>
<li>首先安装Homebrew。brew是一个通过命令行安装各种软件的程序。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>

<p>设置 brew 中科大源</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">替换brew.git:</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line">替换homebrew-core.git:</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>brew install **   安装软件</p>
<p>brew list           列出已安装的软件</p>
<p>brew update     更新brew</p>
<p>brew home       用浏览器打开brew的官方网站</p>
<p>brew info          显示软件信息</p>
<p>brew deps        显示包依赖</p>
</blockquote>
<ol start="2">
<li>后端Node.js安装，推荐使用NVM（node version management）安装</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启终端，命令行下即可使用nvm，使用<code>nvm install &lt;versions&gt; </code>进行对应的node版本安装。使用<code>nvm use </code>使用， 再通过<code>nvm alias default </code>确保有默认版本。最后使用<code>nvm ls</code>查看。</p>
</blockquote>
<ol start="3">
<li>使用npm安装各种包工具</li>
</ol>
<blockquote>
<p>npm install  等等</p>
</blockquote>
<h2 id="GIT-使用"><a href="#GIT-使用" class="headerlink" title="GIT 使用"></a>GIT 使用</h2><p>使用brew安装git</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>

<p>使用github管理项目代码，而且github还不止能管理代码，还可以在github上提issue，然后assign给团队里的人，github绑定了以后还可以接收到邮件，当然可以筛选掉，在<code>github-&gt;setting-&gt;Notifications</code><a href="https://github.com/settings/notifications">链接</a>里。</p>
<p>这里还要了解一下git workflow，而具体的任务应该是hot-fix还是release又或者是feature，这要具体任务具体分析。</p>
<p>git流程：找到指定的分支，然后创建一个新feature或者hot-fix的分支，如果在代码完成之前，之前的分支已经发生改变，就需要执行<code>git rebase</code>,把原分支的更改同步到当前分支.之后再提Pull Requests,让leader做code review,通过以后就可以做merge.</p>
<p><strong>由于开启了二步验证，github无法再通过HTTPS协议clone项目，只能通过SSH clone。具体如何添加SSH<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">戳这里</a></strong></p>
<h2 id="Waffle-io任务安排"><a href="#Waffle-io任务安排" class="headerlink" title="Waffle.io任务安排"></a>Waffle.io任务安排</h2><p>一个使用 kanban workflow 的平台。需要找leader或者相关的人把你拉入你的小组，之后你就可以在主界面里看到整个小组的所有任务以及任务的进度。你也可以选择只看assign自己的任务，并且在完成一个进度的时候拖动任务板块到它正处于的进度，方便小组其他成员了解进度。</p>
<h3 id="正规的流程："><a href="#正规的流程：" class="headerlink" title="正规的流程："></a>正规的流程：</h3><ol>
<li>在planning的时候收到任务</li>
<li>PM或者PM助理会在github上把任务assign给你，你可以在waffle上看到，然后自己安排优先级。</li>
<li>之后就是自己的编码，按照gitworkflow，自己创建分支。</li>
<li>在编码完成后，先找leader code review，完成以后提交一个Pull requests，等待CI测试通过。</li>
<li>如果测试通过，就提交merge request，不通过当然就是继续测试代码。</li>
<li>在这个过程中也要在waffle上相应的拖动任务板块</li>
</ol>
<h2 id="二步验证"><a href="#二步验证" class="headerlink" title="二步验证"></a>二步验证</h2><p>出于安全的角度，公司采用手机App二步验证。就是在账号密码确认之后，再输入一个每分钟都会自动更新的6位数字密码。这个二步验证在github，Gmail，slack上都要开启，iOS平台推荐使用Authy这个软件（App store），这个软件可以在Widget栏里直接看到密码，而且可以一键复制，再配合PIN同步黏贴栏，就可以直接在电脑在黏贴6位密码。</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Google 配置 SS</title>
    <url>/2018/05/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%20SS/</url>
    <content><![CDATA[<h2 id="一、创建实例"><a href="#一、创建实例" class="headerlink" title="一、创建实例"></a>一、创建实例</h2><ol>
<li>在左侧的菜单中找到 <a href="https://console.cloud.google.com/compute/instances">计算引擎 –  VM 实例</a></li>
<li>通过 创建实例 或者单击加号来创建一个虚拟机。</li>
</ol>
<ul>
<li>名字：随意</li>
<li>地区： 建议asia-east1-c（台湾）</li>
<li>机器类型：建议微型或者小型（看用户量）</li>
<li>启动磁盘单击更改 – Ubuntu 16.04 LTS</li>
<li>防火墙：允许HTTP流量，允许HTTPS流量</li>
</ul>
<h2 id="二、初步配置"><a href="#二、初步配置" class="headerlink" title="二、初步配置"></a>二、初步配置</h2><ol>
<li><p>左侧导航 – 计算 – 网络</p>
</li>
<li><p>外部IP地址 – 选择一个ip – 类型调整为静态</p>
</li>
<li><p>防火墙规则 – 创建防火墙规则（未提及的全部默认）：流量方向入站、来源ip地址<code>0.0.0.0/0</code>、协议和端口<code>全部允许</code></p>
</li>
<li><p>防火墙规则 – 创建防火墙规则（未提及的全部默认）：流量方向出站、来源ip地址<code>0.0.0.0/0</code>、协议和端口<code>全部允许</code>（注意要创建两次防火墙规则，一次出站，一次入站）</p>
<span id="more"></span>
<h2 id="三、配置-SS-以及-BBR"><a href="#三、配置-SS-以及-BBR" class="headerlink" title="三、配置 SS 以及 BBR"></a>三、配置 SS 以及 BBR</h2></li>
<li><p>进入实例控制台 – SSH – 在浏览器窗口中打开</p>
</li>
<li><p>获取root权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su </span><br></pre></td></tr></table></figure></li>
<li><p>安装SS（根据脚本提示来）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure>
<blockquote>
<p>服务器端口：默认为 8989(都可在配置时命令行中修改)<br>密码：默认为 teddysun.com<br>加密方式：默认为 aes-256-cfb<br>协议（Protocol）：默认为 origin<br>混淆（obfs）：默认为 plain</p>
</blockquote>
</li>
<li><p>安装BBR加速：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写入配置</span><br><span class="line"></span><br><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">配置生效</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line">检验</span><br><span class="line"></span><br><span class="line">lsmod | grep bbr</span><br><span class="line">看到回显tcp_bbr 20480 0说明已经成功开启 BBR</span><br><span class="line">不需要重新启动</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置VM实例，完成配置</p>
</li>
</ol>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>添加2个SSH-key</title>
    <url>/2016/11/29/%E6%B7%BB%E5%8A%A02%E4%B8%AASSH-key/</url>
    <content><![CDATA[<h2 id="在使用生成SSH指令的时候-在第一条命令时可修改路径和文件名-没有后缀的是密匙-添加到本地的ssh-agent后缀-pub的是公匙-添加到github或者gitlab上"><a href="#在使用生成SSH指令的时候-在第一条命令时可修改路径和文件名-没有后缀的是密匙-添加到本地的ssh-agent后缀-pub的是公匙-添加到github或者gitlab上" class="headerlink" title="在使用生成SSH指令的时候,在第一条命令时可修改路径和文件名,没有后缀的是密匙,添加到本地的ssh-agent后缀.pub的是公匙,添加到github或者gitlab上."></a>在使用生成SSH指令的时候,在第一条命令时可修改路径和文件名,没有后缀的是密匙,添加到本地的ssh-agent后缀.pub的是公匙,添加到github或者gitlab上.</h2><h3 id="重点在于ssh-agent-首先打开ssh-agent"><a href="#重点在于ssh-agent-首先打开ssh-agent" class="headerlink" title="重点在于ssh-agent,首先打开ssh-agent"></a>重点在于ssh-agent,首先打开ssh-agent</h3><blockquote>
<p>ssh-agent bash</p>
</blockquote>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><blockquote>
<p>ssh-add ~&#x2F;.ssh&#x2F;文件名                    &#x2F;&#x2F;没有后缀的那个</p>
</blockquote>
<span id="more"></span>
<h3 id="最后一步-添加config文件-文件名就叫config"><a href="#最后一步-添加config文件-文件名就叫config" class="headerlink" title="最后一步,添加config文件,文件名就叫config"></a>最后一步,添加config文件,文件名就叫config</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gitlab</span><br><span class="line">    Host gitlab         //测试的时候输入的地址</span><br><span class="line">        HostName gitlab.lingxi.co           //网址</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/gitlab          //文件路径</span><br><span class="line">        User huangweilong            </span><br><span class="line"></span><br><span class="line"># github            </span><br><span class="line">    Host github</span><br><span class="line">        HostName github.com</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/github_5077foxmail</span><br><span class="line">        User hwl5077@foxmail.com</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="好了-测试一下通过与否-当然前提是github和gitlab上都已经绑定好了"><a href="#好了-测试一下通过与否-当然前提是github和gitlab上都已经绑定好了" class="headerlink" title="好了,测试一下通过与否,当然前提是github和gitlab上都已经绑定好了"></a>好了,测试一下通过与否,当然前提是github和gitlab上都已经绑定好了</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github            </span><br><span class="line">ssh -T git@gitlab</span><br></pre></td></tr></table></figure>
<p>这里@后面的就是config文件里的HOST</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>短链接算法</title>
    <url>/2019/07/04/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>分享到微博或者推特都有 140 字的限制,所以最近产品提出一个分享 URL 要做成短链接的需求,便在网上查询了一下资料,综合下来,总结了几种算法.</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>总的来说就是把长的 URL 通过一个算法得出一个 6 位左右的短链,再把这个映射关系保存起来,下次有用户访问短链的时候我们能找到他对应的长链.并通过301 或者 302 重定向到原来的 URL 上.</p>
<h2 id="1-自增-id-转-62-进制"><a href="#1-自增-id-转-62-进制" class="headerlink" title="1. 自增 id 转 62 进制"></a>1. 自增 id 转 62 进制</h2><p>从数据库或者 redis 里取一个自增数据,然后十进制转化成 62 进制,这样短链就永远不会重复,适合于原始 URL 1 对多的情况,也就是一个长链接每次分享都生成不一样的短链接.<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190704142037.png"><br>就算是一亿对应的 62 进制数也就是 6LAze,短短的 5 位.<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190709114800.jpg"></p>
<p>最小的 7 位 62 进制数对应的十进制数是 56800235584,五百六十八亿多,远超当前的所有URL 总和.所以 6 位数的 62 进制是肯定够用的.</p>
<span id="more"></span>
<h3 id="为什么是-62-进制"><a href="#为什么是-62-进制" class="headerlink" title="为什么是 62 进制?"></a>为什么是 62 进制?</h3><p>因为用 0-9 a-z A-Z刚好是 62 位,如果用 64 位就可能会产生&#x2F;或者+,这在 URL 解析的时候可能会发生问题,所以使用 62 进制更加安全</p>
<h2 id="2-哈希值截取"><a href="#2-哈希值截取" class="headerlink" title="2. 哈希值截取"></a>2. 哈希值截取</h2><p>这个方法比较简单,直接对 URL 进行哈希计算,然后取其中的 6 位.这种算法可能会出现重复,所以算出来后需要对数据库进行一次碰撞,如果重复一次.直到数据库里没有,即为短连接.这种方法有点在于快捷而且算法很简单.适合数据量比较小的服务.</p>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>长链到锻炼映射关系需要存储起来.<br>短链到长链的映射肯定是需要用 redis 这样的高速缓存来做,因为页面的访问频率肯定会比较高,如果全部存在数据库里,当用户量比较大时,大量数据库连接会让数据库变得非常慢,甚至挂掉.如果需要做到持久化,也就是这个短链永久有效的话,那还是需要存一份数据库,当redis 找不到时,再去查数据库.</p>
<h1 id="为什么要用-301-跳转而不是-302？"><a href="#为什么要用-301-跳转而不是-302？" class="headerlink" title="为什么要用 301 跳转而不是 302？"></a>为什么要用 301 跳转而不是 302？</h1><p>301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。<br>但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择302虽然会增加服务器压力，但是我想是一个更好的选择。</p>
<h1 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h1><p>如果是长链一对多的情况,那黑客进行大量的请求,很可能会快速消耗短链个数,那可以结合一对多和一对一的策略,在生成锻炼的逻辑中,存储长链到短链的 redis 记录,并设置一个比较短的过期时间,比如 10 分钟,用LRU机制进行淘汰.在生成之前先查询一次redis,如果存在则直接返回短链,并刷新过期时间,如果不存在再去生成.</p>
<blockquote>
<p><a href="https://hufangyun.com/2017/short-url/">参考博客</a><br><a href="https://www.zhihu.com/question/20103344">知乎</a></p>
</blockquote>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>神奇的 null &gt;= 0</title>
    <url>/2019/06/27/%E7%A5%9E%E5%A5%87%E7%9A%84%20null%20%3E=%200/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天在写代码的时候遇到一个 bug,价格竟然显示了 null.非常莫名其妙,我明明做了错误处理,打断点之后发现问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (item.<span class="property">customPrice</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    item.<span class="property">price</span> = item.<span class="property">customPrice</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    item.<span class="property">price</span> = <span class="number">10</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>也就是说 item.customPrice 需要是数字且大于等于0,才会赋值给price,否则会调用默认值.<br>但是我发现当 customPrice &#x3D; null 时这个判断也会为真值,此时 item.price &#x3D; null;</p>
<h2 id="null-gt-x3D-0-那-null-x3D-x3D-0"><a href="#null-gt-x3D-0-那-null-x3D-x3D-0" class="headerlink" title="null &gt;&#x3D; 0?那 null &#x3D;&#x3D; 0?"></a>null &gt;&#x3D; 0?那 null &#x3D;&#x3D; 0?</h2><p>我用 Chrome 的 console 写了几个判断</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20190627150832.png"><br>发现只有 <code>null &gt;= 0</code> 和 <code>null &lt;= 0</code>的判断为真值,其他都是 false</p>
<h2 id="查资料"><a href="#查资料" class="headerlink" title="查资料"></a>查资料</h2><p>如果想明确，这个问题具体是怎么回事，那么我们需要重新来回顾一下我们的 ECMAScript Language Specification (HTML version)，翻译过来就是ECMAScript语言规范(HTML版本)。</p>
<h3 id="内部相等性运算算法"><a href="#内部相等性运算算法" class="headerlink" title="内部相等性运算算法"></a>内部相等性运算算法</h3><p>首先我们来看一下 ES3 关于 内部相等性运算的算法实现。</p>
<span id="more"></span>
<blockquote>
<p>11.9.3 The Abstract Equality Comparison Algorithm<br>The comparison x &#x3D;&#x3D; y, where x and y are values, produces true or false. Such a comparison is performed as follows:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If Type(x) is different from Type(y), go to step 14.</span><br><span class="line">If Type(x) is Undefined, return true.</span><br><span class="line"></span><br><span class="line">If Type(x) is Null, return true.</span><br><span class="line"></span><br><span class="line">If Type(x) is not Number, go to step 11.</span><br><span class="line">If x is NaN, return false.</span><br><span class="line">If y is NaN, return false.</span><br><span class="line">If x is the same number value as y, return true.</span><br><span class="line">If x is +0 and y is -0, return true.</span><br><span class="line">If x is -0 and y is +0, return true.</span><br><span class="line">Return false.</span><br><span class="line"></span><br><span class="line">If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return false.</span><br><span class="line"></span><br><span class="line">If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false.</span><br><span class="line">Return true if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return false.</span><br><span class="line"></span><br><span class="line">If x is null and y is undefined, return true.</span><br><span class="line">If x is undefined and y is null, return true.</span><br><span class="line">If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y).</span><br><span class="line">If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x)== y.</span><br><span class="line">If Type(x) is Boolean, return the result of the comparison ToNumber(x)== y.</span><br><span class="line">If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).</span><br><span class="line">If Type(x) is either String or Number and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).</span><br><span class="line">If Type(x) is Object and Type(y) is either String or Number, return the result of the comparison ToPrimitive(x)== y.</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure>

<h3 id="内部关系运算算法"><a href="#内部关系运算算法" class="headerlink" title="内部关系运算算法"></a>内部关系运算算法</h3><p>接下来我们再来看一下 ES3 关于 内部关系运算的算法实现。</p>
<blockquote>
<p>11.8.5 The Abstract Relational Comparison Algorithm<br>The comparison x &lt; y, where x and y are values, produces true, false, or undefined (which indicates that at least one operand is NaN). Such a comparison is performed as follows:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Call ToPrimitive(x, hint Number).**</span><br><span class="line">Call ToPrimitive(y, hint Number).**</span><br><span class="line">If Type(Result(1)) is String and Type(Result(2)) is String, go to step 16. (Note that this step differs from step 7 in the algorithm for the addition operator **+</span><br><span class="line">** in using and instead of or.)</span><br><span class="line">Call ToNumber(Result(1)).</span><br><span class="line">Call ToNumber(Result(2)).</span><br><span class="line">If Result(4) is NaN, return undefined.</span><br><span class="line">If Result(5) is NaN, return undefined.</span><br><span class="line">If Result(4) and Result(5) are the same number value, return false.</span><br><span class="line"></span><br><span class="line">If Result(4) is +0 and Result(5) is -0, return false.</span><br><span class="line">If Result(4) is -0 and Result(5) is +0, return false.</span><br><span class="line">If Result(4) is +∞, return false.</span><br><span class="line">If Result(5) is +∞, return true.</span><br><span class="line">If Result(5) is -∞, return false.</span><br><span class="line">If Result(4) is -∞, return true.</span><br><span class="line">If the mathematical value of Result(4) is less than the mathematical value of Result(5) --- note that these mathematical values are both finite and not both zero --- return true. Otherwise, return false.</span><br><span class="line">If Result(2) is a prefix of Result(1), return false. (A string value p is a prefix of string value q if q can be the result of concatenating p and some other stringr. Note that any string is a prefix of itself, because r may be the empty string.)</span><br><span class="line">If Result(1) is a prefix of Result(2), return true.</span><br><span class="line"></span><br><span class="line">Let k be the smallest nonnegative integer such that the character at position k within Result(1) is different from the character at position k within Result(2). (There must be such a k, for neither string is a prefix of the other.)</span><br><span class="line">Let m be the integer that is the code point value for the character at position k within Result(1).</span><br><span class="line">Let n be the integer that is the code point value for the character at position k within Result(2).</span><br><span class="line">If m &lt; n, return true. Otherwise, return false.</span><br></pre></td></tr></table></figure>

<h3 id="ES3-的-运算符"><a href="#ES3-的-运算符" class="headerlink" title="ES3 的 运算符"></a>ES3 的 运算符</h3><h4 id="ES3-的-“-gt-”-运算符"><a href="#ES3-的-“-gt-”-运算符" class="headerlink" title="ES3 的 “&gt;” 运算符:"></a>ES3 的 “&gt;” 运算符:</h4><blockquote>
<p>The Greater-than Operator ( &gt; )<br>The production RelationalExpression :<br>RelationalExpression &gt; ShiftExpression is evaluated as follows:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Evaluate RelationalExpression.</span><br><span class="line">Call GetValue(Result(1)).</span><br><span class="line">Evaluate ShiftExpression.</span><br><span class="line">Call GetValue(Result(3)).</span><br><span class="line">**Perform the comparison Result(4) &lt; Result(2). **</span><br><span class="line">If Result(5) is undefined, return false. Otherwise, return Result(5).</span><br></pre></td></tr></table></figure>

<h4 id="ES3-的”-gt-x3D-”-运算符"><a href="#ES3-的”-gt-x3D-”-运算符" class="headerlink" title="ES3 的”&gt;&#x3D;” 运算符:"></a>ES3 的”&gt;&#x3D;” 运算符:</h4><blockquote>
<p>The Greater-than-or-equal Operator ( &gt;&#x3D; )<br>The production RelationalExpression :<br>RelationalExpression &gt;&#x3D; ShiftExpression is evaluated as follows:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Evaluate RelationalExpression.</span><br><span class="line">Call GetValue(Result(1)).</span><br><span class="line">Evaluate ShiftExpression.</span><br><span class="line">Call GetValue(Result(3)).</span><br><span class="line">Perform the comparison Result(2) &lt; Result(4). (see 11.8.5).</span><br><span class="line">If Result(5) is true or undefined, return false. Otherwise, return true.</span><br></pre></td></tr></table></figure>

<h4 id="ES3-的-“-x3D-x3D-”-运算符"><a href="#ES3-的-“-x3D-x3D-”-运算符" class="headerlink" title="ES3 的 “&#x3D;&#x3D;” 运算符 :"></a>ES3 的 “&#x3D;&#x3D;” 运算符 :</h4><blockquote>
<p>The Equals Operator ( &#x3D;&#x3D; )<br>The production EqualityExpression :<br>EqualityExpression &#x3D;&#x3D; RelationalExpression is evaluated as<br>follows:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Evaluate EqualityExpression.</span><br><span class="line">Call GetValue(Result(1)).</span><br><span class="line">Evaluate RelationalExpression.</span><br><span class="line">Call GetValue(Result(3)).</span><br><span class="line">Perform the comparison Result(4) == Result(2). (see 11.9.3).</span><br><span class="line">Return Result(5).</span><br></pre></td></tr></table></figure>

<h2 id="根据资料得出的内容"><a href="#根据资料得出的内容" class="headerlink" title="根据资料得出的内容"></a>根据资料得出的内容</h2><p>着重看一下，上面特意加粗的地方，我们可以明确下面三件事。</p>
<p>关系运算符 和 相等运算符 并不是一个类别的.<br>关系运算符,在设计上,总是需要运算元尝试转为一个number . 而相等运算符在设计上,则没有这方面的考虑.<br>最重要的一点, 不要把 拿 a &gt; b ,  a &#x3D;&#x3D; b 的结果 想当然的去和 a &gt;&#x3D; b 建立联系. 正确的符合最初设计思想的关系是  a &gt; b 与 a &gt;&#x3D; b是一组 . a &#x3D;&#x3D; b 和其他相等运算符才是一组. 比如  a &#x3D;&#x3D;&#x3D; b , a !&#x3D; b, a !&#x3D;&#x3D; b .</p>
<p>那么我们就可以反过来看这个问题了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> &gt; <span class="number">0</span>     <span class="comment">//  null 尝试转型为number , 则为0 . 所以结果为 false, </span></span><br><span class="line"><span class="literal">null</span> &gt;= <span class="number">0</span>    <span class="comment">//  null 尝试转为number ,则为0 , 结果为 true. </span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>    <span class="comment">//  null在设计上，在此处不尝试转型. 所以 结果为false. </span></span><br></pre></td></tr></table></figure>
<p>这里引用一下 Franky大大的话。</p>
<blockquote>
<p>a &gt;&#x3D; b 运算符只是简单的去对 a &lt; b的结果取反. 我以为这是一个设计上的失误的另一个理由是 undefined,在标准中，被单拎出来.细心的你，也一定发现了这一点. 对于undefined的设计,  undefined &gt; 0  , undefined &lt; 0, undefined &#x3D;&#x3D; 0 的结果是符合设计上,逻辑的一致性的. 而null是被遗漏的东西.直到今天早上.我重新翻阅了ES3,5.相关章节. 才恍然大悟自己没有从根本上理解到这个问题.</p>
</blockquote>
<blockquote>
<p>虽然前面的例子,我catch到了BE当初的设计思想. 但是从全局的角度来看. 从关系运算符到相等运算符，尤其是相等运算符的设计上. 真的十分混乱不堪. BE在信中提到,他对 &#x3D;&#x3D; 的现状也很无奈. 甚至用愚蠢这个词来形容自己当初的实现(当然他还提到,当初只是为了在10天内设计出js,并跑过qa的测试用例). 即使如此, 但是他仍然表示 null &#x3D;&#x3D; 0 这个结果是他想要的.<br>　　　　<br>好吧,到了这里,我也有种无力感. 我认为纵观javascript，对关系运算和相等运算的设计.除了混乱,我想不出还有什么词来形容它们更恰当. 这一点从，我们生产环境代码中,大量的类型检查,和防御性代码的的存在,就可以证明这一点.</p>
</blockquote>
<p>同时 Franky大大还举了另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">case1</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">null</span>)&#123;</span><br><span class="line">          ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">case2</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">undefined</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 上面两组完全等价, 这就是一种不明确表述.</span></span><br><span class="line"><span class="comment">// 我们永远不知道代码编写者的目的到底是同时匹配null 和 undefined还是只匹配其中某一个</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">case3</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a === <span class="literal">null</span> || a === <span class="literal">undefined</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// case3 才是最好的表述. 我们明确知道代码编写者的意图. </span></span><br><span class="line"><span class="comment">// 即使很多人可能认为这个代码很愚蠢. 但我坚定的认为这才是好代码.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后, 不得不提到,我发出null &gt;&#x3D; 0 这封信后, Andrea Giammarchi 表示了对我之前看法的支持,他同我最初的看法一样,认为 null &gt;&#x3D; 0 的结果应该为 false . 并建议在 ES7 中的严格模式中,修改这个结果. 虽然同样遭到 David Bruant 的反对.  好吧为他和我的这个错误看法,默哀一分钟…</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>缓存的设计</title>
    <url>/2021/03/04/%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="缓存的设计"><a href="#缓存的设计" class="headerlink" title="缓存的设计"></a>缓存的设计</h1><p>数据库的性能相比而言比较差,当用户量上来以后就不能直接读数据库,否则会导致连接数超过数据库连接串数,出现大量的慢请求,而且大量的数据其实并不会频繁的更新数据,这个时候就可以使用缓存来优化速度.比如使用redis,redis的读写速度要快于MongoDB,使用redis不仅可以减少MongoDB压力,也可以加快接口响应速度.<br>用户先请求redis,如果有数据就直接返回,不再查询数据库,如果redis中没有再查询数据库</p>
<h2 id="缓存的读写策略"><a href="#缓存的读写策略" class="headerlink" title="缓存的读写策略"></a>缓存的读写策略</h2><p>redis和MongoDB中都有一份数据,那如果两端的数据不一致怎么办呢?</p>
<h3 id="Cache-Aside-策略"><a href="#Cache-Aside-策略" class="headerlink" title="Cache Aside 策略"></a>Cache Aside 策略</h3><p>如果先更新数据库后更新缓存,会出现什么问题呢?<br>在2个并发写请求时可能就会出现问题</p>
<span id="more"></span>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210304135321.png"><br>因为变更数据库和变更缓存是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据的不一致。</p>
<blockquote>
<p>这个时候我们可以使用缓存最常见的策略，Cache Aside 策略（也叫旁路缓存策略），这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的。</p>
</blockquote>
<h4 id="它可以分为读策略和写策略，其中读策略的步骤是："><a href="#它可以分为读策略和写策略，其中读策略的步骤是：" class="headerlink" title="它可以分为读策略和写策略，其中读策略的步骤是："></a>它可以分为读策略和写策略，其中读策略的步骤是：</h4><ol>
<li>从缓存中读取数据；</li>
<li>如果缓存命中，则直接返回数据；</li>
<li>如果缓存不命中，则从数据库中查询数据；</li>
<li>查询到数据后，将数据写入到缓存中，并且返回给用户。</li>
</ol>
<h4 id="写策略的步骤是："><a href="#写策略的步骤是：" class="headerlink" title="写策略的步骤是："></a>写策略的步骤是：</h4><ol>
<li>更新数据库中的记录；</li>
<li>删除缓存记录。</li>
</ol>
<h4 id="但是Cache-Aside-存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。"><a href="#但是Cache-Aside-存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。" class="headerlink" title="但是Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。"></a>但是Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。</h4><p>如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p>
<ol>
<li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li>
<li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li>
</ol>
<h3 id="Read-x2F-Write-Through（读穿-x2F-写穿）策略"><a href="#Read-x2F-Write-Through（读穿-x2F-写穿）策略" class="headerlink" title="Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略"></a>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</h3><blockquote>
<p>这个策略的核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。这就好比你在汇报工作的时候只对你的直接上级汇报，再由你的直接上级汇报给他的上级，你是不能越级汇报的。</p>
</blockquote>
<p>Write Through 的策略是这样的：先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做“Write Miss（写失效）”。</p>
<p>一般来说，我们可以选择两种“Write Miss”方式：一个是“Write Allocate（按写分配）”，做法是写入缓存相应位置，再由缓存组件同步更新到数据库中；另一个是“No-write allocate（不按写分配）”，做法是不写入缓存中，而是直接更新到数据库中。</p>
<p>这个策略需要有可靠性很强的组件去实现缓存到数据库同步这一步,可以将更新操作以命令的形式发送到消息队列中,让消费者去做数据库更新</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210304140614.png"></p>
<h3 id="Write-Back（写回）"><a href="#Write-Back（写回）" class="headerlink" title="Write Back（写回）"></a>Write Back（写回）</h3><blockquote>
<p>策略这个策略的核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。不推荐使用.</p>
</blockquote>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210304141436.png"></p>
<h2 id="缓存如何做到高可用"><a href="#缓存如何做到高可用" class="headerlink" title="缓存如何做到高可用"></a>缓存如何做到高可用</h2><h3 id="hash环"><a href="#hash环" class="headerlink" title="hash环"></a>hash环</h3><h3 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h3><h2 id="缓存的穿透-雪崩-击穿以及如何处理"><a href="#缓存的穿透-雪崩-击穿以及如何处理" class="headerlink" title="缓存的穿透,雪崩,击穿以及如何处理"></a>缓存的穿透,雪崩,击穿以及如何处理</h2><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><blockquote>
<p>缓存穿透其实是指从缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询的情况。</p>
</blockquote>
<p>不过少量的缓存穿透不可避免，对系统也是没有损害的，主要有几点原因:</p>
<ul>
<li>一方面，互联网系统通常会面临极大数据量的考验，而缓存系统在容量上是有限的，不可能存储系统所有的数据，那么在查询未缓存数据的时候就会发生缓存穿透。</li>
<li>另一方面，互联网系统的数据访问模型一般会遵从“80&#x2F;20 原则”。“80&#x2F;20 原则”又称为帕累托法则，是意大利经济学家帕累托提出的一个经济学的理论。简单来说，它是指在一组事物中，最重要的部分通常只占 20%，而其他的 80% 并没有那么重要。把它应用到数据访问的领域，就是我们会经常访问 20% 的热点数据，而另外的 80% 的数据则不会被经常访问。比如你买了很多衣服，很多书，但是其实经常穿的、经常看的可能也就是其中很小的一部分。</li>
</ul>
<p>但是如果要读取一个用户表中未注册的用户，会发生什么情况呢？我们会先读缓存再穿透读数据库。由于用户并不存在，所以缓存和数据库中都没有查询到数据，因此也就不会向缓存中回种数据（也就是向缓存中设置值的意思），<strong>这样当再次请求这个用户数据的时候还是会再次穿透到数据库</strong>。在这种场景下缓存并不能有效地阻挡请求穿透到数据库上，它的作用就微乎其微了。那如何解决缓存穿透呢？一般来说我们会有两种解决方案：回种空值以及使用布隆过滤器。</p>
<h4 id="回种空值"><a href="#回种空值" class="headerlink" title="回种空值"></a>回种空值</h4><p>回顾上面提到的场景，你会发现最大的问题在于数据库中并不存在用户的数据，这就造成无论查询多少次数据库中永远都不会存在这个用户的数据，穿透永远都会发生。<br>类似的场景还有一些：比如由于代码的 bug 导致查询数据库的时候抛出了异常，这样可以认为从数据库查询出来的数据为空，同样不会回种缓存。</p>
<p>那么，当我们从数据库中查询到空值或者发生异常时，<strong>我们可以向缓存中回种一个空值</strong>。但是因为空值并不是准确的业务数据，并且会占用缓存的空间，所以我们会给这个空值加一个比较短的过期时间，让空值在短时间之内能够快速过期淘汰。这样空值存在的期间,就不会穿透到数据库层了.</p>
<p>回种空值虽然能够阻挡大量穿透的请求，但如果有大量获取未注册用户信息的请求，<strong>缓存内就会有有大量的空值缓存，也就会浪费缓存的存储空间</strong>，如果缓存空间被占满了，还会剔除掉一些已经被缓存的用户信息反而会造成缓存命中率的下降。所以这个方案，我建议你在使用的时候应该评估一下缓存容量是否能够支撑。如果需要大量的缓存节点来支持，那么就无法通过通过回种空值的方式来解决，这时你可以考虑使用布隆过滤器。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>原理:我们把集合中的每一个值按照提供的 Hash 算法算出对应的 Hash 值，然后将 Hash 值对数组长度取模后得到需要计入数组的索引值，并且将数组这个位置的值从 0 改成 1。在判断一个元素是否存在于这个集合中时，你只需要将这个元素按照相同的算法计算出索引值，如果这个位置的值为 1 就认为这个元素在集合中，否则则认为不在集合中。<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210304143325.png"></p>
<p>那么我们如何使用布隆过滤器来解决缓存穿透的问题呢？还是以存储用户信息的表为例进行讲解。首先我们初始化一个很大的数组，比方说长度为 20 亿的数组，接下来我们选择一个 Hash 算法，然后我们将目前现有的所有用户的 ID 计算出 Hash 值并且映射到这个大数组中，映射位置的值设置为 1，其它值设置为 0。<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210304110809.png"></p>
<p>布隆过滤器拥有极高的性能，无论是写入操作还是读取操作，时间复杂度都是 O(1) 是常量值。在空间上，相对于其他数据结构它也有很大的优势，比如，20 亿的数组需要 2000000000&#x2F;8&#x2F;1024&#x2F;1024 &#x3D; 238M 的空间，而如果使用数组来存储，假设每个用户 ID 占用 4 个字节的空间，那么存储 20 亿用户需要 2000000000 * 4 &#x2F; 1024 &#x2F; 1024 &#x3D; 7600M 的空间，是布隆过滤器的 32 倍。</p>
<h5 id="布隆过滤器的误判有一个特点，就是它只会出现“false-positive”的情况。这是什么意思呢？当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中时，它一定不在集合中。这一点非常适合解决缓存穿透的问题。"><a href="#布隆过滤器的误判有一个特点，就是它只会出现“false-positive”的情况。这是什么意思呢？当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中时，它一定不在集合中。这一点非常适合解决缓存穿透的问题。" class="headerlink" title="布隆过滤器的误判有一个特点，就是它只会出现“false positive”的情况。这是什么意思呢？当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中时，它一定不在集合中。这一点非常适合解决缓存穿透的问题。"></a>布隆过滤器的误判有一个特点，就是它只会出现“false positive”的情况。这是什么意思呢？当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中时，它一定不在集合中。这一点非常适合解决缓存穿透的问题。</h5><h5 id="不过任何事物都有两面性，布隆过滤器也不例外"><a href="#不过任何事物都有两面性，布隆过滤器也不例外" class="headerlink" title="不过任何事物都有两面性，布隆过滤器也不例外"></a>不过任何事物都有两面性，布隆过滤器也不例外</h5><p>它主要有两个缺陷：</p>
<ol>
<li>它在判断元素是否在集合中时是有一定错误几率的，比如它会把不是集合中的元素判断为处在集合中；这是由于hash算法的碰撞造成的.</li>
<li>不支持删除元素。</li>
</ol>
<p>关于布隆过滤器的使用上，有几个建议：</p>
<ol>
<li>选择多个 Hash 函数计算多个 Hash 值，这样可以减少误判的几率；</li>
<li>布隆过滤器会消耗一定的内存空间，所以在使用时需要评估你的业务场景下需要多大的内存，存储的成本是否可以接受。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于<strong>并发用户特别多</strong>，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
</blockquote>
<p><strong>解决方案：</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁<br>使用这2个方案都有一定的风险,第一种方案会造成内存的使用量大大增加;第二种在回写缓存的期间其他用户都会无法获取数据,而且也要小心死锁的问题.所以如果不是必要性的数据,尽量不要使用这种方案.</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是,缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
</ol>
<h2 id="缓存穿透总结"><a href="#缓存穿透总结" class="headerlink" title="缓存穿透总结"></a>缓存穿透总结</h2><p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me20210304144412.png"></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>网络通信基础</title>
    <url>/2020/03/24/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<blockquote>
<p>面对互联网的技术日新月异，所要掌握的东西也越来越多。</p>
</blockquote>
<h2 id="1-关于网络领域的知识（掌握和了解）"><a href="#1-关于网络领域的知识（掌握和了解）" class="headerlink" title="1.关于网络领域的知识（掌握和了解）"></a>1.关于网络领域的知识（掌握和了解）</h2><p>a) 协议：tcp、udp、multicast<br>b) IO (BIO、NIO、AIO)<br>c) Socket<br>d) NIO(Netty&#x2F;Mima)<br>e) 序列化和反序列化</p>
<h2 id="2-一个http请求，在整个网络中的请求过程"><a href="#2-一个http请求，在整个网络中的请求过程" class="headerlink" title="2.一个http请求，在整个网络中的请求过程"></a>2.一个http请求，在整个网络中的请求过程</h2><p>TCP 总共有四层模型：传输层、网络层、数据链路层、物理层</p>
<span id="more"></span>

<p>当应用程序用TCP传输数据时，数据被送入协议栈中，通过逐步分层，最终以一串比特流传送网络。其中每层都需要增加头部的信息。</p>
<ol>
<li>传输层：表示当前的协议头。使用的是TCP协议传输</li>
<li>网络层：增加ip头，IP地址是一个网卡在网络中的通讯地址</li>
<li>数据链路层：增加MAC头，表示这个数据包要发送到网卡地址；MAC地址是全局唯一的。</li>
<li>物理层：转化为比特流进行传输</li>
</ol>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200324142700.png"></p>
<p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上，同时去掉各层协议头，每层协议都要去检查协议标识，以确定接收的数据上层协议。</p>
<ol>
<li>物理层：当数据通过网卡的时候，判断是否需要上传</li>
<li>数据链路层：当拿到数据后，就要从摘到网络层的头，检查MAC地址和当前网卡的MAC是否匹配</li>
<li>网络层：当数据链路层的MAC匹配成功后，拿到IP头，判断IP地址是否和当前的匹配</li>
<li>传输层: 当IP头匹配成功，TCP头会携带端口，将报文交给指定的端口进程进行处理</li>
</ol>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200324142729.png"></p>
<h2 id="3-为什么有了MAC层还要继续走IP层"><a href="#3-为什么有了MAC层还要继续走IP层" class="headerlink" title="3.为什么有了MAC层还要继续走IP层"></a>3.为什么有了MAC层还要继续走IP层</h2><p>我们都知道MAC是全局唯一，就类似于人的身份证号一样，虽然人的身份证号是和户口地、出生时间有关，但是人是移动的，不能通过身份证号就能找到这个人再什么地方，mac地址类似，知道mac地址，并不能在网络中将数据发送给它，除非它和发送方在同一个网络内。所以要实现机器之间的通信，不仅仅需要mac地址，也必须需要ip地址。IP地址代表的是，当前机器在网络中的位置，通过ip层的寻找，就可以实现任意两台Internet上的机器之间的传输数据。</p>
<h2 id="4-什么是IP协议"><a href="#4-什么是IP协议" class="headerlink" title="4.什么是IP协议"></a>4.什么是IP协议</h2><p>TCP 和UDP 是两种著名的传输层的协议，它们都是使用IP作为网络层协议。IP协议提供了一组数据报文服务，每组分组报文都是由网络独立处理和分发。</p>
<h3 id="a-TCP-x2F-IP"><a href="#a-TCP-x2F-IP" class="headerlink" title="a) TCP&#x2F;IP"></a>a) TCP&#x2F;IP</h3><p>TCP协议能够检测和恢复IP层提供的主机到主机的通信中可能发生的报文丢失、重复及其他错误。TCP提供了一个可信赖的字节流通道，这样应用程序就不需要考虑这些问题。同时，TCP协议是一种面向连接的协议，在使用TCP进行通信之前，两个应用程序之间需要建立一个TCP连接，而这个连接有涉及到两台电脑需要完成握手消息的交换。</p>
<h3 id="b-UDP-x2F-IP"><a href="#b-UDP-x2F-IP" class="headerlink" title="b) UDP&#x2F;IP"></a>b) UDP&#x2F;IP</h3><p>UDP协议不会对IP层产生的错误进行修复，而是简单的扩展了IP协议的数据报文服务，使它能够在应用程序之间工作，而不是在主机之间工作，因此使用UDP协议必须要考虑到报文丢失，顺序混乱的问题</p>
<h2 id="5-TCP如何做到可靠传输？"><a href="#5-TCP如何做到可靠传输？" class="headerlink" title="5.TCP如何做到可靠传输？"></a>5.TCP如何做到可靠传输？</h2><h4 id="a-建立可靠的连接"><a href="#a-建立可靠的连接" class="headerlink" title="a)建立可靠的连接"></a>a)建立可靠的连接</h4><p>由于TCP协议是一个种可信的传输协议，所以在传输之前，需要通过三次握手建立一个连接，所谓的三次握手，就是在建立TCP链接时，需要客户端和服务端总共发送3个包来确认连接的建立</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200324142748.png"></p>
<h3 id="b-断开连接（TCP四次挥手协议）"><a href="#b-断开连接（TCP四次挥手协议）" class="headerlink" title="b) 断开连接（TCP四次挥手协议）"></a>b) 断开连接（TCP四次挥手协议）</h3><p>四次挥手表示TCP断开连接的时候，需要客户端和服务端总共发送4个包来确认连接的断开；客户端和服务器均可主动发起挥手动作（TCP是一个全双工协议），在socket编程中，任何一方执行close()操作既可产生挥手操作。</p>
<p><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200324142800.png"></p>
<h3 id="c-为什么连接三次握手、关闭四次挥手"><a href="#c-为什么连接三次握手、关闭四次挥手" class="headerlink" title="c)为什么连接三次握手、关闭四次挥手"></a>c)为什么连接三次握手、关闭四次挥手</h3><p>三次握手是因为当Server端收到Client端SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答，SYN报文是用来同步的，第三次发送的时候，客户发送一个确认包，告诉服务端已经建立连接。但是关闭连接是，当Server端接收到FIN报文时，很可能并不会立即关闭SOCKET(因为还有消息没有处理完），所以只能先回复一个ACK报文，告诉CLient端，“你发的FIN报文我收到了”。只有等到我Server端所有报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。</p>
<h2 id="6-滑动窗口协议"><a href="#6-滑动窗口协议" class="headerlink" title="6.滑动窗口协议"></a>6.滑动窗口协议</h2><p>当建立可靠连接以后，就开始进行数据传输，在通信过程中，最重要的就是数据包，也就是协议传输的数据。如果数据的传送方和接收方出现来不及接收的情况，就会出现数据的丢失。因此利用滑动窗口机制，很有效的在TCP连接上实现对发送发流量控制。TCP的窗口单位是字节，不是报文段，发送方的的发送窗口不能超过接收方给出的窗口。</p>
<p>原文链接：<a href="https://blog.csdn.net/moon1107gitana/article/details/80896868">https://blog.csdn.net/moon1107gitana/article/details/80896868</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>苹果App主体迁移</title>
    <url>/2020/11/26/%E8%8B%B9%E6%9E%9C%E4%B8%BB%E4%BD%93%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="苹果App主体迁移"><a href="#苹果App主体迁移" class="headerlink" title="苹果App主体迁移"></a>苹果App主体迁移</h1><h2 id="苹果App主体迁移-苹果登录"><a href="#苹果App主体迁移-苹果登录" class="headerlink" title="苹果App主体迁移-苹果登录"></a>苹果App主体迁移-苹果登录</h2><h2 id="迁移流程图"><a href="#迁移流程图" class="headerlink" title="迁移流程图"></a>迁移流程图</h2><p>![](<a href="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me%E8%8B%B9%E6%9E%9C%E4%B8%BB%E4%BD%93%E8%BF%81%E7%A7%BB">https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me苹果主体迁移</a> 流程图 .png)</p>
<h2 id="迁移前操作"><a href="#迁移前操作" class="headerlink" title="迁移前操作"></a>迁移前操作</h2><blockquote>
<p>获取苹果转移标识符 transfer_sub <a href="https://developer.apple.com/documentation/sign_in_with_apple/transferring_your_apps_and_users_to_another_team">苹果官方文档</a></p>
</blockquote>
<h3 id="客户端提供参数："><a href="#客户端提供参数：" class="headerlink" title="客户端提供参数："></a>客户端提供参数：</h3><ol>
<li>client_id</li>
<li>team_id</li>
<li>key_id</li>
<li>苹果p8文件</li>
<li>recipient_team_id</li>
</ol>
<h3 id="后端操作步骤"><a href="#后端操作步骤" class="headerlink" title="后端操作步骤"></a>后端操作步骤</h3><ol>
<li>获取client_secret,有效期可配置</li>
<li>获取accessToken,缓存一小时</li>
<li>获取转移标识符transfer_sub,并入库</li>
</ol>
<span id="more"></span>
<h3 id="获取client-secret"><a href="#获取client-secret" class="headerlink" title="获取client_secret"></a>获取client_secret</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用ruby fileName.rb执行以下代码，获取client_secret</span></span><br><span class="line"><span class="comment"># 需安装jwt</span></span><br><span class="line"><span class="comment"># gem install jwt -v 1.5.4</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&quot;jwt&quot;</span></span><br><span class="line">key_file = <span class="string">&quot;AuthKey_xxxxx.p8&quot;</span> <span class="comment"># 客户端提供的p8文件路径</span></span><br><span class="line">team_id = <span class="string">&quot;team_id&quot;</span></span><br><span class="line">client_id = <span class="string">&quot;bundle_id&quot;</span></span><br><span class="line">key_id = <span class="string">&quot;key_id&quot;</span></span><br><span class="line">validity_period = <span class="number">180</span></span><br><span class="line">private_key = <span class="title class_">OpenSSL::PKey::EC</span>.new <span class="variable constant_">IO</span>.read key_file</span><br><span class="line">token = <span class="variable constant_">JWT</span>.encode(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="symbol">iss:</span> team_id,</span><br><span class="line">    <span class="symbol">iat:</span> Time.now.to_i,</span><br><span class="line">    <span class="symbol">exp:</span> Time.now.to_i + <span class="number">86400</span> * validity_period,</span><br><span class="line">    <span class="symbol">aud:</span> <span class="string">&quot;https://appleid.apple.com&quot;</span>,</span><br><span class="line">    <span class="symbol">sub:</span> client_id</span><br><span class="line">  &#125;,</span><br><span class="line">  private_key,</span><br><span class="line">  <span class="string">&quot;ES256&quot;</span>,</span><br><span class="line">  header_fields=</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="symbol">kid:</span> key_id </span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">puts token</span><br></pre></td></tr></table></figure>

<h3 id="获取AccessToken"><a href="#获取AccessToken" class="headerlink" title="获取AccessToken"></a>获取AccessToken</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --location --request POST &#x27;http://appleid.apple.com/auth/token?grant_type=client_credentials&amp;scope=user.migration&amp;client_id=&#123;bundleId&#125;&amp;client_secret=&#123;刚刚上面生成的client_secret&#125;&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \</span><br><span class="line">--data-raw &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新加坡请求苹果服务器耗时大概是1000ms</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getAppleAccessToken</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = redisKey.<span class="property">string</span>.<span class="property">appleAccessToken</span>;</span><br><span class="line">    <span class="keyword">let</span> accessToken = <span class="keyword">await</span> redis.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!accessToken) &#123;</span><br><span class="line">        <span class="keyword">const</span> startTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">        <span class="keyword">const</span> bundleId = <span class="string">&#x27;bundle_id&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> clientSecret = <span class="string">&#x27;clientSecret&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`http://appleid.apple.com/auth/token?grant_type=client_credentials&amp;scope=user.migration&amp;client_id=<span class="subst">$&#123;bundleId&#125;</span>&amp;client_secret=<span class="subst">$&#123;clientSecret&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> options = &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">uri</span>: url,</span><br><span class="line">            <span class="attr">followAllRedirects</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">followOriginalHttpMethod</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">request</span>(options).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> endTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">access_token</span>) &#123;</span><br><span class="line">            <span class="comment">// 苹果accessToken有效期1小时,不会覆盖,不会因为生成新的,导致旧的token失效</span></span><br><span class="line">            accessToken = result.<span class="property">access_token</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`新生成accessToken <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(result)&#125;</span>`</span>, <span class="string">&#x27;耗时&#x27;</span>, endTime - startTime);</span><br><span class="line">            <span class="keyword">await</span> redis.<span class="title function_">set</span>(key, accessToken, <span class="string">&#x27;EX&#x27;</span>, <span class="number">3600</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accessToken;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="获取转移标识符transfer-sub"><a href="#获取转移标识符transfer-sub" class="headerlink" title="获取转移标识符transfer_sub"></a>获取转移标识符transfer_sub</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --location --request POST &#x27;http://appleid.apple.com/auth/usermigrationinfo?sub=&#123;用户苹果登录时传的appleUserId&#125;&amp;target=&#123;target_id&#125;&amp;client_id=&#123;bundleId&#125;&amp;client_secret=&#123;&#123;刚刚上面的上面生成的client_secret&#125;&#125;&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \</span><br><span class="line">--header &#x27;Authorization: Bearer &#123;刚刚上面获取的accesstoken&#125;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新加坡请求苹果服务器耗时大概是1000ms</span><br><span class="line">const getTransferSub = async (appleUserId, token) =&gt; &#123;</span><br><span class="line">    const startTime = new Date().getTime();</span><br><span class="line">    const bundleId = &#x27;bundle_id&#x27;; // App的bundle_id</span><br><span class="line">    const targetId = &#x27;targetId&#x27;; // 接收App的团队id,recipient_team_id</span><br><span class="line">    const clientSecret = &#x27;clientSecret&#x27;;</span><br><span class="line">    const url = `http://appleid.apple.com/auth/usermigrationinfo?sub=$&#123;appleUserId&#125;&amp;target=$&#123;targetId&#125;&amp;client_id=$&#123;bundleId&#125;&amp;client_secret=$&#123;clientSecret&#125;`;</span><br><span class="line">    const options = &#123;</span><br><span class="line">        method: &#x27;POST&#x27;,</span><br><span class="line">        uri: url,</span><br><span class="line">        followAllRedirects: true,</span><br><span class="line">        followOriginalHttpMethod: true,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,</span><br><span class="line">            &#x27;Authorization&#x27;: `Bearer $&#123;token&#125;`</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const data = await request(options).catch((err) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;获取TransferSub失败&#x27;, JSON.stringify(err), err.message, redisKey.string.appleAccessToken); // 有部分用户可能取消了苹果登录的授权,所以会失败</span><br><span class="line">        throw new Error(&#x27;getTransferSubError&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    const endTime = new Date().getTime();</span><br><span class="line">    console.log(`获取TransferSub $&#123;data&#125;`, &#x27;耗时&#x27;, endTime - startTime);</span><br><span class="line">    const result = JSON.parse(data);</span><br><span class="line">    if (result.error) &#123;</span><br><span class="line">        console.log(&#x27;token过期&#x27;, result.error, redisKey.string.appleAccessToken);</span><br><span class="line">        // token过期,删除原来的缓存</span><br><span class="line">        await redis.del(redisKey.string.appleAccessToken);</span><br><span class="line">        throw new Error(&#x27;token_expires&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.transfer_sub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="通过队列消费任务"><a href="#通过队列消费任务" class="headerlink" title="通过队列消费任务"></a>通过队列消费任务</h3><blockquote>
<p>我这边最多使用了30个容器同时消费,并没有被苹果因为QPS的原因拒绝</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.addSetup(async function(channel) &#123;</span><br><span class="line">    const prefetch = parseInt(process.env.prefetch) || 1;</span><br><span class="line">    await channel.assertQueue(&#x27;apple.login.userId.record&#x27;, &#123; durable: true &#125;);</span><br><span class="line">    await channel.prefetch(prefetch);</span><br><span class="line">    channel.setConfig(&#123;</span><br><span class="line">        DEAD_LETTER_TTLs: [5, 10, 30], // 重试配置</span><br><span class="line">    &#125;);</span><br><span class="line">    await channel.consumerQueue(&#x27;apple.login.userId.record&#x27;, async function(data) &#123;</span><br><span class="line">        console.log(&#x27;苹果登录用户转移标识符记录:&#x27;, JSON.stringify(data.username));</span><br><span class="line">        await recordUserAppleTransferSub(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">const recordUserAppleTransferSub = async (data) =&gt; &#123;</span><br><span class="line">    const appleUserId = data.username;</span><br><span class="line">    if (appleUserId) &#123;</span><br><span class="line">        const accessToken = await getAppleAccessToken();</span><br><span class="line">        if (accessToken) &#123;</span><br><span class="line">            let transferSub = await getTransferSubByAppleUserId(appleUserId);</span><br><span class="line">            if (!transferSub) &#123;</span><br><span class="line">                transferSub = await getTransferSub(appleUserId, accessToken);</span><br><span class="line">                await updateTransferSubUserData(appleUserId, transferSub);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&#x27;该用户已经获取了transferSub&#x27;, JSON.stringify(transferSub), appleUserId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迁移后"><a href="#迁移后" class="headerlink" title="迁移后"></a>迁移后</h2><blockquote>
<p>获取新的appleUserId <a href="https://developer.apple.com/documentation/sign_in_with_apple/bringing_new_apps_and_users_into_your_team">苹果官方文档</a></p>
</blockquote>
<h3 id="客户端提供参数：-1"><a href="#客户端提供参数：-1" class="headerlink" title="客户端提供参数："></a>客户端提供参数：</h3><ol>
<li>client_id</li>
<li>team_id</li>
<li>key_id</li>
<li>苹果p8文件</li>
</ol>
<h3 id="后端操作步骤-1"><a href="#后端操作步骤-1" class="headerlink" title="后端操作步骤"></a>后端操作步骤</h3><ol>
<li>获取client_secret,有效期可配置</li>
<li>获取accessToken,缓存一小时</li>
<li>通过transfer_sub和token,获取新的AppleUserId,并入库</li>
</ol>
<h3 id="获取新的client-secret"><a href="#获取新的client-secret" class="headerlink" title="获取新的client_secret"></a>获取新的client_secret</h3><p>客户端提供新的参数,使用之前的脚本获取client_secret</p>
<h3 id="获取AccessToken-1"><a href="#获取AccessToken-1" class="headerlink" title="获取AccessToken"></a>获取AccessToken</h3><p>使用新的client_secret获取AccessToken</p>
<h3 id="获取新的AppleUserId-遍历之前的苹果登录转移标识符表"><a href="#获取新的AppleUserId-遍历之前的苹果登录转移标识符表" class="headerlink" title="获取新的AppleUserId(遍历之前的苹果登录转移标识符表)"></a>获取新的AppleUserId(遍历之前的苹果登录转移标识符表)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --location --request POST &#x27;http://appleid.apple.com/auth/usermigrationinfo?transfer_sub=&#123;transfer_sub&#125;&amp;client_id=&#123;bundleId&#125;&amp;client_secret=&#123;&#123;刚刚上面的上面生成的client_secret&#125;&#125;&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \</span><br><span class="line">--header &#x27;Authorization: Bearer &#123;刚刚上面获取的accesstoken&#125;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const getNewAppleUserId = async (transferSub, token) =&gt; &#123;</span><br><span class="line">    const startTime = new Date().getTime();</span><br><span class="line">    const bundleId = &#x27;bundle_id&#x27;;</span><br><span class="line">    const url = `http://appleid.apple.com/auth/usermigrationinfo?transfer_sub=$&#123;transferSub&#125;&amp;client_id=$&#123;bundleId&#125;&amp;client_secret=$&#123;clientSecret&#125;`;</span><br><span class="line">    const options = &#123;</span><br><span class="line">        method: &#x27;POST&#x27;,</span><br><span class="line">        uri: url,</span><br><span class="line">        followAllRedirects: true,</span><br><span class="line">        followOriginalHttpMethod: true,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,</span><br><span class="line">            &#x27;Authorization&#x27;: `Bearer $&#123;token&#125;`</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const data = await request(options).catch((err) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;获取NewAppleUserId失败&#x27;, JSON.stringify(err), err.message, redisKey.string.appleAccessToken);</span><br><span class="line">        throw new Error(&#x27;getNewAppleUserId&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    const endTime = new Date().getTime();</span><br><span class="line">    console.log(`获取NewAppleUserId $&#123;data&#125;`, &#x27;耗时&#x27;, `$&#123;endTime - startTime&#125;ms`);</span><br><span class="line">    const result = JSON.parse(data);</span><br><span class="line">    if (result.error) &#123;</span><br><span class="line">        console.log(&#x27;token过期&#x27;, result.error, redisKey.string.appleAccessToken);</span><br><span class="line">        await redis.del(redisKey.string.appleAccessToken);</span><br><span class="line">        throw new Error(&#x27;token_expires&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.sub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="将新AppleUserId入库-建立新旧AppleUserId的映射关系"><a href="#将新AppleUserId入库-建立新旧AppleUserId的映射关系" class="headerlink" title="将新AppleUserId入库,建立新旧AppleUserId的映射关系"></a>将新AppleUserId入库,建立新旧AppleUserId的映射关系</h3><p>在用户表中新增newAppleUserId字段,建立<strong>部分索引</strong><br>当用户调用苹果登录时,先判断用户客户端是否为新版客户端,如果是则查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctx.model.User.findOne(&#123; $or: [&#123; username: appleUserId &#125;, &#123; newAppleUserId: appleUserId &#125;] &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="苹果App主题迁移-游客登录"><a href="#苹果App主题迁移-游客登录" class="headerlink" title="苹果App主题迁移-游客登录"></a>苹果App主题迁移-游客登录</h1><h2 id="客户端上报deviceId和openId"><a href="#客户端上报deviceId和openId" class="headerlink" title="客户端上报deviceId和openId"></a>客户端上报deviceId和openId</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.router.post(&#x27;/apple_device_guest&#x27;, app.controller.device.openIdAndDeviceId); // 苹果主体迁移临时记录</span><br></pre></td></tr></table></figure>

<h2 id="客户端通过deviceId获取openId"><a href="#客户端通过deviceId获取openId" class="headerlink" title="客户端通过deviceId获取openId"></a>客户端通过deviceId获取openId</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.router.get(&#x27;/apple_device_guest&#x27;, app.controller.device.getOpenIdByDeviceId); // 获取openId</span><br></pre></td></tr></table></figure>

<p>##新版游客登录</p>
<ol>
<li>判断客户端版本是否是在迁移后的新版</li>
<li>是的话先通过IDFA(deviceId)获取openId</li>
<li>通过openId找到原来的账号进行登录</li>
<li>如果没有IDFA则注册新账号进行登录</li>
</ol>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>google服务</title>
    <url>/2019/04/25/%E8%B0%B7%E6%AD%8C%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="google服务"><a href="#google服务" class="headerlink" title="google服务"></a>google服务</h1><h2 id="谷歌登录"><a href="#谷歌登录" class="headerlink" title="谷歌登录"></a>谷歌登录</h2><p>谷歌登录只需要 clientId.客户端会获取到 idToken,发送给后端以后,后端拿 idToken请求谷歌,谷歌会解析出这个 Google 账号的信息,其中azp参数就是 clientId,与本地的 clientId 对比,校验这个账号是不是本应用登录的.是的话就创建账号或登录,返回账号信息给客户端.</p>
<h2 id="谷歌支付"><a href="#谷歌支付" class="headerlink" title="谷歌支付"></a>谷歌支付</h2><p>谷歌支付需要的参数:</p>
<ul>
<li>clientId</li>
<li>clientSecret</li>
<li>googlePublicKey</li>
<li>最麻烦的refreshToken</li>
</ul>
<p>其中 clientId 和 clientSecret还有googlePublicKey在谷歌开发者后台可以拿到.<br>refreshToken 需要一连串的流程</p>
<span id="more"></span>

<p>1.生成Code:</p>
<h3 id="这个code-只能用一次"><a href="#这个code-只能用一次" class="headerlink" title="这个code 只能用一次!!!"></a>这个code 只能用一次!!!</h3><p><a href="https://accounts.google.com/o/oauth2/auth?scope=https://www.googleapis.com/auth/androidpublisher&amp;response_type=code&amp;access_type=offline&amp;redirect_uri=%7Byour_web_index%7D&amp;client_id=%7Byour_client_id%7D">https://accounts.google.com/o/oauth2/auth?scope=https://www.googleapis.com/auth/androidpublisher&amp;response_type=code&amp;access_type=offline&amp;redirect_uri={your_web_index}&amp;client_id={your_client_id}</a><br>访问成功后会弹出一个对话框，点击同意即可，如果你没有登录，请登录您被开发者邀请共同开发且已经授权的帐号，切记这里的帐号一定是在Google Pay Control中可以查到的并已经授于访问权限的。接下来浏览器会定位到你的Web Index页面。并在浏览器地址上多出了?code&#x3D;……的字符串，取出这个code。</p>
<p>2.获取Refresh Token:</p>
<h3 id="首先要注意-refreshToken-只有在第一次请求的时候会返回-以后请求都不会有了-所以请妥善保存"><a href="#首先要注意-refreshToken-只有在第一次请求的时候会返回-以后请求都不会有了-所以请妥善保存" class="headerlink" title="首先要注意,refreshToken 只有在第一次请求的时候会返回,以后请求都不会有了,所以请妥善保存"></a>首先要注意,refreshToken 只有在第一次请求的时候会返回,以后请求都不会有了,所以请妥善保存</h3><p>请求 <strong>POST</strong> <a href="https://accounts.google.com/o/oauth2/token">https://accounts.google.com/o/oauth2/token</a><br>参数放在body 里,用 x-www-form-urlencoded 方式</p>
<table>
<thead>
<tr>
<th align="center">params</th>
<th align="center">data</th>
</tr>
</thead>
<tbody><tr>
<td align="center">code</td>
<td align="center">{your_code}</td>
</tr>
<tr>
<td align="center">client_id</td>
<td align="center">{your_client_id}</td>
</tr>
<tr>
<td align="center">client_secret</td>
<td align="center">{your_client_secret}</td>
</tr>
<tr>
<td align="center">redirect_uri</td>
<td align="center">{you_redirect_url}</td>
</tr>
<tr>
<td align="center">grant_type</td>
<td align="center">authorization_code</td>
</tr>
</tbody></table>
<p>因为这个是请求谷歌 API 的,所以是需要翻墙的,而本地请求postman App 和 iterm2 都是没有走 ss 代理的,所以都没法访问,需要使用 postman 的 Chrome 应用,并且安装<strong>Postman Interceptor</strong>插件.<br>访问格式是这样:<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200302163732.png"></p>
<p>这样就会返回:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;&#123;&#123;access_token&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">3600</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#123;refresh_token&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[https://www.googleapis.com/auth/androidpublisher](https://www.googleapis.com/auth/androidpublisher)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bearer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>到这里就获得了 refreshToken.</p>
<h3 id="当获得了这些所需的就可以去申请商品-由客户端发起内购了-但是要注意-商品的申请一定要在谷歌开发者账号关联-client-之前-否则就会报错"><a href="#当获得了这些所需的就可以去申请商品-由客户端发起内购了-但是要注意-商品的申请一定要在谷歌开发者账号关联-client-之前-否则就会报错" class="headerlink" title="当获得了这些所需的就可以去申请商品,由客户端发起内购了.但是要注意,商品的申请一定要在谷歌开发者账号关联 client 之前.否则就会报错"></a>当获得了这些所需的就可以去申请商品,由客户端发起内购了.但是要注意,商品的申请一定要在谷歌开发者账号关联 client 之前.否则就会报错</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">403</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The project id used to call the Google Play Developer API has not been linked in the Google Play Developer Console.&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span> <span class="string">&quot;androidpublisher&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The project id used to call the Google Play Developer API has not been linked in the Google Play Developer Console.&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;projectNotLinked&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果报这个错,并且已经确定开发者账号已经关联的应用,那可以重新申请商品试试.</p>
<h3 id="一个开发者账号下有多个App的情况有一个坑"><a href="#一个开发者账号下有多个App的情况有一个坑" class="headerlink" title="一个开发者账号下有多个App的情况有一个坑:"></a>一个开发者账号下有多个App的情况有一个坑:</h3><p>主要是Google Console的这个API权限，只能关联一个项目,所以谷歌支付的<strong>客户端ID</strong>和<strong>应用私钥</strong>参数都要配指定关联App的<br>只有谷歌公钥 (publishKey)是配各自App自己的<br><img src="https://hwl-1255548986.cos.ap-guangzhou.myqcloud.com/hwl.me/20200305182719.png"></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>限流算法</title>
    <url>/2021/03/04/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>总所周知服务器的承受能力是有限度的,当请求量超过承受量时,可能会导致服务器宕机,连原本能解决的请求都无法处理.就比如地铁,本来每分钟能运输一万人,但是突然有十万人一起涌进地铁站,导致站台过于拥挤,人们都无法顺利上车,结果就是连原本排在最前面的一万人都无法上地铁,这个时候就可以采取限流策略,限制进站人数,让地铁能顺利的将一批批的乘客送走.</p>
<h1 id="分层限流"><a href="#分层限流" class="headerlink" title="分层限流"></a>分层限流</h1><ol>
<li>限流总并发&#x2F;连接&#x2F;请求数</li>
<li>限制总资源数</li>
<li>限流某个接口的总并发&#x2F;请求数</li>
<li>限流某个接口的时间窗请求数</li>
<li>平滑限流某个接口的请求数：前面几个限流都不能很好的应对突发请求，即瞬间请求可能都被允许，从而导致一些问题（极限值请求），因此在一些场景中需要对突发请求进行整形，整形为平均速率请求处理（比如5r&#x2F;s，则每隔200ms处理一个请求，平滑了速率）。</li>
</ol>
<h1 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h1><p>限流策略主要有两大类共四种</p>
<ul>
<li>计数器限流<ul>
<li>固定窗口</li>
<li>滑动窗口</li>
</ul>
</li>
<li>桶限流<ul>
<li>令牌桶</li>
<li>漏桶</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="计数器固定窗口"><a href="#计数器固定窗口" class="headerlink" title="计数器固定窗口"></a>计数器固定窗口</h2><p>最容易想到的就是限制单位时间内的访问人数,当有一条请求进来时,计算器加1,当计数器数字到达阈值时,拒绝后续的请求.当计数周期达到后,计数器清零.比如QPS为10的话,可以使用秒级时间戳加上redis的inc实现,设置过期时间为1s.<br>但是有一个明显的弊端,就是固定窗口计数器算法无法处理突刺流量，比如10QPS，1ms中来了10个请求，后续的999ms的所有请求都会被拒绝。并且这1ms来了10个请求,服务器可能也无法并发的处理.</p>
<h2 id="计数器滑动窗口"><a href="#计数器滑动窗口" class="headerlink" title="计数器滑动窗口"></a>计数器滑动窗口</h2><p>为了解决这个问题,可以将窗口再细分,比如使用百毫秒级时间戳,既每100ms处理一个请求.同100ms为单位的时间内如果请求数量超过限制,也会触发限流处理策略.然后统计的时间范围随着时间的推移同步后移。<br>即便滑动时间窗口限流算法可以保证任意时间窗口内接口请求次数都不会超过最大限流值，但是仍然不能防止在细时间粒度上面访问过于集中的问题。<br>为了应对上面的问题，对于时间窗口限流算法，还有很多改进版本，比如：<br>多层次限流，我们可以对同一个接口设置多条限流规则，除了 1 秒不超过 100 次之外，我们还可以设置 100ms 不超过 20 次 (代码中实现写了平均的两倍)，两条规则同时限制，流量会更加平滑。</p>
<h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法就是服务器处理速度恒定,多余的请求可以被存储到水桶里,等待慢慢的流出,但是如果超过水桶的容纳极限,就会溢出,触发限流后续策略.<br>可以使用队列加固定数量消费者的方式来实现,请求都先发送到队列服务器中,让消费者去消费,如果队列中的任务堆积超过一定数量,可以”抛弃”请求,或者增加消费者数量.</p>
<h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>其实就是池化思想,服务器的连接串数量固定,每次请求进来时会从连接串里拿连接串,当用完时释放连接串,这个时候连接串又回到了连接池里.当连接池里的串都被用完时,后续进来的请求只能等待或者被丢弃.</p>
<h1 id="当触发了限流策略之后"><a href="#当触发了限流策略之后" class="headerlink" title="当触发了限流策略之后"></a>当触发了限流策略之后</h1><p>无论是使用哪种算法,都能可能超过当前限流的最大值,这个时候要怎么处理呢?<br>要根据业务场景具体分析,比如是获取用户头像这种不影响主业务的功能,完全可以丢弃,或者返回指定的错误码,让客户端过一段时间再重试.如果是客户端上报购买数据这种重要数据,可以将请求放到延迟队列中,过一段时间后再尝试消费.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>四种算法都有各自适用的场景,要根据业务情况具体分析.有可能是为了防止恶意请求,也可能是服务器处理不过来如此大的压力.如果是服务器无法处理这么大的流量时,还可以通过降级,甚至熔断来保护服务器</p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>对 DI（依赖注入） 和 IOC（控制反转） 的理解</title>
    <url>/2022/04/21/%E5%AF%B9%20DI%EF%BC%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%89%20%E5%92%8C%20IOC%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%89%20%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="对-DI（依赖注入）-和-IOC（控制反转）-的理解"><a href="#对-DI（依赖注入）-和-IOC（控制反转）-的理解" class="headerlink" title="对 DI（依赖注入） 和 IOC（控制反转） 的理解"></a>对 DI（依赖注入） 和 IOC（控制反转） 的理解</h1><p>简单来说，类A依赖类B，但A不控制B的创建和销毁，仅使用B，那么B的控制权则交给A之外处理，这叫控制反转（IOC）</p>
<h1 id="由于A依赖于B，因此在A中必然要使用B的实例，我们可以通过A的构造函数将B的实例注入。"><a href="#由于A依赖于B，因此在A中必然要使用B的实例，我们可以通过A的构造函数将B的实例注入。" class="headerlink" title="由于A依赖于B，因此在A中必然要使用B的实例，我们可以通过A的构造函数将B的实例注入。"></a>由于A依赖于B，因此在A中必然要使用B的<strong>实例</strong>，我们可以通过A的构造函数将B的<strong>实例</strong>注入。</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B &#123; &#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor(b: B) &#123; </span><br><span class="line">      console.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const b = new B();</span><br><span class="line">// 将B的实例注入到a中</span><br><span class="line">const a = new A(b);</span><br></pre></td></tr></table></figure>

<p>和原来的主要区别在于： <strong>之前是在 class A 之中实例化 B，现在是直接把实例作为参数传入。</strong></p>
<p>接下来我将通过代码的形式对比使用依赖注入相比非依赖注入的好处体现在哪。</p>
<h3 id="非依赖注入代码"><a href="#非依赖注入代码" class="headerlink" title="非依赖注入代码"></a>非依赖注入代码</h3><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引擎 </span><br><span class="line">export class Engine &#123;</span><br><span class="line">  public cylinders = &#x27;引擎发动机1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">// 轮胎</span><br><span class="line">export class Tires &#123;</span><br><span class="line">  public make = &#x27;品牌&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Car &#123;</span><br><span class="line">  public engine: Engine;</span><br><span class="line">  public tires: Tires;</span><br><span class="line">  public description = &#x27;No DI&#x27;; </span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.engine = new Engine();</span><br><span class="line">    this.tires = new Tires();</span><br><span class="line">  &#125;</span><br><span class="line">  // Method using the engine and tires</span><br><span class="line">  drive() &#123;</span><br><span class="line">    return `$&#123;this.description&#125; car with ` +</span><br><span class="line">      `$&#123;this.engine.cylinders&#125; cylinders and $&#123;this.tires.make&#125; tires.`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，Car类没有通过第三方容器而是亲自创建了一个引擎（engine）和一些轮胎（tires），这样的代码耦合度比较高，这样会存在以下问题：</p>
<h4 id="问题1：如果有一天对引擎进行升级，代码如下："><a href="#问题1：如果有一天对引擎进行升级，代码如下：" class="headerlink" title="问题1：如果有一天对引擎进行升级，代码如下："></a>问题1：如果有一天对引擎进行升级，代码如下：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引擎  </span><br><span class="line">export class Engine &#123;</span><br><span class="line">  public cylinders = &#x27;&#x27;;</span><br><span class="line">  constructor(_cylinders:string) &#123;</span><br><span class="line">    this.cylinders = _cylinders;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建引擎的时候需要传入一个参数**，那么这时候就需要修改Car类里的new Engine(parameter)**，这样就导致修改Engine 类时同时需要去维护所有使用他的其他类，并且实际开发过程中，开发人员很可能不是同一个人，沟通和交流又需要成本。这就是耦合。</p>
<p>这里请思考一个问题：要怎么做才能使引擎升级的时候不需要修改Car类呢？（答案：DI）</p>
<h4 id="问题2：如果想在Car上使用不同品牌的轮胎，代码如下："><a href="#问题2：如果想在Car上使用不同品牌的轮胎，代码如下：" class="headerlink" title="问题2：如果想在Car上使用不同品牌的轮胎，代码如下："></a>问题2：如果想在Car上使用不同品牌的轮胎，代码如下：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 轮胎</span><br><span class="line">export class Tires &#123;</span><br><span class="line">  public make = &#x27;品牌&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Tires1 extends Tires &#123;</span><br><span class="line">  public make = &#x27;品牌1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Tires2 extends Tires &#123;</span><br><span class="line">  public make = &#x27;品牌2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Car &#123;</span><br><span class="line">   //。。。。。。其他代码省略。。。。。。。</span><br><span class="line">  public tires: Tires;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.tires = new Tires1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时又得重新修改Car的代码</p>
<h4 id="问题3：如何实现数据共享，比如说车联网，建立了一个Service数据中心，不同的Car通过Service实现数据通信以及数据共享，如果是通过在Car里new-Service的方式，是无法实现数据共享和通信的，因为不同Car里的Service不是同一个实例。"><a href="#问题3：如何实现数据共享，比如说车联网，建立了一个Service数据中心，不同的Car通过Service实现数据通信以及数据共享，如果是通过在Car里new-Service的方式，是无法实现数据共享和通信的，因为不同Car里的Service不是同一个实例。" class="headerlink" title="问题3：如何实现数据共享，比如说车联网，建立了一个Service数据中心，不同的Car通过Service实现数据通信以及数据共享，如果是通过在Car里new Service的方式，是无法实现数据共享和通信的，因为不同Car里的Service不是同一个实例。"></a>问题3：如何实现数据共享，比如说车联网，建立了一个Service数据中心，不同的Car通过Service实现数据通信以及数据共享，如果是通过在Car里new Service的方式，是无法实现数据共享和通信的，因为不同Car里的Service不是同一个实例。</h4><h4 id="问题4：测试比较难，根本无法测试。-在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自更多的依赖，在这样层层的依赖关系中，由于不能控制Car背后的隐藏依赖，要进行测试是比较难的，或者应该说，这样的代码是根本无法进行测试的。-比如说想同时测试不同品牌的轮子的car的性能，因为car里头的new已经写死了，因此无法做到。-比如说想同时测试不同参数的引擎的car的性能，因为car里头的new已经写死了，因此无法做到。"><a href="#问题4：测试比较难，根本无法测试。-在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自更多的依赖，在这样层层的依赖关系中，由于不能控制Car背后的隐藏依赖，要进行测试是比较难的，或者应该说，这样的代码是根本无法进行测试的。-比如说想同时测试不同品牌的轮子的car的性能，因为car里头的new已经写死了，因此无法做到。-比如说想同时测试不同参数的引擎的car的性能，因为car里头的new已经写死了，因此无法做到。" class="headerlink" title="问题4：测试比较难，根本无法测试。 在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自更多的依赖，在这样层层的依赖关系中，由于不能控制Car背后的隐藏依赖，要进行测试是比较难的，或者应该说，这样的代码是根本无法进行测试的。 比如说想同时测试不同品牌的轮子的car的性能，因为car里头的new已经写死了，因此无法做到。 比如说想同时测试不同参数的引擎的car的性能，因为car里头的new已经写死了，因此无法做到。"></a>问题4：测试比较难，根本无法测试。 在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自更多的依赖，在这样层层的依赖关系中，由于不能控制Car背后的隐藏依赖，要进行测试是比较难的，或者应该说，这样的代码是根本无法进行测试的。 比如说想同时测试不同品牌的轮子的car的性能，因为car里头的new已经写死了，因此无法做到。 比如说想同时测试不同参数的引擎的car的性能，因为car里头的new已经写死了，因此无法做到。</h4><h3 id="使用依赖注入（DI）"><a href="#使用依赖注入（DI）" class="headerlink" title="使用依赖注入（DI）"></a>使用依赖注入（DI）</h3><p>接下来将演示使用DI来解决以上的4个问题。 先看使用DI实现的car.ts代码： car.ts</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export class Engine &#123;</span><br><span class="line">  public cylinders = &#x27;引擎发动机1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Tires &#123;</span><br><span class="line">  public make = &#x27;品牌&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Tires1 extends Tires &#123;</span><br><span class="line">  public make = &#x27;品牌1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Tires2 extends Tires &#123;</span><br><span class="line">  public make = &#x27;品牌2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Car &#123;</span><br><span class="line">  public description = &#x27;DI&#x27;; </span><br><span class="line">  // 通过构造函数注入Engine和Tires</span><br><span class="line">  constructor(public engine: Engine, public tires: Tires) &#123;&#125;  </span><br><span class="line">  // Method using the engine and tires</span><br><span class="line">  drive() &#123;</span><br><span class="line">    return `$&#123;this.description&#125; car with ` +</span><br><span class="line">      `$&#123;this.engine.cylinders&#125; cylinders and $&#123;this.tires.make&#125; tires.`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，通过往构造函数中传入engine和tires来创建Car，**::Car类不再亲自创建engine和tires，而是消费它们::**，此时最大的好处就是engine和tires与Car解除了强耦的关系。在new Car的时候，可以传入任何类型的Engine和Tires，即 let car &#x3D; new Car(new Engine(),new Tires());</p>
<h4 id="解决问题1：如果有一天对引擎进行升级，代码如下："><a href="#解决问题1：如果有一天对引擎进行升级，代码如下：" class="headerlink" title="解决问题1：如果有一天对引擎进行升级，代码如下："></a>解决问题1：如果有一天对引擎进行升级，代码如下：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export class Engine &#123;</span><br><span class="line">  public cylinders = &#x27;&#x27;;</span><br><span class="line">  constructor(_cylinders:string) &#123;</span><br><span class="line">    this.cylinders = _cylinders;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建引擎的时候需要传入一个参数，<strong>这时候不需要修改Car类，只需要修改主程序即可。（原本我们需要先修改 Car 类，再修改主程序，现在只需要修改主程序）</strong></p>
<p>主程序代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    const car = new Car(new Engine(&#x27;引擎启动机2&#x27;), new Tires1());</span><br><span class="line">    car.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决问题2：如果想在Car上使用不同品牌的轮胎，代码如下："><a href="#解决问题2：如果想在Car上使用不同品牌的轮胎，代码如下：" class="headerlink" title="解决问题2：如果想在Car上使用不同品牌的轮胎，代码如下："></a>解决问题2：如果想在Car上使用不同品牌的轮胎，代码如下：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export class Tires &#123;</span><br><span class="line">  public make = &#x27;品牌&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Tire1 extends Tires &#123;</span><br><span class="line">  public make = &#x27;品牌1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Tire2 extends Tires &#123;</span><br><span class="line">  public make = &#x27;品牌2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">export class Car &#123;</span><br><span class="line">   //。。。。。。其他代码省略。。。。。。。</span><br><span class="line">  constructor(public engine: Engine, public tires: Tires) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不需要修改Car类，只需要修改主程序即可： 主程序代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  // 使用品牌1的轮胎</span><br><span class="line">  const car1 = new Car(new Engine(&#x27;引擎启动机1&#x27;), new Tires1());</span><br><span class="line">  car.drive();</span><br><span class="line">  // 使用品牌2的轮胎</span><br><span class="line">  const car2 = new Car(new Engine(&#x27;引擎启动机2&#x27;), new Tires2());</span><br><span class="line">  car.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决问题3：如何实现数据共享，比如说车联网，建立一个Service数据中心（就像angular的Service层，可以给多个component共享），不同的Car通过Service实现数据通信以及数据共享。-代码如下：-Service-ts"><a href="#解决问题3：如何实现数据共享，比如说车联网，建立一个Service数据中心（就像angular的Service层，可以给多个component共享），不同的Car通过Service实现数据通信以及数据共享。-代码如下：-Service-ts" class="headerlink" title="解决问题3：如何实现数据共享，比如说车联网，建立一个Service数据中心（就像angular的Service层，可以给多个component共享），不同的Car通过Service实现数据通信以及数据共享。 代码如下： Service.ts"></a>解决问题3：如何实现数据共享，比如说车联网，建立一个Service数据中心（就像angular的Service层，可以给多个component共享），不同的Car通过Service实现数据通信以及数据共享。 代码如下： Service.ts</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export class Service &#123;</span><br><span class="line">  public data = &#x27;&#x27;;</span><br><span class="line">  // 向Service存数据</span><br><span class="line">  setData(_data: string) &#123;</span><br><span class="line">    this.data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  // 从Service中取数据</span><br><span class="line">  getData() &#123;</span><br><span class="line">    return this.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cart.ts</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export class Car &#123;</span><br><span class="line">  constructor(public service: Service) &#123; &#125;</span><br><span class="line">  // 向Service存数据</span><br><span class="line">  setDataToService(_data: string) &#123;</span><br><span class="line">    this.service.setData(_data);</span><br><span class="line">  &#125;</span><br><span class="line">  // 从Service中取数据</span><br><span class="line">  getDataFromService() &#123;</span><br><span class="line">    return this.service.getData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时主程序如下： 主程序代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  // 创建一个共享服务中心Service</span><br><span class="line">  const shareService = new Service();</span><br><span class="line">  const car1 = new Car(shareService);</span><br><span class="line">  const car2 = new Car(shareService);</span><br><span class="line">  // car1向服务中心存数据</span><br><span class="line">  car1.setDataToService(&#x27;this data is from car1.&#x27;);</span><br><span class="line">  // car2从服务中心取数据</span><br><span class="line">  car2.getDataFromService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<p>作者：SimpleXD， 链接：<a href="https://juejin.cn/post/6844903740953067534">https://juejin.cn/post/6844903740953067534</a></p>
]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
  <entry>
    <title>面向切面编程（AOP）</title>
    <url>/2022/04/21/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%88AOP%EF%BC%89/</url>
    <content><![CDATA[<h1 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h1><p>首先 AOP 是一种编程方式</p>
<p>为了理解AOP的概念，我们先用OOP举例，比如一个业务组件<code>BookService</code>，它有几个业务方法：</p>
<ul>
<li>createBook：添加新的Book；</li>
<li>updateBook：修改Book；</li>
<li>deleteBook：删除Book；</li>
</ul>
<p>对每个业务方法，例如，<code>createBook()</code>，除了业务逻辑，还需要安全检查、日志记录和事务处理，它的代码像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    public void createBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        Transaction tx = startTransaction();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 核心业务逻辑</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(&quot;created book: &quot; + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续编写<code>updateBook()</code>，代码如下：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    public void updateBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        Transaction tx = startTransaction();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 核心业务逻辑</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(&quot;updated book: &quot; + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化。</p>
<p>考察业务模型可以发现，<code>BookService</code>关心的是自身的核心逻辑，但整个系统还要求关注安全检查、日志、事务等功能，这些功能实际上“横跨”多个业务方法，为了实现这些功能，不得不在每个业务方法上重复编写代码。</p>
<p>对于这种问题我们可以使用鉴权中间件的方式，统一检查权限。但是日志和 try catch 这就没法用中间件解决了。</p>
<p>另一种可行的方式是使用<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">Proxy模式</a>，将某个功能，例如，权限检查，放入Proxy中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SecurityCheckBookService implements BookService &#123;</span><br><span class="line">    private final BookService target;</span><br><span class="line"></span><br><span class="line">    public SecurityCheckBookService(BookService target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void securityCheck() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是先把核心代码写出来，然后再抽象出一个代理执行的类，对原先的类都加上统一的处理。这样做就很麻烦，原来一个类的事现在要先设计方法，然后拆分成 2 个类来写。但是其实每个方法要做的鉴权还是都要再写一遍。</p>
<p>然后我们就会想，反正鉴权，日志，错误处理这些事每个方法每个类都要做的，那不如把这些抽离出来，单独编写，然后再代码编译的时候，再自动的加进去，不需要程序员一个个写。::这就是面向切面编程了。::</p>
<blockquote>
<p>既然<code>SecurityCheckBookService</code>的代码都是标准的Proxy样板代码，不如把权限检查视作一种切面（Aspect），把日志、事务也视为切面，然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p>
</blockquote>
<p>如果我们以AOP的视角来编写上述业务，可以依次实现：</p>
<ol>
<li>核心逻辑，即BookService；</li>
<li>切面逻辑，即：<ol>
<li>权限检查的Aspect；</li>
<li>日志的Aspect；</li>
<li>事务的Aspect。</li>
</ol>
</li>
</ol>
<p>然后，以某种方式，让框架来把上述3个Aspect以Proxy的方式“织入”到<code>BookService</code>中，这样一来，就不必编写复杂而冗长的Proxy模式。这个植入的过程当然是用代码自动化的方式实现，不需要程序员去写，也不会表现在核心逻辑的代码里。</p>
<p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p>
<p>在Java平台上，对于AOP的织入，有3种方式：</p>
<ol>
<li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li>
<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li>
</ol>
<p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p>
<h4 id="AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。"><a href="#AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。" class="headerlink" title="AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。"></a>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</h4>]]></content>
      <categories>
        <category>TechDoc</category>
      </categories>
  </entry>
</search>
